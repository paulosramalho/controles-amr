
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Cliente
 * 
 */
export type Cliente = $Result.DefaultSelection<Prisma.$ClientePayload>
/**
 * Model OrdemPagamento
 * 
 */
export type OrdemPagamento = $Result.DefaultSelection<Prisma.$OrdemPagamentoPayload>
/**
 * Model Pagamento
 * 
 */
export type Pagamento = $Result.DefaultSelection<Prisma.$PagamentoPayload>
/**
 * Model Advogado
 * 
 */
export type Advogado = $Result.DefaultSelection<Prisma.$AdvogadoPayload>
/**
 * Model Repasse
 * 
 */
export type Repasse = $Result.DefaultSelection<Prisma.$RepassePayload>
/**
 * Model Estagiario
 * 
 */
export type Estagiario = $Result.DefaultSelection<Prisma.$EstagiarioPayload>
/**
 * Model PrestadorServico
 * 
 */
export type PrestadorServico = $Result.DefaultSelection<Prisma.$PrestadorServicoPayload>
/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model ConfiguracaoCalculo
 * 
 */
export type ConfiguracaoCalculo = $Result.DefaultSelection<Prisma.$ConfiguracaoCalculoPayload>
/**
 * Model ModeloDistribuicao
 * 
 */
export type ModeloDistribuicao = $Result.DefaultSelection<Prisma.$ModeloDistribuicaoPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ModeloPagamento: {
  AVISTA: 'AVISTA',
  ENTRADA_E_PARCELAS: 'ENTRADA_E_PARCELAS',
  PARCELAS: 'PARCELAS'
};

export type ModeloPagamento = (typeof ModeloPagamento)[keyof typeof ModeloPagamento]


export const StatusOrdem: {
  ATIVA: 'ATIVA',
  CONCLUIDA: 'CONCLUIDA',
  SUSPENSA: 'SUSPENSA',
  CANCELADA: 'CANCELADA'
};

export type StatusOrdem = (typeof StatusOrdem)[keyof typeof StatusOrdem]


export const StatusPagamento: {
  EM_ABERTO: 'EM_ABERTO',
  PAGO: 'PAGO',
  PARCIAL: 'PARCIAL',
  CANCELADO: 'CANCELADO'
};

export type StatusPagamento = (typeof StatusPagamento)[keyof typeof StatusPagamento]


export const TipoAdvogado: {
  SOCIO_PATRIMONIAL: 'SOCIO_PATRIMONIAL',
  SOCIO_SERVICO: 'SOCIO_SERVICO',
  ASSOCIADO: 'ASSOCIADO',
  CORRESPONDENTE: 'CORRESPONDENTE',
  OUTRO: 'OUTRO'
};

export type TipoAdvogado = (typeof TipoAdvogado)[keyof typeof TipoAdvogado]


export const OrigemRepasse: {
  INCIDENTAL: 'INCIDENTAL',
  MENSAL_RECORRENTE: 'MENSAL_RECORRENTE',
  DISTRIBUICAO_LUCRO: 'DISTRIBUICAO_LUCRO',
  OUTRA: 'OUTRA'
};

export type OrigemRepasse = (typeof OrigemRepasse)[keyof typeof OrigemRepasse]


export const PerfilUsuario: {
  ADMIN: 'ADMIN',
  FINANCEIRO: 'FINANCEIRO',
  OPERACIONAL: 'OPERACIONAL',
  LEITURA: 'LEITURA'
};

export type PerfilUsuario = (typeof PerfilUsuario)[keyof typeof PerfilUsuario]

}

export type ModeloPagamento = $Enums.ModeloPagamento

export const ModeloPagamento: typeof $Enums.ModeloPagamento

export type StatusOrdem = $Enums.StatusOrdem

export const StatusOrdem: typeof $Enums.StatusOrdem

export type StatusPagamento = $Enums.StatusPagamento

export const StatusPagamento: typeof $Enums.StatusPagamento

export type TipoAdvogado = $Enums.TipoAdvogado

export const TipoAdvogado: typeof $Enums.TipoAdvogado

export type OrigemRepasse = $Enums.OrigemRepasse

export const OrigemRepasse: typeof $Enums.OrigemRepasse

export type PerfilUsuario = $Enums.PerfilUsuario

export const PerfilUsuario: typeof $Enums.PerfilUsuario

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Clientes
 * const clientes = await prisma.cliente.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Clientes
   * const clientes = await prisma.cliente.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.cliente`: Exposes CRUD operations for the **Cliente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clientes
    * const clientes = await prisma.cliente.findMany()
    * ```
    */
  get cliente(): Prisma.ClienteDelegate<ExtArgs>;

  /**
   * `prisma.ordemPagamento`: Exposes CRUD operations for the **OrdemPagamento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrdemPagamentos
    * const ordemPagamentos = await prisma.ordemPagamento.findMany()
    * ```
    */
  get ordemPagamento(): Prisma.OrdemPagamentoDelegate<ExtArgs>;

  /**
   * `prisma.pagamento`: Exposes CRUD operations for the **Pagamento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pagamentos
    * const pagamentos = await prisma.pagamento.findMany()
    * ```
    */
  get pagamento(): Prisma.PagamentoDelegate<ExtArgs>;

  /**
   * `prisma.advogado`: Exposes CRUD operations for the **Advogado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Advogados
    * const advogados = await prisma.advogado.findMany()
    * ```
    */
  get advogado(): Prisma.AdvogadoDelegate<ExtArgs>;

  /**
   * `prisma.repasse`: Exposes CRUD operations for the **Repasse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Repasses
    * const repasses = await prisma.repasse.findMany()
    * ```
    */
  get repasse(): Prisma.RepasseDelegate<ExtArgs>;

  /**
   * `prisma.estagiario`: Exposes CRUD operations for the **Estagiario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Estagiarios
    * const estagiarios = await prisma.estagiario.findMany()
    * ```
    */
  get estagiario(): Prisma.EstagiarioDelegate<ExtArgs>;

  /**
   * `prisma.prestadorServico`: Exposes CRUD operations for the **PrestadorServico** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrestadorServicos
    * const prestadorServicos = await prisma.prestadorServico.findMany()
    * ```
    */
  get prestadorServico(): Prisma.PrestadorServicoDelegate<ExtArgs>;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs>;

  /**
   * `prisma.configuracaoCalculo`: Exposes CRUD operations for the **ConfiguracaoCalculo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConfiguracaoCalculos
    * const configuracaoCalculos = await prisma.configuracaoCalculo.findMany()
    * ```
    */
  get configuracaoCalculo(): Prisma.ConfiguracaoCalculoDelegate<ExtArgs>;

  /**
   * `prisma.modeloDistribuicao`: Exposes CRUD operations for the **ModeloDistribuicao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModeloDistribuicaos
    * const modeloDistribuicaos = await prisma.modeloDistribuicao.findMany()
    * ```
    */
  get modeloDistribuicao(): Prisma.ModeloDistribuicaoDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.20.0
   * Query Engine version: 06fc58a368dc7be9fbbbe894adf8d445d208c284
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Cliente: 'Cliente',
    OrdemPagamento: 'OrdemPagamento',
    Pagamento: 'Pagamento',
    Advogado: 'Advogado',
    Repasse: 'Repasse',
    Estagiario: 'Estagiario',
    PrestadorServico: 'PrestadorServico',
    Usuario: 'Usuario',
    ConfiguracaoCalculo: 'ConfiguracaoCalculo',
    ModeloDistribuicao: 'ModeloDistribuicao'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "cliente" | "ordemPagamento" | "pagamento" | "advogado" | "repasse" | "estagiario" | "prestadorServico" | "usuario" | "configuracaoCalculo" | "modeloDistribuicao"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Cliente: {
        payload: Prisma.$ClientePayload<ExtArgs>
        fields: Prisma.ClienteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClienteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClienteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          findFirst: {
            args: Prisma.ClienteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClienteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          findMany: {
            args: Prisma.ClienteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>[]
          }
          create: {
            args: Prisma.ClienteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          createMany: {
            args: Prisma.ClienteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClienteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>[]
          }
          delete: {
            args: Prisma.ClienteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          update: {
            args: Prisma.ClienteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          deleteMany: {
            args: Prisma.ClienteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClienteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClienteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          aggregate: {
            args: Prisma.ClienteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCliente>
          }
          groupBy: {
            args: Prisma.ClienteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClienteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClienteCountArgs<ExtArgs>
            result: $Utils.Optional<ClienteCountAggregateOutputType> | number
          }
        }
      }
      OrdemPagamento: {
        payload: Prisma.$OrdemPagamentoPayload<ExtArgs>
        fields: Prisma.OrdemPagamentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrdemPagamentoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdemPagamentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrdemPagamentoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdemPagamentoPayload>
          }
          findFirst: {
            args: Prisma.OrdemPagamentoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdemPagamentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrdemPagamentoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdemPagamentoPayload>
          }
          findMany: {
            args: Prisma.OrdemPagamentoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdemPagamentoPayload>[]
          }
          create: {
            args: Prisma.OrdemPagamentoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdemPagamentoPayload>
          }
          createMany: {
            args: Prisma.OrdemPagamentoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrdemPagamentoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdemPagamentoPayload>[]
          }
          delete: {
            args: Prisma.OrdemPagamentoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdemPagamentoPayload>
          }
          update: {
            args: Prisma.OrdemPagamentoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdemPagamentoPayload>
          }
          deleteMany: {
            args: Prisma.OrdemPagamentoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrdemPagamentoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrdemPagamentoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdemPagamentoPayload>
          }
          aggregate: {
            args: Prisma.OrdemPagamentoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrdemPagamento>
          }
          groupBy: {
            args: Prisma.OrdemPagamentoGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrdemPagamentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrdemPagamentoCountArgs<ExtArgs>
            result: $Utils.Optional<OrdemPagamentoCountAggregateOutputType> | number
          }
        }
      }
      Pagamento: {
        payload: Prisma.$PagamentoPayload<ExtArgs>
        fields: Prisma.PagamentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PagamentoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PagamentoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          findFirst: {
            args: Prisma.PagamentoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PagamentoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          findMany: {
            args: Prisma.PagamentoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>[]
          }
          create: {
            args: Prisma.PagamentoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          createMany: {
            args: Prisma.PagamentoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PagamentoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>[]
          }
          delete: {
            args: Prisma.PagamentoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          update: {
            args: Prisma.PagamentoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          deleteMany: {
            args: Prisma.PagamentoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PagamentoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PagamentoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          aggregate: {
            args: Prisma.PagamentoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePagamento>
          }
          groupBy: {
            args: Prisma.PagamentoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PagamentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PagamentoCountArgs<ExtArgs>
            result: $Utils.Optional<PagamentoCountAggregateOutputType> | number
          }
        }
      }
      Advogado: {
        payload: Prisma.$AdvogadoPayload<ExtArgs>
        fields: Prisma.AdvogadoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdvogadoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvogadoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdvogadoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvogadoPayload>
          }
          findFirst: {
            args: Prisma.AdvogadoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvogadoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdvogadoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvogadoPayload>
          }
          findMany: {
            args: Prisma.AdvogadoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvogadoPayload>[]
          }
          create: {
            args: Prisma.AdvogadoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvogadoPayload>
          }
          createMany: {
            args: Prisma.AdvogadoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdvogadoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvogadoPayload>[]
          }
          delete: {
            args: Prisma.AdvogadoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvogadoPayload>
          }
          update: {
            args: Prisma.AdvogadoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvogadoPayload>
          }
          deleteMany: {
            args: Prisma.AdvogadoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdvogadoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdvogadoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvogadoPayload>
          }
          aggregate: {
            args: Prisma.AdvogadoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdvogado>
          }
          groupBy: {
            args: Prisma.AdvogadoGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdvogadoGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdvogadoCountArgs<ExtArgs>
            result: $Utils.Optional<AdvogadoCountAggregateOutputType> | number
          }
        }
      }
      Repasse: {
        payload: Prisma.$RepassePayload<ExtArgs>
        fields: Prisma.RepasseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RepasseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepassePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RepasseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepassePayload>
          }
          findFirst: {
            args: Prisma.RepasseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepassePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RepasseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepassePayload>
          }
          findMany: {
            args: Prisma.RepasseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepassePayload>[]
          }
          create: {
            args: Prisma.RepasseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepassePayload>
          }
          createMany: {
            args: Prisma.RepasseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RepasseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepassePayload>[]
          }
          delete: {
            args: Prisma.RepasseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepassePayload>
          }
          update: {
            args: Prisma.RepasseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepassePayload>
          }
          deleteMany: {
            args: Prisma.RepasseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RepasseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RepasseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepassePayload>
          }
          aggregate: {
            args: Prisma.RepasseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRepasse>
          }
          groupBy: {
            args: Prisma.RepasseGroupByArgs<ExtArgs>
            result: $Utils.Optional<RepasseGroupByOutputType>[]
          }
          count: {
            args: Prisma.RepasseCountArgs<ExtArgs>
            result: $Utils.Optional<RepasseCountAggregateOutputType> | number
          }
        }
      }
      Estagiario: {
        payload: Prisma.$EstagiarioPayload<ExtArgs>
        fields: Prisma.EstagiarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EstagiarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstagiarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EstagiarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstagiarioPayload>
          }
          findFirst: {
            args: Prisma.EstagiarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstagiarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EstagiarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstagiarioPayload>
          }
          findMany: {
            args: Prisma.EstagiarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstagiarioPayload>[]
          }
          create: {
            args: Prisma.EstagiarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstagiarioPayload>
          }
          createMany: {
            args: Prisma.EstagiarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EstagiarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstagiarioPayload>[]
          }
          delete: {
            args: Prisma.EstagiarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstagiarioPayload>
          }
          update: {
            args: Prisma.EstagiarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstagiarioPayload>
          }
          deleteMany: {
            args: Prisma.EstagiarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EstagiarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EstagiarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EstagiarioPayload>
          }
          aggregate: {
            args: Prisma.EstagiarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEstagiario>
          }
          groupBy: {
            args: Prisma.EstagiarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<EstagiarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.EstagiarioCountArgs<ExtArgs>
            result: $Utils.Optional<EstagiarioCountAggregateOutputType> | number
          }
        }
      }
      PrestadorServico: {
        payload: Prisma.$PrestadorServicoPayload<ExtArgs>
        fields: Prisma.PrestadorServicoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrestadorServicoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorServicoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrestadorServicoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorServicoPayload>
          }
          findFirst: {
            args: Prisma.PrestadorServicoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorServicoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrestadorServicoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorServicoPayload>
          }
          findMany: {
            args: Prisma.PrestadorServicoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorServicoPayload>[]
          }
          create: {
            args: Prisma.PrestadorServicoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorServicoPayload>
          }
          createMany: {
            args: Prisma.PrestadorServicoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrestadorServicoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorServicoPayload>[]
          }
          delete: {
            args: Prisma.PrestadorServicoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorServicoPayload>
          }
          update: {
            args: Prisma.PrestadorServicoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorServicoPayload>
          }
          deleteMany: {
            args: Prisma.PrestadorServicoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrestadorServicoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PrestadorServicoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrestadorServicoPayload>
          }
          aggregate: {
            args: Prisma.PrestadorServicoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrestadorServico>
          }
          groupBy: {
            args: Prisma.PrestadorServicoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrestadorServicoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrestadorServicoCountArgs<ExtArgs>
            result: $Utils.Optional<PrestadorServicoCountAggregateOutputType> | number
          }
        }
      }
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      ConfiguracaoCalculo: {
        payload: Prisma.$ConfiguracaoCalculoPayload<ExtArgs>
        fields: Prisma.ConfiguracaoCalculoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConfiguracaoCalculoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracaoCalculoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConfiguracaoCalculoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracaoCalculoPayload>
          }
          findFirst: {
            args: Prisma.ConfiguracaoCalculoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracaoCalculoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConfiguracaoCalculoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracaoCalculoPayload>
          }
          findMany: {
            args: Prisma.ConfiguracaoCalculoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracaoCalculoPayload>[]
          }
          create: {
            args: Prisma.ConfiguracaoCalculoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracaoCalculoPayload>
          }
          createMany: {
            args: Prisma.ConfiguracaoCalculoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConfiguracaoCalculoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracaoCalculoPayload>[]
          }
          delete: {
            args: Prisma.ConfiguracaoCalculoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracaoCalculoPayload>
          }
          update: {
            args: Prisma.ConfiguracaoCalculoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracaoCalculoPayload>
          }
          deleteMany: {
            args: Prisma.ConfiguracaoCalculoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConfiguracaoCalculoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConfiguracaoCalculoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracaoCalculoPayload>
          }
          aggregate: {
            args: Prisma.ConfiguracaoCalculoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfiguracaoCalculo>
          }
          groupBy: {
            args: Prisma.ConfiguracaoCalculoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConfiguracaoCalculoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConfiguracaoCalculoCountArgs<ExtArgs>
            result: $Utils.Optional<ConfiguracaoCalculoCountAggregateOutputType> | number
          }
        }
      }
      ModeloDistribuicao: {
        payload: Prisma.$ModeloDistribuicaoPayload<ExtArgs>
        fields: Prisma.ModeloDistribuicaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModeloDistribuicaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModeloDistribuicaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModeloDistribuicaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModeloDistribuicaoPayload>
          }
          findFirst: {
            args: Prisma.ModeloDistribuicaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModeloDistribuicaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModeloDistribuicaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModeloDistribuicaoPayload>
          }
          findMany: {
            args: Prisma.ModeloDistribuicaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModeloDistribuicaoPayload>[]
          }
          create: {
            args: Prisma.ModeloDistribuicaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModeloDistribuicaoPayload>
          }
          createMany: {
            args: Prisma.ModeloDistribuicaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModeloDistribuicaoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModeloDistribuicaoPayload>[]
          }
          delete: {
            args: Prisma.ModeloDistribuicaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModeloDistribuicaoPayload>
          }
          update: {
            args: Prisma.ModeloDistribuicaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModeloDistribuicaoPayload>
          }
          deleteMany: {
            args: Prisma.ModeloDistribuicaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModeloDistribuicaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModeloDistribuicaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModeloDistribuicaoPayload>
          }
          aggregate: {
            args: Prisma.ModeloDistribuicaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModeloDistribuicao>
          }
          groupBy: {
            args: Prisma.ModeloDistribuicaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModeloDistribuicaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModeloDistribuicaoCountArgs<ExtArgs>
            result: $Utils.Optional<ModeloDistribuicaoCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ClienteCountOutputType
   */

  export type ClienteCountOutputType = {
    ordens: number
  }

  export type ClienteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ordens?: boolean | ClienteCountOutputTypeCountOrdensArgs
  }

  // Custom InputTypes
  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteCountOutputType
     */
    select?: ClienteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeCountOrdensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdemPagamentoWhereInput
  }


  /**
   * Count Type OrdemPagamentoCountOutputType
   */

  export type OrdemPagamentoCountOutputType = {
    pagamentos: number
    repasses: number
  }

  export type OrdemPagamentoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pagamentos?: boolean | OrdemPagamentoCountOutputTypeCountPagamentosArgs
    repasses?: boolean | OrdemPagamentoCountOutputTypeCountRepassesArgs
  }

  // Custom InputTypes
  /**
   * OrdemPagamentoCountOutputType without action
   */
  export type OrdemPagamentoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemPagamentoCountOutputType
     */
    select?: OrdemPagamentoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrdemPagamentoCountOutputType without action
   */
  export type OrdemPagamentoCountOutputTypeCountPagamentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagamentoWhereInput
  }

  /**
   * OrdemPagamentoCountOutputType without action
   */
  export type OrdemPagamentoCountOutputTypeCountRepassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RepasseWhereInput
  }


  /**
   * Count Type AdvogadoCountOutputType
   */

  export type AdvogadoCountOutputType = {
    repasses: number
  }

  export type AdvogadoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    repasses?: boolean | AdvogadoCountOutputTypeCountRepassesArgs
  }

  // Custom InputTypes
  /**
   * AdvogadoCountOutputType without action
   */
  export type AdvogadoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvogadoCountOutputType
     */
    select?: AdvogadoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdvogadoCountOutputType without action
   */
  export type AdvogadoCountOutputTypeCountRepassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RepasseWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Cliente
   */

  export type AggregateCliente = {
    _count: ClienteCountAggregateOutputType | null
    _avg: ClienteAvgAggregateOutputType | null
    _sum: ClienteSumAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
  }

  export type ClienteAvgAggregateOutputType = {
    id: number | null
  }

  export type ClienteSumAggregateOutputType = {
    id: number | null
  }

  export type ClienteMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    cpfCnpj: string | null
    nomeRazaoSocial: string | null
    email: string | null
    telefone: string | null
    observacoes: string | null
    ativo: boolean | null
  }

  export type ClienteMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    cpfCnpj: string | null
    nomeRazaoSocial: string | null
    email: string | null
    telefone: string | null
    observacoes: string | null
    ativo: boolean | null
  }

  export type ClienteCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    cpfCnpj: number
    nomeRazaoSocial: number
    email: number
    telefone: number
    observacoes: number
    ativo: number
    _all: number
  }


  export type ClienteAvgAggregateInputType = {
    id?: true
  }

  export type ClienteSumAggregateInputType = {
    id?: true
  }

  export type ClienteMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    cpfCnpj?: true
    nomeRazaoSocial?: true
    email?: true
    telefone?: true
    observacoes?: true
    ativo?: true
  }

  export type ClienteMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    cpfCnpj?: true
    nomeRazaoSocial?: true
    email?: true
    telefone?: true
    observacoes?: true
    ativo?: true
  }

  export type ClienteCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    cpfCnpj?: true
    nomeRazaoSocial?: true
    email?: true
    telefone?: true
    observacoes?: true
    ativo?: true
    _all?: true
  }

  export type ClienteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cliente to aggregate.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clientes
    **/
    _count?: true | ClienteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClienteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClienteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClienteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClienteMaxAggregateInputType
  }

  export type GetClienteAggregateType<T extends ClienteAggregateArgs> = {
        [P in keyof T & keyof AggregateCliente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCliente[P]>
      : GetScalarType<T[P], AggregateCliente[P]>
  }




  export type ClienteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClienteWhereInput
    orderBy?: ClienteOrderByWithAggregationInput | ClienteOrderByWithAggregationInput[]
    by: ClienteScalarFieldEnum[] | ClienteScalarFieldEnum
    having?: ClienteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClienteCountAggregateInputType | true
    _avg?: ClienteAvgAggregateInputType
    _sum?: ClienteSumAggregateInputType
    _min?: ClienteMinAggregateInputType
    _max?: ClienteMaxAggregateInputType
  }

  export type ClienteGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    cpfCnpj: string
    nomeRazaoSocial: string
    email: string | null
    telefone: string | null
    observacoes: string | null
    ativo: boolean
    _count: ClienteCountAggregateOutputType | null
    _avg: ClienteAvgAggregateOutputType | null
    _sum: ClienteSumAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
  }

  type GetClienteGroupByPayload<T extends ClienteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClienteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClienteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClienteGroupByOutputType[P]>
            : GetScalarType<T[P], ClienteGroupByOutputType[P]>
        }
      >
    >


  export type ClienteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cpfCnpj?: boolean
    nomeRazaoSocial?: boolean
    email?: boolean
    telefone?: boolean
    observacoes?: boolean
    ativo?: boolean
    ordens?: boolean | Cliente$ordensArgs<ExtArgs>
    _count?: boolean | ClienteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cliente"]>

  export type ClienteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cpfCnpj?: boolean
    nomeRazaoSocial?: boolean
    email?: boolean
    telefone?: boolean
    observacoes?: boolean
    ativo?: boolean
  }, ExtArgs["result"]["cliente"]>

  export type ClienteSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cpfCnpj?: boolean
    nomeRazaoSocial?: boolean
    email?: boolean
    telefone?: boolean
    observacoes?: boolean
    ativo?: boolean
  }

  export type ClienteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ordens?: boolean | Cliente$ordensArgs<ExtArgs>
    _count?: boolean | ClienteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClienteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClientePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cliente"
    objects: {
      ordens: Prisma.$OrdemPagamentoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      cpfCnpj: string
      nomeRazaoSocial: string
      email: string | null
      telefone: string | null
      observacoes: string | null
      ativo: boolean
    }, ExtArgs["result"]["cliente"]>
    composites: {}
  }

  type ClienteGetPayload<S extends boolean | null | undefined | ClienteDefaultArgs> = $Result.GetResult<Prisma.$ClientePayload, S>

  type ClienteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClienteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClienteCountAggregateInputType | true
    }

  export interface ClienteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cliente'], meta: { name: 'Cliente' } }
    /**
     * Find zero or one Cliente that matches the filter.
     * @param {ClienteFindUniqueArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClienteFindUniqueArgs>(args: SelectSubset<T, ClienteFindUniqueArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Cliente that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClienteFindUniqueOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClienteFindUniqueOrThrowArgs>(args: SelectSubset<T, ClienteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Cliente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindFirstArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClienteFindFirstArgs>(args?: SelectSubset<T, ClienteFindFirstArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Cliente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindFirstOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClienteFindFirstOrThrowArgs>(args?: SelectSubset<T, ClienteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Clientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clientes
     * const clientes = await prisma.cliente.findMany()
     * 
     * // Get first 10 Clientes
     * const clientes = await prisma.cliente.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clienteWithIdOnly = await prisma.cliente.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClienteFindManyArgs>(args?: SelectSubset<T, ClienteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Cliente.
     * @param {ClienteCreateArgs} args - Arguments to create a Cliente.
     * @example
     * // Create one Cliente
     * const Cliente = await prisma.cliente.create({
     *   data: {
     *     // ... data to create a Cliente
     *   }
     * })
     * 
     */
    create<T extends ClienteCreateArgs>(args: SelectSubset<T, ClienteCreateArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Clientes.
     * @param {ClienteCreateManyArgs} args - Arguments to create many Clientes.
     * @example
     * // Create many Clientes
     * const cliente = await prisma.cliente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClienteCreateManyArgs>(args?: SelectSubset<T, ClienteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clientes and returns the data saved in the database.
     * @param {ClienteCreateManyAndReturnArgs} args - Arguments to create many Clientes.
     * @example
     * // Create many Clientes
     * const cliente = await prisma.cliente.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clientes and only return the `id`
     * const clienteWithIdOnly = await prisma.cliente.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClienteCreateManyAndReturnArgs>(args?: SelectSubset<T, ClienteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Cliente.
     * @param {ClienteDeleteArgs} args - Arguments to delete one Cliente.
     * @example
     * // Delete one Cliente
     * const Cliente = await prisma.cliente.delete({
     *   where: {
     *     // ... filter to delete one Cliente
     *   }
     * })
     * 
     */
    delete<T extends ClienteDeleteArgs>(args: SelectSubset<T, ClienteDeleteArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Cliente.
     * @param {ClienteUpdateArgs} args - Arguments to update one Cliente.
     * @example
     * // Update one Cliente
     * const cliente = await prisma.cliente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClienteUpdateArgs>(args: SelectSubset<T, ClienteUpdateArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Clientes.
     * @param {ClienteDeleteManyArgs} args - Arguments to filter Clientes to delete.
     * @example
     * // Delete a few Clientes
     * const { count } = await prisma.cliente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClienteDeleteManyArgs>(args?: SelectSubset<T, ClienteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clientes
     * const cliente = await prisma.cliente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClienteUpdateManyArgs>(args: SelectSubset<T, ClienteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cliente.
     * @param {ClienteUpsertArgs} args - Arguments to update or create a Cliente.
     * @example
     * // Update or create a Cliente
     * const cliente = await prisma.cliente.upsert({
     *   create: {
     *     // ... data to create a Cliente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cliente we want to update
     *   }
     * })
     */
    upsert<T extends ClienteUpsertArgs>(args: SelectSubset<T, ClienteUpsertArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteCountArgs} args - Arguments to filter Clientes to count.
     * @example
     * // Count the number of Clientes
     * const count = await prisma.cliente.count({
     *   where: {
     *     // ... the filter for the Clientes we want to count
     *   }
     * })
    **/
    count<T extends ClienteCountArgs>(
      args?: Subset<T, ClienteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClienteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClienteAggregateArgs>(args: Subset<T, ClienteAggregateArgs>): Prisma.PrismaPromise<GetClienteAggregateType<T>>

    /**
     * Group by Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClienteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClienteGroupByArgs['orderBy'] }
        : { orderBy?: ClienteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClienteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClienteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cliente model
   */
  readonly fields: ClienteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cliente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClienteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ordens<T extends Cliente$ordensArgs<ExtArgs> = {}>(args?: Subset<T, Cliente$ordensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdemPagamentoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cliente model
   */ 
  interface ClienteFieldRefs {
    readonly id: FieldRef<"Cliente", 'Int'>
    readonly createdAt: FieldRef<"Cliente", 'DateTime'>
    readonly updatedAt: FieldRef<"Cliente", 'DateTime'>
    readonly cpfCnpj: FieldRef<"Cliente", 'String'>
    readonly nomeRazaoSocial: FieldRef<"Cliente", 'String'>
    readonly email: FieldRef<"Cliente", 'String'>
    readonly telefone: FieldRef<"Cliente", 'String'>
    readonly observacoes: FieldRef<"Cliente", 'String'>
    readonly ativo: FieldRef<"Cliente", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Cliente findUnique
   */
  export type ClienteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente findUniqueOrThrow
   */
  export type ClienteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente findFirst
   */
  export type ClienteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clientes.
     */
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Cliente findFirstOrThrow
   */
  export type ClienteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clientes.
     */
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Cliente findMany
   */
  export type ClienteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Clientes to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Cliente create
   */
  export type ClienteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The data needed to create a Cliente.
     */
    data: XOR<ClienteCreateInput, ClienteUncheckedCreateInput>
  }

  /**
   * Cliente createMany
   */
  export type ClienteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clientes.
     */
    data: ClienteCreateManyInput | ClienteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cliente createManyAndReturn
   */
  export type ClienteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Clientes.
     */
    data: ClienteCreateManyInput | ClienteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cliente update
   */
  export type ClienteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The data needed to update a Cliente.
     */
    data: XOR<ClienteUpdateInput, ClienteUncheckedUpdateInput>
    /**
     * Choose, which Cliente to update.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente updateMany
   */
  export type ClienteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clientes.
     */
    data: XOR<ClienteUpdateManyMutationInput, ClienteUncheckedUpdateManyInput>
    /**
     * Filter which Clientes to update
     */
    where?: ClienteWhereInput
  }

  /**
   * Cliente upsert
   */
  export type ClienteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The filter to search for the Cliente to update in case it exists.
     */
    where: ClienteWhereUniqueInput
    /**
     * In case the Cliente found by the `where` argument doesn't exist, create a new Cliente with this data.
     */
    create: XOR<ClienteCreateInput, ClienteUncheckedCreateInput>
    /**
     * In case the Cliente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClienteUpdateInput, ClienteUncheckedUpdateInput>
  }

  /**
   * Cliente delete
   */
  export type ClienteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter which Cliente to delete.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente deleteMany
   */
  export type ClienteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clientes to delete
     */
    where?: ClienteWhereInput
  }

  /**
   * Cliente.ordens
   */
  export type Cliente$ordensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemPagamento
     */
    select?: OrdemPagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemPagamentoInclude<ExtArgs> | null
    where?: OrdemPagamentoWhereInput
    orderBy?: OrdemPagamentoOrderByWithRelationInput | OrdemPagamentoOrderByWithRelationInput[]
    cursor?: OrdemPagamentoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdemPagamentoScalarFieldEnum | OrdemPagamentoScalarFieldEnum[]
  }

  /**
   * Cliente without action
   */
  export type ClienteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
  }


  /**
   * Model OrdemPagamento
   */

  export type AggregateOrdemPagamento = {
    _count: OrdemPagamentoCountAggregateOutputType | null
    _avg: OrdemPagamentoAvgAggregateOutputType | null
    _sum: OrdemPagamentoSumAggregateOutputType | null
    _min: OrdemPagamentoMinAggregateOutputType | null
    _max: OrdemPagamentoMaxAggregateOutputType | null
  }

  export type OrdemPagamentoAvgAggregateOutputType = {
    id: number | null
    clienteId: number | null
    sequenciaCliente: number | null
    valorTotalPrevisto: Decimal | null
  }

  export type OrdemPagamentoSumAggregateOutputType = {
    id: number | null
    clienteId: number | null
    sequenciaCliente: number | null
    valorTotalPrevisto: Decimal | null
  }

  export type OrdemPagamentoMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    clienteId: number | null
    sequenciaCliente: number | null
    codigoInterno: string | null
    descricao: string | null
    tipoContrato: string | null
    valorTotalPrevisto: Decimal | null
    modeloPagamento: $Enums.ModeloPagamento | null
    dataInicio: Date | null
    dataFimPrevista: Date | null
    status: $Enums.StatusOrdem | null
  }

  export type OrdemPagamentoMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    clienteId: number | null
    sequenciaCliente: number | null
    codigoInterno: string | null
    descricao: string | null
    tipoContrato: string | null
    valorTotalPrevisto: Decimal | null
    modeloPagamento: $Enums.ModeloPagamento | null
    dataInicio: Date | null
    dataFimPrevista: Date | null
    status: $Enums.StatusOrdem | null
  }

  export type OrdemPagamentoCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    clienteId: number
    sequenciaCliente: number
    codigoInterno: number
    descricao: number
    tipoContrato: number
    valorTotalPrevisto: number
    modeloPagamento: number
    dataInicio: number
    dataFimPrevista: number
    status: number
    _all: number
  }


  export type OrdemPagamentoAvgAggregateInputType = {
    id?: true
    clienteId?: true
    sequenciaCliente?: true
    valorTotalPrevisto?: true
  }

  export type OrdemPagamentoSumAggregateInputType = {
    id?: true
    clienteId?: true
    sequenciaCliente?: true
    valorTotalPrevisto?: true
  }

  export type OrdemPagamentoMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    clienteId?: true
    sequenciaCliente?: true
    codigoInterno?: true
    descricao?: true
    tipoContrato?: true
    valorTotalPrevisto?: true
    modeloPagamento?: true
    dataInicio?: true
    dataFimPrevista?: true
    status?: true
  }

  export type OrdemPagamentoMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    clienteId?: true
    sequenciaCliente?: true
    codigoInterno?: true
    descricao?: true
    tipoContrato?: true
    valorTotalPrevisto?: true
    modeloPagamento?: true
    dataInicio?: true
    dataFimPrevista?: true
    status?: true
  }

  export type OrdemPagamentoCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    clienteId?: true
    sequenciaCliente?: true
    codigoInterno?: true
    descricao?: true
    tipoContrato?: true
    valorTotalPrevisto?: true
    modeloPagamento?: true
    dataInicio?: true
    dataFimPrevista?: true
    status?: true
    _all?: true
  }

  export type OrdemPagamentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrdemPagamento to aggregate.
     */
    where?: OrdemPagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrdemPagamentos to fetch.
     */
    orderBy?: OrdemPagamentoOrderByWithRelationInput | OrdemPagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrdemPagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrdemPagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrdemPagamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrdemPagamentos
    **/
    _count?: true | OrdemPagamentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrdemPagamentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrdemPagamentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrdemPagamentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrdemPagamentoMaxAggregateInputType
  }

  export type GetOrdemPagamentoAggregateType<T extends OrdemPagamentoAggregateArgs> = {
        [P in keyof T & keyof AggregateOrdemPagamento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrdemPagamento[P]>
      : GetScalarType<T[P], AggregateOrdemPagamento[P]>
  }




  export type OrdemPagamentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdemPagamentoWhereInput
    orderBy?: OrdemPagamentoOrderByWithAggregationInput | OrdemPagamentoOrderByWithAggregationInput[]
    by: OrdemPagamentoScalarFieldEnum[] | OrdemPagamentoScalarFieldEnum
    having?: OrdemPagamentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrdemPagamentoCountAggregateInputType | true
    _avg?: OrdemPagamentoAvgAggregateInputType
    _sum?: OrdemPagamentoSumAggregateInputType
    _min?: OrdemPagamentoMinAggregateInputType
    _max?: OrdemPagamentoMaxAggregateInputType
  }

  export type OrdemPagamentoGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    clienteId: number
    sequenciaCliente: number
    codigoInterno: string | null
    descricao: string | null
    tipoContrato: string | null
    valorTotalPrevisto: Decimal | null
    modeloPagamento: $Enums.ModeloPagamento
    dataInicio: Date
    dataFimPrevista: Date | null
    status: $Enums.StatusOrdem
    _count: OrdemPagamentoCountAggregateOutputType | null
    _avg: OrdemPagamentoAvgAggregateOutputType | null
    _sum: OrdemPagamentoSumAggregateOutputType | null
    _min: OrdemPagamentoMinAggregateOutputType | null
    _max: OrdemPagamentoMaxAggregateOutputType | null
  }

  type GetOrdemPagamentoGroupByPayload<T extends OrdemPagamentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrdemPagamentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrdemPagamentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrdemPagamentoGroupByOutputType[P]>
            : GetScalarType<T[P], OrdemPagamentoGroupByOutputType[P]>
        }
      >
    >


  export type OrdemPagamentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clienteId?: boolean
    sequenciaCliente?: boolean
    codigoInterno?: boolean
    descricao?: boolean
    tipoContrato?: boolean
    valorTotalPrevisto?: boolean
    modeloPagamento?: boolean
    dataInicio?: boolean
    dataFimPrevista?: boolean
    status?: boolean
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
    pagamentos?: boolean | OrdemPagamento$pagamentosArgs<ExtArgs>
    repasses?: boolean | OrdemPagamento$repassesArgs<ExtArgs>
    _count?: boolean | OrdemPagamentoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ordemPagamento"]>

  export type OrdemPagamentoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clienteId?: boolean
    sequenciaCliente?: boolean
    codigoInterno?: boolean
    descricao?: boolean
    tipoContrato?: boolean
    valorTotalPrevisto?: boolean
    modeloPagamento?: boolean
    dataInicio?: boolean
    dataFimPrevista?: boolean
    status?: boolean
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ordemPagamento"]>

  export type OrdemPagamentoSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clienteId?: boolean
    sequenciaCliente?: boolean
    codigoInterno?: boolean
    descricao?: boolean
    tipoContrato?: boolean
    valorTotalPrevisto?: boolean
    modeloPagamento?: boolean
    dataInicio?: boolean
    dataFimPrevista?: boolean
    status?: boolean
  }

  export type OrdemPagamentoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
    pagamentos?: boolean | OrdemPagamento$pagamentosArgs<ExtArgs>
    repasses?: boolean | OrdemPagamento$repassesArgs<ExtArgs>
    _count?: boolean | OrdemPagamentoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrdemPagamentoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }

  export type $OrdemPagamentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrdemPagamento"
    objects: {
      cliente: Prisma.$ClientePayload<ExtArgs>
      pagamentos: Prisma.$PagamentoPayload<ExtArgs>[]
      repasses: Prisma.$RepassePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      clienteId: number
      sequenciaCliente: number
      codigoInterno: string | null
      descricao: string | null
      tipoContrato: string | null
      valorTotalPrevisto: Prisma.Decimal | null
      modeloPagamento: $Enums.ModeloPagamento
      dataInicio: Date
      dataFimPrevista: Date | null
      status: $Enums.StatusOrdem
    }, ExtArgs["result"]["ordemPagamento"]>
    composites: {}
  }

  type OrdemPagamentoGetPayload<S extends boolean | null | undefined | OrdemPagamentoDefaultArgs> = $Result.GetResult<Prisma.$OrdemPagamentoPayload, S>

  type OrdemPagamentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrdemPagamentoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrdemPagamentoCountAggregateInputType | true
    }

  export interface OrdemPagamentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrdemPagamento'], meta: { name: 'OrdemPagamento' } }
    /**
     * Find zero or one OrdemPagamento that matches the filter.
     * @param {OrdemPagamentoFindUniqueArgs} args - Arguments to find a OrdemPagamento
     * @example
     * // Get one OrdemPagamento
     * const ordemPagamento = await prisma.ordemPagamento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrdemPagamentoFindUniqueArgs>(args: SelectSubset<T, OrdemPagamentoFindUniqueArgs<ExtArgs>>): Prisma__OrdemPagamentoClient<$Result.GetResult<Prisma.$OrdemPagamentoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OrdemPagamento that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrdemPagamentoFindUniqueOrThrowArgs} args - Arguments to find a OrdemPagamento
     * @example
     * // Get one OrdemPagamento
     * const ordemPagamento = await prisma.ordemPagamento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrdemPagamentoFindUniqueOrThrowArgs>(args: SelectSubset<T, OrdemPagamentoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrdemPagamentoClient<$Result.GetResult<Prisma.$OrdemPagamentoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OrdemPagamento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdemPagamentoFindFirstArgs} args - Arguments to find a OrdemPagamento
     * @example
     * // Get one OrdemPagamento
     * const ordemPagamento = await prisma.ordemPagamento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrdemPagamentoFindFirstArgs>(args?: SelectSubset<T, OrdemPagamentoFindFirstArgs<ExtArgs>>): Prisma__OrdemPagamentoClient<$Result.GetResult<Prisma.$OrdemPagamentoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OrdemPagamento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdemPagamentoFindFirstOrThrowArgs} args - Arguments to find a OrdemPagamento
     * @example
     * // Get one OrdemPagamento
     * const ordemPagamento = await prisma.ordemPagamento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrdemPagamentoFindFirstOrThrowArgs>(args?: SelectSubset<T, OrdemPagamentoFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrdemPagamentoClient<$Result.GetResult<Prisma.$OrdemPagamentoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OrdemPagamentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdemPagamentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrdemPagamentos
     * const ordemPagamentos = await prisma.ordemPagamento.findMany()
     * 
     * // Get first 10 OrdemPagamentos
     * const ordemPagamentos = await prisma.ordemPagamento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ordemPagamentoWithIdOnly = await prisma.ordemPagamento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrdemPagamentoFindManyArgs>(args?: SelectSubset<T, OrdemPagamentoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdemPagamentoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OrdemPagamento.
     * @param {OrdemPagamentoCreateArgs} args - Arguments to create a OrdemPagamento.
     * @example
     * // Create one OrdemPagamento
     * const OrdemPagamento = await prisma.ordemPagamento.create({
     *   data: {
     *     // ... data to create a OrdemPagamento
     *   }
     * })
     * 
     */
    create<T extends OrdemPagamentoCreateArgs>(args: SelectSubset<T, OrdemPagamentoCreateArgs<ExtArgs>>): Prisma__OrdemPagamentoClient<$Result.GetResult<Prisma.$OrdemPagamentoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OrdemPagamentos.
     * @param {OrdemPagamentoCreateManyArgs} args - Arguments to create many OrdemPagamentos.
     * @example
     * // Create many OrdemPagamentos
     * const ordemPagamento = await prisma.ordemPagamento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrdemPagamentoCreateManyArgs>(args?: SelectSubset<T, OrdemPagamentoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrdemPagamentos and returns the data saved in the database.
     * @param {OrdemPagamentoCreateManyAndReturnArgs} args - Arguments to create many OrdemPagamentos.
     * @example
     * // Create many OrdemPagamentos
     * const ordemPagamento = await prisma.ordemPagamento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrdemPagamentos and only return the `id`
     * const ordemPagamentoWithIdOnly = await prisma.ordemPagamento.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrdemPagamentoCreateManyAndReturnArgs>(args?: SelectSubset<T, OrdemPagamentoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdemPagamentoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OrdemPagamento.
     * @param {OrdemPagamentoDeleteArgs} args - Arguments to delete one OrdemPagamento.
     * @example
     * // Delete one OrdemPagamento
     * const OrdemPagamento = await prisma.ordemPagamento.delete({
     *   where: {
     *     // ... filter to delete one OrdemPagamento
     *   }
     * })
     * 
     */
    delete<T extends OrdemPagamentoDeleteArgs>(args: SelectSubset<T, OrdemPagamentoDeleteArgs<ExtArgs>>): Prisma__OrdemPagamentoClient<$Result.GetResult<Prisma.$OrdemPagamentoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OrdemPagamento.
     * @param {OrdemPagamentoUpdateArgs} args - Arguments to update one OrdemPagamento.
     * @example
     * // Update one OrdemPagamento
     * const ordemPagamento = await prisma.ordemPagamento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrdemPagamentoUpdateArgs>(args: SelectSubset<T, OrdemPagamentoUpdateArgs<ExtArgs>>): Prisma__OrdemPagamentoClient<$Result.GetResult<Prisma.$OrdemPagamentoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OrdemPagamentos.
     * @param {OrdemPagamentoDeleteManyArgs} args - Arguments to filter OrdemPagamentos to delete.
     * @example
     * // Delete a few OrdemPagamentos
     * const { count } = await prisma.ordemPagamento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrdemPagamentoDeleteManyArgs>(args?: SelectSubset<T, OrdemPagamentoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrdemPagamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdemPagamentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrdemPagamentos
     * const ordemPagamento = await prisma.ordemPagamento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrdemPagamentoUpdateManyArgs>(args: SelectSubset<T, OrdemPagamentoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrdemPagamento.
     * @param {OrdemPagamentoUpsertArgs} args - Arguments to update or create a OrdemPagamento.
     * @example
     * // Update or create a OrdemPagamento
     * const ordemPagamento = await prisma.ordemPagamento.upsert({
     *   create: {
     *     // ... data to create a OrdemPagamento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrdemPagamento we want to update
     *   }
     * })
     */
    upsert<T extends OrdemPagamentoUpsertArgs>(args: SelectSubset<T, OrdemPagamentoUpsertArgs<ExtArgs>>): Prisma__OrdemPagamentoClient<$Result.GetResult<Prisma.$OrdemPagamentoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OrdemPagamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdemPagamentoCountArgs} args - Arguments to filter OrdemPagamentos to count.
     * @example
     * // Count the number of OrdemPagamentos
     * const count = await prisma.ordemPagamento.count({
     *   where: {
     *     // ... the filter for the OrdemPagamentos we want to count
     *   }
     * })
    **/
    count<T extends OrdemPagamentoCountArgs>(
      args?: Subset<T, OrdemPagamentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrdemPagamentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrdemPagamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdemPagamentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrdemPagamentoAggregateArgs>(args: Subset<T, OrdemPagamentoAggregateArgs>): Prisma.PrismaPromise<GetOrdemPagamentoAggregateType<T>>

    /**
     * Group by OrdemPagamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdemPagamentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrdemPagamentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrdemPagamentoGroupByArgs['orderBy'] }
        : { orderBy?: OrdemPagamentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrdemPagamentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrdemPagamentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrdemPagamento model
   */
  readonly fields: OrdemPagamentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrdemPagamento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrdemPagamentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cliente<T extends ClienteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClienteDefaultArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    pagamentos<T extends OrdemPagamento$pagamentosArgs<ExtArgs> = {}>(args?: Subset<T, OrdemPagamento$pagamentosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findMany"> | Null>
    repasses<T extends OrdemPagamento$repassesArgs<ExtArgs> = {}>(args?: Subset<T, OrdemPagamento$repassesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepassePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrdemPagamento model
   */ 
  interface OrdemPagamentoFieldRefs {
    readonly id: FieldRef<"OrdemPagamento", 'Int'>
    readonly createdAt: FieldRef<"OrdemPagamento", 'DateTime'>
    readonly updatedAt: FieldRef<"OrdemPagamento", 'DateTime'>
    readonly clienteId: FieldRef<"OrdemPagamento", 'Int'>
    readonly sequenciaCliente: FieldRef<"OrdemPagamento", 'Int'>
    readonly codigoInterno: FieldRef<"OrdemPagamento", 'String'>
    readonly descricao: FieldRef<"OrdemPagamento", 'String'>
    readonly tipoContrato: FieldRef<"OrdemPagamento", 'String'>
    readonly valorTotalPrevisto: FieldRef<"OrdemPagamento", 'Decimal'>
    readonly modeloPagamento: FieldRef<"OrdemPagamento", 'ModeloPagamento'>
    readonly dataInicio: FieldRef<"OrdemPagamento", 'DateTime'>
    readonly dataFimPrevista: FieldRef<"OrdemPagamento", 'DateTime'>
    readonly status: FieldRef<"OrdemPagamento", 'StatusOrdem'>
  }
    

  // Custom InputTypes
  /**
   * OrdemPagamento findUnique
   */
  export type OrdemPagamentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemPagamento
     */
    select?: OrdemPagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemPagamentoInclude<ExtArgs> | null
    /**
     * Filter, which OrdemPagamento to fetch.
     */
    where: OrdemPagamentoWhereUniqueInput
  }

  /**
   * OrdemPagamento findUniqueOrThrow
   */
  export type OrdemPagamentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemPagamento
     */
    select?: OrdemPagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemPagamentoInclude<ExtArgs> | null
    /**
     * Filter, which OrdemPagamento to fetch.
     */
    where: OrdemPagamentoWhereUniqueInput
  }

  /**
   * OrdemPagamento findFirst
   */
  export type OrdemPagamentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemPagamento
     */
    select?: OrdemPagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemPagamentoInclude<ExtArgs> | null
    /**
     * Filter, which OrdemPagamento to fetch.
     */
    where?: OrdemPagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrdemPagamentos to fetch.
     */
    orderBy?: OrdemPagamentoOrderByWithRelationInput | OrdemPagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrdemPagamentos.
     */
    cursor?: OrdemPagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrdemPagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrdemPagamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrdemPagamentos.
     */
    distinct?: OrdemPagamentoScalarFieldEnum | OrdemPagamentoScalarFieldEnum[]
  }

  /**
   * OrdemPagamento findFirstOrThrow
   */
  export type OrdemPagamentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemPagamento
     */
    select?: OrdemPagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemPagamentoInclude<ExtArgs> | null
    /**
     * Filter, which OrdemPagamento to fetch.
     */
    where?: OrdemPagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrdemPagamentos to fetch.
     */
    orderBy?: OrdemPagamentoOrderByWithRelationInput | OrdemPagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrdemPagamentos.
     */
    cursor?: OrdemPagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrdemPagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrdemPagamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrdemPagamentos.
     */
    distinct?: OrdemPagamentoScalarFieldEnum | OrdemPagamentoScalarFieldEnum[]
  }

  /**
   * OrdemPagamento findMany
   */
  export type OrdemPagamentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemPagamento
     */
    select?: OrdemPagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemPagamentoInclude<ExtArgs> | null
    /**
     * Filter, which OrdemPagamentos to fetch.
     */
    where?: OrdemPagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrdemPagamentos to fetch.
     */
    orderBy?: OrdemPagamentoOrderByWithRelationInput | OrdemPagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrdemPagamentos.
     */
    cursor?: OrdemPagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrdemPagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrdemPagamentos.
     */
    skip?: number
    distinct?: OrdemPagamentoScalarFieldEnum | OrdemPagamentoScalarFieldEnum[]
  }

  /**
   * OrdemPagamento create
   */
  export type OrdemPagamentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemPagamento
     */
    select?: OrdemPagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemPagamentoInclude<ExtArgs> | null
    /**
     * The data needed to create a OrdemPagamento.
     */
    data: XOR<OrdemPagamentoCreateInput, OrdemPagamentoUncheckedCreateInput>
  }

  /**
   * OrdemPagamento createMany
   */
  export type OrdemPagamentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrdemPagamentos.
     */
    data: OrdemPagamentoCreateManyInput | OrdemPagamentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrdemPagamento createManyAndReturn
   */
  export type OrdemPagamentoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemPagamento
     */
    select?: OrdemPagamentoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OrdemPagamentos.
     */
    data: OrdemPagamentoCreateManyInput | OrdemPagamentoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemPagamentoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrdemPagamento update
   */
  export type OrdemPagamentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemPagamento
     */
    select?: OrdemPagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemPagamentoInclude<ExtArgs> | null
    /**
     * The data needed to update a OrdemPagamento.
     */
    data: XOR<OrdemPagamentoUpdateInput, OrdemPagamentoUncheckedUpdateInput>
    /**
     * Choose, which OrdemPagamento to update.
     */
    where: OrdemPagamentoWhereUniqueInput
  }

  /**
   * OrdemPagamento updateMany
   */
  export type OrdemPagamentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrdemPagamentos.
     */
    data: XOR<OrdemPagamentoUpdateManyMutationInput, OrdemPagamentoUncheckedUpdateManyInput>
    /**
     * Filter which OrdemPagamentos to update
     */
    where?: OrdemPagamentoWhereInput
  }

  /**
   * OrdemPagamento upsert
   */
  export type OrdemPagamentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemPagamento
     */
    select?: OrdemPagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemPagamentoInclude<ExtArgs> | null
    /**
     * The filter to search for the OrdemPagamento to update in case it exists.
     */
    where: OrdemPagamentoWhereUniqueInput
    /**
     * In case the OrdemPagamento found by the `where` argument doesn't exist, create a new OrdemPagamento with this data.
     */
    create: XOR<OrdemPagamentoCreateInput, OrdemPagamentoUncheckedCreateInput>
    /**
     * In case the OrdemPagamento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrdemPagamentoUpdateInput, OrdemPagamentoUncheckedUpdateInput>
  }

  /**
   * OrdemPagamento delete
   */
  export type OrdemPagamentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemPagamento
     */
    select?: OrdemPagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemPagamentoInclude<ExtArgs> | null
    /**
     * Filter which OrdemPagamento to delete.
     */
    where: OrdemPagamentoWhereUniqueInput
  }

  /**
   * OrdemPagamento deleteMany
   */
  export type OrdemPagamentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrdemPagamentos to delete
     */
    where?: OrdemPagamentoWhereInput
  }

  /**
   * OrdemPagamento.pagamentos
   */
  export type OrdemPagamento$pagamentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    where?: PagamentoWhereInput
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    cursor?: PagamentoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PagamentoScalarFieldEnum | PagamentoScalarFieldEnum[]
  }

  /**
   * OrdemPagamento.repasses
   */
  export type OrdemPagamento$repassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repasse
     */
    select?: RepasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepasseInclude<ExtArgs> | null
    where?: RepasseWhereInput
    orderBy?: RepasseOrderByWithRelationInput | RepasseOrderByWithRelationInput[]
    cursor?: RepasseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RepasseScalarFieldEnum | RepasseScalarFieldEnum[]
  }

  /**
   * OrdemPagamento without action
   */
  export type OrdemPagamentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemPagamento
     */
    select?: OrdemPagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemPagamentoInclude<ExtArgs> | null
  }


  /**
   * Model Pagamento
   */

  export type AggregatePagamento = {
    _count: PagamentoCountAggregateOutputType | null
    _avg: PagamentoAvgAggregateOutputType | null
    _sum: PagamentoSumAggregateOutputType | null
    _min: PagamentoMinAggregateOutputType | null
    _max: PagamentoMaxAggregateOutputType | null
  }

  export type PagamentoAvgAggregateOutputType = {
    id: number | null
    ordemPagamentoId: number | null
    numeroParcela: number | null
    valorPrevisto: Decimal | null
    valorPago: Decimal | null
  }

  export type PagamentoSumAggregateOutputType = {
    id: number | null
    ordemPagamentoId: number | null
    numeroParcela: number | null
    valorPrevisto: Decimal | null
    valorPago: Decimal | null
  }

  export type PagamentoMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    ordemPagamentoId: number | null
    numeroParcela: number | null
    dataPrevista: Date | null
    dataEfetiva: Date | null
    valorPrevisto: Decimal | null
    valorPago: Decimal | null
    formaPagamento: string | null
    status: $Enums.StatusPagamento | null
    observacoes: string | null
  }

  export type PagamentoMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    ordemPagamentoId: number | null
    numeroParcela: number | null
    dataPrevista: Date | null
    dataEfetiva: Date | null
    valorPrevisto: Decimal | null
    valorPago: Decimal | null
    formaPagamento: string | null
    status: $Enums.StatusPagamento | null
    observacoes: string | null
  }

  export type PagamentoCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    ordemPagamentoId: number
    numeroParcela: number
    dataPrevista: number
    dataEfetiva: number
    valorPrevisto: number
    valorPago: number
    formaPagamento: number
    status: number
    observacoes: number
    _all: number
  }


  export type PagamentoAvgAggregateInputType = {
    id?: true
    ordemPagamentoId?: true
    numeroParcela?: true
    valorPrevisto?: true
    valorPago?: true
  }

  export type PagamentoSumAggregateInputType = {
    id?: true
    ordemPagamentoId?: true
    numeroParcela?: true
    valorPrevisto?: true
    valorPago?: true
  }

  export type PagamentoMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    ordemPagamentoId?: true
    numeroParcela?: true
    dataPrevista?: true
    dataEfetiva?: true
    valorPrevisto?: true
    valorPago?: true
    formaPagamento?: true
    status?: true
    observacoes?: true
  }

  export type PagamentoMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    ordemPagamentoId?: true
    numeroParcela?: true
    dataPrevista?: true
    dataEfetiva?: true
    valorPrevisto?: true
    valorPago?: true
    formaPagamento?: true
    status?: true
    observacoes?: true
  }

  export type PagamentoCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    ordemPagamentoId?: true
    numeroParcela?: true
    dataPrevista?: true
    dataEfetiva?: true
    valorPrevisto?: true
    valorPago?: true
    formaPagamento?: true
    status?: true
    observacoes?: true
    _all?: true
  }

  export type PagamentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pagamento to aggregate.
     */
    where?: PagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagamentos to fetch.
     */
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pagamentos
    **/
    _count?: true | PagamentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PagamentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PagamentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PagamentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PagamentoMaxAggregateInputType
  }

  export type GetPagamentoAggregateType<T extends PagamentoAggregateArgs> = {
        [P in keyof T & keyof AggregatePagamento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePagamento[P]>
      : GetScalarType<T[P], AggregatePagamento[P]>
  }




  export type PagamentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagamentoWhereInput
    orderBy?: PagamentoOrderByWithAggregationInput | PagamentoOrderByWithAggregationInput[]
    by: PagamentoScalarFieldEnum[] | PagamentoScalarFieldEnum
    having?: PagamentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PagamentoCountAggregateInputType | true
    _avg?: PagamentoAvgAggregateInputType
    _sum?: PagamentoSumAggregateInputType
    _min?: PagamentoMinAggregateInputType
    _max?: PagamentoMaxAggregateInputType
  }

  export type PagamentoGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    ordemPagamentoId: number
    numeroParcela: number
    dataPrevista: Date
    dataEfetiva: Date | null
    valorPrevisto: Decimal
    valorPago: Decimal | null
    formaPagamento: string | null
    status: $Enums.StatusPagamento
    observacoes: string | null
    _count: PagamentoCountAggregateOutputType | null
    _avg: PagamentoAvgAggregateOutputType | null
    _sum: PagamentoSumAggregateOutputType | null
    _min: PagamentoMinAggregateOutputType | null
    _max: PagamentoMaxAggregateOutputType | null
  }

  type GetPagamentoGroupByPayload<T extends PagamentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PagamentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PagamentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PagamentoGroupByOutputType[P]>
            : GetScalarType<T[P], PagamentoGroupByOutputType[P]>
        }
      >
    >


  export type PagamentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ordemPagamentoId?: boolean
    numeroParcela?: boolean
    dataPrevista?: boolean
    dataEfetiva?: boolean
    valorPrevisto?: boolean
    valorPago?: boolean
    formaPagamento?: boolean
    status?: boolean
    observacoes?: boolean
    ordemPagamento?: boolean | OrdemPagamentoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pagamento"]>

  export type PagamentoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ordemPagamentoId?: boolean
    numeroParcela?: boolean
    dataPrevista?: boolean
    dataEfetiva?: boolean
    valorPrevisto?: boolean
    valorPago?: boolean
    formaPagamento?: boolean
    status?: boolean
    observacoes?: boolean
    ordemPagamento?: boolean | OrdemPagamentoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pagamento"]>

  export type PagamentoSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ordemPagamentoId?: boolean
    numeroParcela?: boolean
    dataPrevista?: boolean
    dataEfetiva?: boolean
    valorPrevisto?: boolean
    valorPago?: boolean
    formaPagamento?: boolean
    status?: boolean
    observacoes?: boolean
  }

  export type PagamentoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ordemPagamento?: boolean | OrdemPagamentoDefaultArgs<ExtArgs>
  }
  export type PagamentoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ordemPagamento?: boolean | OrdemPagamentoDefaultArgs<ExtArgs>
  }

  export type $PagamentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pagamento"
    objects: {
      ordemPagamento: Prisma.$OrdemPagamentoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      ordemPagamentoId: number
      numeroParcela: number
      dataPrevista: Date
      dataEfetiva: Date | null
      valorPrevisto: Prisma.Decimal
      valorPago: Prisma.Decimal | null
      formaPagamento: string | null
      status: $Enums.StatusPagamento
      observacoes: string | null
    }, ExtArgs["result"]["pagamento"]>
    composites: {}
  }

  type PagamentoGetPayload<S extends boolean | null | undefined | PagamentoDefaultArgs> = $Result.GetResult<Prisma.$PagamentoPayload, S>

  type PagamentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PagamentoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PagamentoCountAggregateInputType | true
    }

  export interface PagamentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pagamento'], meta: { name: 'Pagamento' } }
    /**
     * Find zero or one Pagamento that matches the filter.
     * @param {PagamentoFindUniqueArgs} args - Arguments to find a Pagamento
     * @example
     * // Get one Pagamento
     * const pagamento = await prisma.pagamento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PagamentoFindUniqueArgs>(args: SelectSubset<T, PagamentoFindUniqueArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pagamento that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PagamentoFindUniqueOrThrowArgs} args - Arguments to find a Pagamento
     * @example
     * // Get one Pagamento
     * const pagamento = await prisma.pagamento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PagamentoFindUniqueOrThrowArgs>(args: SelectSubset<T, PagamentoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pagamento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoFindFirstArgs} args - Arguments to find a Pagamento
     * @example
     * // Get one Pagamento
     * const pagamento = await prisma.pagamento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PagamentoFindFirstArgs>(args?: SelectSubset<T, PagamentoFindFirstArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pagamento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoFindFirstOrThrowArgs} args - Arguments to find a Pagamento
     * @example
     * // Get one Pagamento
     * const pagamento = await prisma.pagamento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PagamentoFindFirstOrThrowArgs>(args?: SelectSubset<T, PagamentoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pagamentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pagamentos
     * const pagamentos = await prisma.pagamento.findMany()
     * 
     * // Get first 10 Pagamentos
     * const pagamentos = await prisma.pagamento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pagamentoWithIdOnly = await prisma.pagamento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PagamentoFindManyArgs>(args?: SelectSubset<T, PagamentoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pagamento.
     * @param {PagamentoCreateArgs} args - Arguments to create a Pagamento.
     * @example
     * // Create one Pagamento
     * const Pagamento = await prisma.pagamento.create({
     *   data: {
     *     // ... data to create a Pagamento
     *   }
     * })
     * 
     */
    create<T extends PagamentoCreateArgs>(args: SelectSubset<T, PagamentoCreateArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pagamentos.
     * @param {PagamentoCreateManyArgs} args - Arguments to create many Pagamentos.
     * @example
     * // Create many Pagamentos
     * const pagamento = await prisma.pagamento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PagamentoCreateManyArgs>(args?: SelectSubset<T, PagamentoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pagamentos and returns the data saved in the database.
     * @param {PagamentoCreateManyAndReturnArgs} args - Arguments to create many Pagamentos.
     * @example
     * // Create many Pagamentos
     * const pagamento = await prisma.pagamento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pagamentos and only return the `id`
     * const pagamentoWithIdOnly = await prisma.pagamento.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PagamentoCreateManyAndReturnArgs>(args?: SelectSubset<T, PagamentoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Pagamento.
     * @param {PagamentoDeleteArgs} args - Arguments to delete one Pagamento.
     * @example
     * // Delete one Pagamento
     * const Pagamento = await prisma.pagamento.delete({
     *   where: {
     *     // ... filter to delete one Pagamento
     *   }
     * })
     * 
     */
    delete<T extends PagamentoDeleteArgs>(args: SelectSubset<T, PagamentoDeleteArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pagamento.
     * @param {PagamentoUpdateArgs} args - Arguments to update one Pagamento.
     * @example
     * // Update one Pagamento
     * const pagamento = await prisma.pagamento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PagamentoUpdateArgs>(args: SelectSubset<T, PagamentoUpdateArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pagamentos.
     * @param {PagamentoDeleteManyArgs} args - Arguments to filter Pagamentos to delete.
     * @example
     * // Delete a few Pagamentos
     * const { count } = await prisma.pagamento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PagamentoDeleteManyArgs>(args?: SelectSubset<T, PagamentoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pagamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pagamentos
     * const pagamento = await prisma.pagamento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PagamentoUpdateManyArgs>(args: SelectSubset<T, PagamentoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pagamento.
     * @param {PagamentoUpsertArgs} args - Arguments to update or create a Pagamento.
     * @example
     * // Update or create a Pagamento
     * const pagamento = await prisma.pagamento.upsert({
     *   create: {
     *     // ... data to create a Pagamento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pagamento we want to update
     *   }
     * })
     */
    upsert<T extends PagamentoUpsertArgs>(args: SelectSubset<T, PagamentoUpsertArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pagamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoCountArgs} args - Arguments to filter Pagamentos to count.
     * @example
     * // Count the number of Pagamentos
     * const count = await prisma.pagamento.count({
     *   where: {
     *     // ... the filter for the Pagamentos we want to count
     *   }
     * })
    **/
    count<T extends PagamentoCountArgs>(
      args?: Subset<T, PagamentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PagamentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pagamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PagamentoAggregateArgs>(args: Subset<T, PagamentoAggregateArgs>): Prisma.PrismaPromise<GetPagamentoAggregateType<T>>

    /**
     * Group by Pagamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PagamentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PagamentoGroupByArgs['orderBy'] }
        : { orderBy?: PagamentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PagamentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPagamentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pagamento model
   */
  readonly fields: PagamentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pagamento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PagamentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ordemPagamento<T extends OrdemPagamentoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrdemPagamentoDefaultArgs<ExtArgs>>): Prisma__OrdemPagamentoClient<$Result.GetResult<Prisma.$OrdemPagamentoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pagamento model
   */ 
  interface PagamentoFieldRefs {
    readonly id: FieldRef<"Pagamento", 'Int'>
    readonly createdAt: FieldRef<"Pagamento", 'DateTime'>
    readonly updatedAt: FieldRef<"Pagamento", 'DateTime'>
    readonly ordemPagamentoId: FieldRef<"Pagamento", 'Int'>
    readonly numeroParcela: FieldRef<"Pagamento", 'Int'>
    readonly dataPrevista: FieldRef<"Pagamento", 'DateTime'>
    readonly dataEfetiva: FieldRef<"Pagamento", 'DateTime'>
    readonly valorPrevisto: FieldRef<"Pagamento", 'Decimal'>
    readonly valorPago: FieldRef<"Pagamento", 'Decimal'>
    readonly formaPagamento: FieldRef<"Pagamento", 'String'>
    readonly status: FieldRef<"Pagamento", 'StatusPagamento'>
    readonly observacoes: FieldRef<"Pagamento", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Pagamento findUnique
   */
  export type PagamentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamento to fetch.
     */
    where: PagamentoWhereUniqueInput
  }

  /**
   * Pagamento findUniqueOrThrow
   */
  export type PagamentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamento to fetch.
     */
    where: PagamentoWhereUniqueInput
  }

  /**
   * Pagamento findFirst
   */
  export type PagamentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamento to fetch.
     */
    where?: PagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagamentos to fetch.
     */
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pagamentos.
     */
    cursor?: PagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pagamentos.
     */
    distinct?: PagamentoScalarFieldEnum | PagamentoScalarFieldEnum[]
  }

  /**
   * Pagamento findFirstOrThrow
   */
  export type PagamentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamento to fetch.
     */
    where?: PagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagamentos to fetch.
     */
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pagamentos.
     */
    cursor?: PagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pagamentos.
     */
    distinct?: PagamentoScalarFieldEnum | PagamentoScalarFieldEnum[]
  }

  /**
   * Pagamento findMany
   */
  export type PagamentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamentos to fetch.
     */
    where?: PagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagamentos to fetch.
     */
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pagamentos.
     */
    cursor?: PagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagamentos.
     */
    skip?: number
    distinct?: PagamentoScalarFieldEnum | PagamentoScalarFieldEnum[]
  }

  /**
   * Pagamento create
   */
  export type PagamentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * The data needed to create a Pagamento.
     */
    data: XOR<PagamentoCreateInput, PagamentoUncheckedCreateInput>
  }

  /**
   * Pagamento createMany
   */
  export type PagamentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pagamentos.
     */
    data: PagamentoCreateManyInput | PagamentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pagamento createManyAndReturn
   */
  export type PagamentoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Pagamentos.
     */
    data: PagamentoCreateManyInput | PagamentoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pagamento update
   */
  export type PagamentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * The data needed to update a Pagamento.
     */
    data: XOR<PagamentoUpdateInput, PagamentoUncheckedUpdateInput>
    /**
     * Choose, which Pagamento to update.
     */
    where: PagamentoWhereUniqueInput
  }

  /**
   * Pagamento updateMany
   */
  export type PagamentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pagamentos.
     */
    data: XOR<PagamentoUpdateManyMutationInput, PagamentoUncheckedUpdateManyInput>
    /**
     * Filter which Pagamentos to update
     */
    where?: PagamentoWhereInput
  }

  /**
   * Pagamento upsert
   */
  export type PagamentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * The filter to search for the Pagamento to update in case it exists.
     */
    where: PagamentoWhereUniqueInput
    /**
     * In case the Pagamento found by the `where` argument doesn't exist, create a new Pagamento with this data.
     */
    create: XOR<PagamentoCreateInput, PagamentoUncheckedCreateInput>
    /**
     * In case the Pagamento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PagamentoUpdateInput, PagamentoUncheckedUpdateInput>
  }

  /**
   * Pagamento delete
   */
  export type PagamentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter which Pagamento to delete.
     */
    where: PagamentoWhereUniqueInput
  }

  /**
   * Pagamento deleteMany
   */
  export type PagamentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pagamentos to delete
     */
    where?: PagamentoWhereInput
  }

  /**
   * Pagamento without action
   */
  export type PagamentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
  }


  /**
   * Model Advogado
   */

  export type AggregateAdvogado = {
    _count: AdvogadoCountAggregateOutputType | null
    _avg: AdvogadoAvgAggregateOutputType | null
    _sum: AdvogadoSumAggregateOutputType | null
    _min: AdvogadoMinAggregateOutputType | null
    _max: AdvogadoMaxAggregateOutputType | null
  }

  export type AdvogadoAvgAggregateOutputType = {
    id: number | null
    valorFixoMensal: Decimal | null
  }

  export type AdvogadoSumAggregateOutputType = {
    id: number | null
    valorFixoMensal: Decimal | null
  }

  export type AdvogadoMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nome: string | null
    cpf: string | null
    email: string | null
    telefone: string | null
    tipo: $Enums.TipoAdvogado | null
    possuiFixoMensal: boolean | null
    valorFixoMensal: Decimal | null
    ativo: boolean | null
  }

  export type AdvogadoMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nome: string | null
    cpf: string | null
    email: string | null
    telefone: string | null
    tipo: $Enums.TipoAdvogado | null
    possuiFixoMensal: boolean | null
    valorFixoMensal: Decimal | null
    ativo: boolean | null
  }

  export type AdvogadoCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    nome: number
    cpf: number
    email: number
    telefone: number
    tipo: number
    possuiFixoMensal: number
    valorFixoMensal: number
    ativo: number
    _all: number
  }


  export type AdvogadoAvgAggregateInputType = {
    id?: true
    valorFixoMensal?: true
  }

  export type AdvogadoSumAggregateInputType = {
    id?: true
    valorFixoMensal?: true
  }

  export type AdvogadoMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nome?: true
    cpf?: true
    email?: true
    telefone?: true
    tipo?: true
    possuiFixoMensal?: true
    valorFixoMensal?: true
    ativo?: true
  }

  export type AdvogadoMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nome?: true
    cpf?: true
    email?: true
    telefone?: true
    tipo?: true
    possuiFixoMensal?: true
    valorFixoMensal?: true
    ativo?: true
  }

  export type AdvogadoCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nome?: true
    cpf?: true
    email?: true
    telefone?: true
    tipo?: true
    possuiFixoMensal?: true
    valorFixoMensal?: true
    ativo?: true
    _all?: true
  }

  export type AdvogadoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Advogado to aggregate.
     */
    where?: AdvogadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advogados to fetch.
     */
    orderBy?: AdvogadoOrderByWithRelationInput | AdvogadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdvogadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advogados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advogados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Advogados
    **/
    _count?: true | AdvogadoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdvogadoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdvogadoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdvogadoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdvogadoMaxAggregateInputType
  }

  export type GetAdvogadoAggregateType<T extends AdvogadoAggregateArgs> = {
        [P in keyof T & keyof AggregateAdvogado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdvogado[P]>
      : GetScalarType<T[P], AggregateAdvogado[P]>
  }




  export type AdvogadoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdvogadoWhereInput
    orderBy?: AdvogadoOrderByWithAggregationInput | AdvogadoOrderByWithAggregationInput[]
    by: AdvogadoScalarFieldEnum[] | AdvogadoScalarFieldEnum
    having?: AdvogadoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdvogadoCountAggregateInputType | true
    _avg?: AdvogadoAvgAggregateInputType
    _sum?: AdvogadoSumAggregateInputType
    _min?: AdvogadoMinAggregateInputType
    _max?: AdvogadoMaxAggregateInputType
  }

  export type AdvogadoGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    nome: string
    cpf: string | null
    email: string | null
    telefone: string | null
    tipo: $Enums.TipoAdvogado
    possuiFixoMensal: boolean
    valorFixoMensal: Decimal | null
    ativo: boolean
    _count: AdvogadoCountAggregateOutputType | null
    _avg: AdvogadoAvgAggregateOutputType | null
    _sum: AdvogadoSumAggregateOutputType | null
    _min: AdvogadoMinAggregateOutputType | null
    _max: AdvogadoMaxAggregateOutputType | null
  }

  type GetAdvogadoGroupByPayload<T extends AdvogadoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdvogadoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdvogadoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdvogadoGroupByOutputType[P]>
            : GetScalarType<T[P], AdvogadoGroupByOutputType[P]>
        }
      >
    >


  export type AdvogadoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nome?: boolean
    cpf?: boolean
    email?: boolean
    telefone?: boolean
    tipo?: boolean
    possuiFixoMensal?: boolean
    valorFixoMensal?: boolean
    ativo?: boolean
    repasses?: boolean | Advogado$repassesArgs<ExtArgs>
    _count?: boolean | AdvogadoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["advogado"]>

  export type AdvogadoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nome?: boolean
    cpf?: boolean
    email?: boolean
    telefone?: boolean
    tipo?: boolean
    possuiFixoMensal?: boolean
    valorFixoMensal?: boolean
    ativo?: boolean
  }, ExtArgs["result"]["advogado"]>

  export type AdvogadoSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nome?: boolean
    cpf?: boolean
    email?: boolean
    telefone?: boolean
    tipo?: boolean
    possuiFixoMensal?: boolean
    valorFixoMensal?: boolean
    ativo?: boolean
  }

  export type AdvogadoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    repasses?: boolean | Advogado$repassesArgs<ExtArgs>
    _count?: boolean | AdvogadoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdvogadoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AdvogadoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Advogado"
    objects: {
      repasses: Prisma.$RepassePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      nome: string
      cpf: string | null
      email: string | null
      telefone: string | null
      tipo: $Enums.TipoAdvogado
      possuiFixoMensal: boolean
      valorFixoMensal: Prisma.Decimal | null
      ativo: boolean
    }, ExtArgs["result"]["advogado"]>
    composites: {}
  }

  type AdvogadoGetPayload<S extends boolean | null | undefined | AdvogadoDefaultArgs> = $Result.GetResult<Prisma.$AdvogadoPayload, S>

  type AdvogadoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdvogadoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdvogadoCountAggregateInputType | true
    }

  export interface AdvogadoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Advogado'], meta: { name: 'Advogado' } }
    /**
     * Find zero or one Advogado that matches the filter.
     * @param {AdvogadoFindUniqueArgs} args - Arguments to find a Advogado
     * @example
     * // Get one Advogado
     * const advogado = await prisma.advogado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdvogadoFindUniqueArgs>(args: SelectSubset<T, AdvogadoFindUniqueArgs<ExtArgs>>): Prisma__AdvogadoClient<$Result.GetResult<Prisma.$AdvogadoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Advogado that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdvogadoFindUniqueOrThrowArgs} args - Arguments to find a Advogado
     * @example
     * // Get one Advogado
     * const advogado = await prisma.advogado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdvogadoFindUniqueOrThrowArgs>(args: SelectSubset<T, AdvogadoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdvogadoClient<$Result.GetResult<Prisma.$AdvogadoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Advogado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvogadoFindFirstArgs} args - Arguments to find a Advogado
     * @example
     * // Get one Advogado
     * const advogado = await prisma.advogado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdvogadoFindFirstArgs>(args?: SelectSubset<T, AdvogadoFindFirstArgs<ExtArgs>>): Prisma__AdvogadoClient<$Result.GetResult<Prisma.$AdvogadoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Advogado that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvogadoFindFirstOrThrowArgs} args - Arguments to find a Advogado
     * @example
     * // Get one Advogado
     * const advogado = await prisma.advogado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdvogadoFindFirstOrThrowArgs>(args?: SelectSubset<T, AdvogadoFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdvogadoClient<$Result.GetResult<Prisma.$AdvogadoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Advogados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvogadoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Advogados
     * const advogados = await prisma.advogado.findMany()
     * 
     * // Get first 10 Advogados
     * const advogados = await prisma.advogado.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const advogadoWithIdOnly = await prisma.advogado.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdvogadoFindManyArgs>(args?: SelectSubset<T, AdvogadoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvogadoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Advogado.
     * @param {AdvogadoCreateArgs} args - Arguments to create a Advogado.
     * @example
     * // Create one Advogado
     * const Advogado = await prisma.advogado.create({
     *   data: {
     *     // ... data to create a Advogado
     *   }
     * })
     * 
     */
    create<T extends AdvogadoCreateArgs>(args: SelectSubset<T, AdvogadoCreateArgs<ExtArgs>>): Prisma__AdvogadoClient<$Result.GetResult<Prisma.$AdvogadoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Advogados.
     * @param {AdvogadoCreateManyArgs} args - Arguments to create many Advogados.
     * @example
     * // Create many Advogados
     * const advogado = await prisma.advogado.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdvogadoCreateManyArgs>(args?: SelectSubset<T, AdvogadoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Advogados and returns the data saved in the database.
     * @param {AdvogadoCreateManyAndReturnArgs} args - Arguments to create many Advogados.
     * @example
     * // Create many Advogados
     * const advogado = await prisma.advogado.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Advogados and only return the `id`
     * const advogadoWithIdOnly = await prisma.advogado.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdvogadoCreateManyAndReturnArgs>(args?: SelectSubset<T, AdvogadoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvogadoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Advogado.
     * @param {AdvogadoDeleteArgs} args - Arguments to delete one Advogado.
     * @example
     * // Delete one Advogado
     * const Advogado = await prisma.advogado.delete({
     *   where: {
     *     // ... filter to delete one Advogado
     *   }
     * })
     * 
     */
    delete<T extends AdvogadoDeleteArgs>(args: SelectSubset<T, AdvogadoDeleteArgs<ExtArgs>>): Prisma__AdvogadoClient<$Result.GetResult<Prisma.$AdvogadoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Advogado.
     * @param {AdvogadoUpdateArgs} args - Arguments to update one Advogado.
     * @example
     * // Update one Advogado
     * const advogado = await prisma.advogado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdvogadoUpdateArgs>(args: SelectSubset<T, AdvogadoUpdateArgs<ExtArgs>>): Prisma__AdvogadoClient<$Result.GetResult<Prisma.$AdvogadoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Advogados.
     * @param {AdvogadoDeleteManyArgs} args - Arguments to filter Advogados to delete.
     * @example
     * // Delete a few Advogados
     * const { count } = await prisma.advogado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdvogadoDeleteManyArgs>(args?: SelectSubset<T, AdvogadoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Advogados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvogadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Advogados
     * const advogado = await prisma.advogado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdvogadoUpdateManyArgs>(args: SelectSubset<T, AdvogadoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Advogado.
     * @param {AdvogadoUpsertArgs} args - Arguments to update or create a Advogado.
     * @example
     * // Update or create a Advogado
     * const advogado = await prisma.advogado.upsert({
     *   create: {
     *     // ... data to create a Advogado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Advogado we want to update
     *   }
     * })
     */
    upsert<T extends AdvogadoUpsertArgs>(args: SelectSubset<T, AdvogadoUpsertArgs<ExtArgs>>): Prisma__AdvogadoClient<$Result.GetResult<Prisma.$AdvogadoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Advogados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvogadoCountArgs} args - Arguments to filter Advogados to count.
     * @example
     * // Count the number of Advogados
     * const count = await prisma.advogado.count({
     *   where: {
     *     // ... the filter for the Advogados we want to count
     *   }
     * })
    **/
    count<T extends AdvogadoCountArgs>(
      args?: Subset<T, AdvogadoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdvogadoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Advogado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvogadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdvogadoAggregateArgs>(args: Subset<T, AdvogadoAggregateArgs>): Prisma.PrismaPromise<GetAdvogadoAggregateType<T>>

    /**
     * Group by Advogado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvogadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdvogadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdvogadoGroupByArgs['orderBy'] }
        : { orderBy?: AdvogadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdvogadoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdvogadoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Advogado model
   */
  readonly fields: AdvogadoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Advogado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdvogadoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    repasses<T extends Advogado$repassesArgs<ExtArgs> = {}>(args?: Subset<T, Advogado$repassesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepassePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Advogado model
   */ 
  interface AdvogadoFieldRefs {
    readonly id: FieldRef<"Advogado", 'Int'>
    readonly createdAt: FieldRef<"Advogado", 'DateTime'>
    readonly updatedAt: FieldRef<"Advogado", 'DateTime'>
    readonly nome: FieldRef<"Advogado", 'String'>
    readonly cpf: FieldRef<"Advogado", 'String'>
    readonly email: FieldRef<"Advogado", 'String'>
    readonly telefone: FieldRef<"Advogado", 'String'>
    readonly tipo: FieldRef<"Advogado", 'TipoAdvogado'>
    readonly possuiFixoMensal: FieldRef<"Advogado", 'Boolean'>
    readonly valorFixoMensal: FieldRef<"Advogado", 'Decimal'>
    readonly ativo: FieldRef<"Advogado", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Advogado findUnique
   */
  export type AdvogadoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advogado
     */
    select?: AdvogadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvogadoInclude<ExtArgs> | null
    /**
     * Filter, which Advogado to fetch.
     */
    where: AdvogadoWhereUniqueInput
  }

  /**
   * Advogado findUniqueOrThrow
   */
  export type AdvogadoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advogado
     */
    select?: AdvogadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvogadoInclude<ExtArgs> | null
    /**
     * Filter, which Advogado to fetch.
     */
    where: AdvogadoWhereUniqueInput
  }

  /**
   * Advogado findFirst
   */
  export type AdvogadoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advogado
     */
    select?: AdvogadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvogadoInclude<ExtArgs> | null
    /**
     * Filter, which Advogado to fetch.
     */
    where?: AdvogadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advogados to fetch.
     */
    orderBy?: AdvogadoOrderByWithRelationInput | AdvogadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Advogados.
     */
    cursor?: AdvogadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advogados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advogados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Advogados.
     */
    distinct?: AdvogadoScalarFieldEnum | AdvogadoScalarFieldEnum[]
  }

  /**
   * Advogado findFirstOrThrow
   */
  export type AdvogadoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advogado
     */
    select?: AdvogadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvogadoInclude<ExtArgs> | null
    /**
     * Filter, which Advogado to fetch.
     */
    where?: AdvogadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advogados to fetch.
     */
    orderBy?: AdvogadoOrderByWithRelationInput | AdvogadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Advogados.
     */
    cursor?: AdvogadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advogados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advogados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Advogados.
     */
    distinct?: AdvogadoScalarFieldEnum | AdvogadoScalarFieldEnum[]
  }

  /**
   * Advogado findMany
   */
  export type AdvogadoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advogado
     */
    select?: AdvogadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvogadoInclude<ExtArgs> | null
    /**
     * Filter, which Advogados to fetch.
     */
    where?: AdvogadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advogados to fetch.
     */
    orderBy?: AdvogadoOrderByWithRelationInput | AdvogadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Advogados.
     */
    cursor?: AdvogadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advogados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advogados.
     */
    skip?: number
    distinct?: AdvogadoScalarFieldEnum | AdvogadoScalarFieldEnum[]
  }

  /**
   * Advogado create
   */
  export type AdvogadoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advogado
     */
    select?: AdvogadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvogadoInclude<ExtArgs> | null
    /**
     * The data needed to create a Advogado.
     */
    data: XOR<AdvogadoCreateInput, AdvogadoUncheckedCreateInput>
  }

  /**
   * Advogado createMany
   */
  export type AdvogadoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Advogados.
     */
    data: AdvogadoCreateManyInput | AdvogadoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Advogado createManyAndReturn
   */
  export type AdvogadoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advogado
     */
    select?: AdvogadoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Advogados.
     */
    data: AdvogadoCreateManyInput | AdvogadoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Advogado update
   */
  export type AdvogadoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advogado
     */
    select?: AdvogadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvogadoInclude<ExtArgs> | null
    /**
     * The data needed to update a Advogado.
     */
    data: XOR<AdvogadoUpdateInput, AdvogadoUncheckedUpdateInput>
    /**
     * Choose, which Advogado to update.
     */
    where: AdvogadoWhereUniqueInput
  }

  /**
   * Advogado updateMany
   */
  export type AdvogadoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Advogados.
     */
    data: XOR<AdvogadoUpdateManyMutationInput, AdvogadoUncheckedUpdateManyInput>
    /**
     * Filter which Advogados to update
     */
    where?: AdvogadoWhereInput
  }

  /**
   * Advogado upsert
   */
  export type AdvogadoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advogado
     */
    select?: AdvogadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvogadoInclude<ExtArgs> | null
    /**
     * The filter to search for the Advogado to update in case it exists.
     */
    where: AdvogadoWhereUniqueInput
    /**
     * In case the Advogado found by the `where` argument doesn't exist, create a new Advogado with this data.
     */
    create: XOR<AdvogadoCreateInput, AdvogadoUncheckedCreateInput>
    /**
     * In case the Advogado was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdvogadoUpdateInput, AdvogadoUncheckedUpdateInput>
  }

  /**
   * Advogado delete
   */
  export type AdvogadoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advogado
     */
    select?: AdvogadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvogadoInclude<ExtArgs> | null
    /**
     * Filter which Advogado to delete.
     */
    where: AdvogadoWhereUniqueInput
  }

  /**
   * Advogado deleteMany
   */
  export type AdvogadoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Advogados to delete
     */
    where?: AdvogadoWhereInput
  }

  /**
   * Advogado.repasses
   */
  export type Advogado$repassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repasse
     */
    select?: RepasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepasseInclude<ExtArgs> | null
    where?: RepasseWhereInput
    orderBy?: RepasseOrderByWithRelationInput | RepasseOrderByWithRelationInput[]
    cursor?: RepasseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RepasseScalarFieldEnum | RepasseScalarFieldEnum[]
  }

  /**
   * Advogado without action
   */
  export type AdvogadoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advogado
     */
    select?: AdvogadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvogadoInclude<ExtArgs> | null
  }


  /**
   * Model Repasse
   */

  export type AggregateRepasse = {
    _count: RepasseCountAggregateOutputType | null
    _avg: RepasseAvgAggregateOutputType | null
    _sum: RepasseSumAggregateOutputType | null
    _min: RepasseMinAggregateOutputType | null
    _max: RepasseMaxAggregateOutputType | null
  }

  export type RepasseAvgAggregateOutputType = {
    id: number | null
    advogadoId: number | null
    ordemPagamentoId: number | null
    valorDevido: Decimal | null
    valorPago: Decimal | null
    saldoAReceber: Decimal | null
  }

  export type RepasseSumAggregateOutputType = {
    id: number | null
    advogadoId: number | null
    ordemPagamentoId: number | null
    valorDevido: Decimal | null
    valorPago: Decimal | null
    saldoAReceber: Decimal | null
  }

  export type RepasseMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    advogadoId: number | null
    ordemPagamentoId: number | null
    referenciaCompetencia: string | null
    valorDevido: Decimal | null
    valorPago: Decimal | null
    dataPagamento: Date | null
    saldoAReceber: Decimal | null
    origem: $Enums.OrigemRepasse | null
    modeloDistribuicaoCodigo: string | null
    observacoes: string | null
  }

  export type RepasseMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    advogadoId: number | null
    ordemPagamentoId: number | null
    referenciaCompetencia: string | null
    valorDevido: Decimal | null
    valorPago: Decimal | null
    dataPagamento: Date | null
    saldoAReceber: Decimal | null
    origem: $Enums.OrigemRepasse | null
    modeloDistribuicaoCodigo: string | null
    observacoes: string | null
  }

  export type RepasseCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    advogadoId: number
    ordemPagamentoId: number
    referenciaCompetencia: number
    valorDevido: number
    valorPago: number
    dataPagamento: number
    saldoAReceber: number
    origem: number
    modeloDistribuicaoCodigo: number
    observacoes: number
    _all: number
  }


  export type RepasseAvgAggregateInputType = {
    id?: true
    advogadoId?: true
    ordemPagamentoId?: true
    valorDevido?: true
    valorPago?: true
    saldoAReceber?: true
  }

  export type RepasseSumAggregateInputType = {
    id?: true
    advogadoId?: true
    ordemPagamentoId?: true
    valorDevido?: true
    valorPago?: true
    saldoAReceber?: true
  }

  export type RepasseMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    advogadoId?: true
    ordemPagamentoId?: true
    referenciaCompetencia?: true
    valorDevido?: true
    valorPago?: true
    dataPagamento?: true
    saldoAReceber?: true
    origem?: true
    modeloDistribuicaoCodigo?: true
    observacoes?: true
  }

  export type RepasseMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    advogadoId?: true
    ordemPagamentoId?: true
    referenciaCompetencia?: true
    valorDevido?: true
    valorPago?: true
    dataPagamento?: true
    saldoAReceber?: true
    origem?: true
    modeloDistribuicaoCodigo?: true
    observacoes?: true
  }

  export type RepasseCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    advogadoId?: true
    ordemPagamentoId?: true
    referenciaCompetencia?: true
    valorDevido?: true
    valorPago?: true
    dataPagamento?: true
    saldoAReceber?: true
    origem?: true
    modeloDistribuicaoCodigo?: true
    observacoes?: true
    _all?: true
  }

  export type RepasseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Repasse to aggregate.
     */
    where?: RepasseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Repasses to fetch.
     */
    orderBy?: RepasseOrderByWithRelationInput | RepasseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RepasseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Repasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Repasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Repasses
    **/
    _count?: true | RepasseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RepasseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RepasseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RepasseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RepasseMaxAggregateInputType
  }

  export type GetRepasseAggregateType<T extends RepasseAggregateArgs> = {
        [P in keyof T & keyof AggregateRepasse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRepasse[P]>
      : GetScalarType<T[P], AggregateRepasse[P]>
  }




  export type RepasseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RepasseWhereInput
    orderBy?: RepasseOrderByWithAggregationInput | RepasseOrderByWithAggregationInput[]
    by: RepasseScalarFieldEnum[] | RepasseScalarFieldEnum
    having?: RepasseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RepasseCountAggregateInputType | true
    _avg?: RepasseAvgAggregateInputType
    _sum?: RepasseSumAggregateInputType
    _min?: RepasseMinAggregateInputType
    _max?: RepasseMaxAggregateInputType
  }

  export type RepasseGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    advogadoId: number
    ordemPagamentoId: number | null
    referenciaCompetencia: string
    valorDevido: Decimal
    valorPago: Decimal | null
    dataPagamento: Date | null
    saldoAReceber: Decimal | null
    origem: $Enums.OrigemRepasse
    modeloDistribuicaoCodigo: string | null
    observacoes: string | null
    _count: RepasseCountAggregateOutputType | null
    _avg: RepasseAvgAggregateOutputType | null
    _sum: RepasseSumAggregateOutputType | null
    _min: RepasseMinAggregateOutputType | null
    _max: RepasseMaxAggregateOutputType | null
  }

  type GetRepasseGroupByPayload<T extends RepasseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RepasseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RepasseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RepasseGroupByOutputType[P]>
            : GetScalarType<T[P], RepasseGroupByOutputType[P]>
        }
      >
    >


  export type RepasseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    advogadoId?: boolean
    ordemPagamentoId?: boolean
    referenciaCompetencia?: boolean
    valorDevido?: boolean
    valorPago?: boolean
    dataPagamento?: boolean
    saldoAReceber?: boolean
    origem?: boolean
    modeloDistribuicaoCodigo?: boolean
    observacoes?: boolean
    advogado?: boolean | AdvogadoDefaultArgs<ExtArgs>
    ordemPagamento?: boolean | Repasse$ordemPagamentoArgs<ExtArgs>
  }, ExtArgs["result"]["repasse"]>

  export type RepasseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    advogadoId?: boolean
    ordemPagamentoId?: boolean
    referenciaCompetencia?: boolean
    valorDevido?: boolean
    valorPago?: boolean
    dataPagamento?: boolean
    saldoAReceber?: boolean
    origem?: boolean
    modeloDistribuicaoCodigo?: boolean
    observacoes?: boolean
    advogado?: boolean | AdvogadoDefaultArgs<ExtArgs>
    ordemPagamento?: boolean | Repasse$ordemPagamentoArgs<ExtArgs>
  }, ExtArgs["result"]["repasse"]>

  export type RepasseSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    advogadoId?: boolean
    ordemPagamentoId?: boolean
    referenciaCompetencia?: boolean
    valorDevido?: boolean
    valorPago?: boolean
    dataPagamento?: boolean
    saldoAReceber?: boolean
    origem?: boolean
    modeloDistribuicaoCodigo?: boolean
    observacoes?: boolean
  }

  export type RepasseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    advogado?: boolean | AdvogadoDefaultArgs<ExtArgs>
    ordemPagamento?: boolean | Repasse$ordemPagamentoArgs<ExtArgs>
  }
  export type RepasseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    advogado?: boolean | AdvogadoDefaultArgs<ExtArgs>
    ordemPagamento?: boolean | Repasse$ordemPagamentoArgs<ExtArgs>
  }

  export type $RepassePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Repasse"
    objects: {
      advogado: Prisma.$AdvogadoPayload<ExtArgs>
      ordemPagamento: Prisma.$OrdemPagamentoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      advogadoId: number
      ordemPagamentoId: number | null
      referenciaCompetencia: string
      valorDevido: Prisma.Decimal
      valorPago: Prisma.Decimal | null
      dataPagamento: Date | null
      saldoAReceber: Prisma.Decimal | null
      origem: $Enums.OrigemRepasse
      modeloDistribuicaoCodigo: string | null
      observacoes: string | null
    }, ExtArgs["result"]["repasse"]>
    composites: {}
  }

  type RepasseGetPayload<S extends boolean | null | undefined | RepasseDefaultArgs> = $Result.GetResult<Prisma.$RepassePayload, S>

  type RepasseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RepasseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RepasseCountAggregateInputType | true
    }

  export interface RepasseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Repasse'], meta: { name: 'Repasse' } }
    /**
     * Find zero or one Repasse that matches the filter.
     * @param {RepasseFindUniqueArgs} args - Arguments to find a Repasse
     * @example
     * // Get one Repasse
     * const repasse = await prisma.repasse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RepasseFindUniqueArgs>(args: SelectSubset<T, RepasseFindUniqueArgs<ExtArgs>>): Prisma__RepasseClient<$Result.GetResult<Prisma.$RepassePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Repasse that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RepasseFindUniqueOrThrowArgs} args - Arguments to find a Repasse
     * @example
     * // Get one Repasse
     * const repasse = await prisma.repasse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RepasseFindUniqueOrThrowArgs>(args: SelectSubset<T, RepasseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RepasseClient<$Result.GetResult<Prisma.$RepassePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Repasse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepasseFindFirstArgs} args - Arguments to find a Repasse
     * @example
     * // Get one Repasse
     * const repasse = await prisma.repasse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RepasseFindFirstArgs>(args?: SelectSubset<T, RepasseFindFirstArgs<ExtArgs>>): Prisma__RepasseClient<$Result.GetResult<Prisma.$RepassePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Repasse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepasseFindFirstOrThrowArgs} args - Arguments to find a Repasse
     * @example
     * // Get one Repasse
     * const repasse = await prisma.repasse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RepasseFindFirstOrThrowArgs>(args?: SelectSubset<T, RepasseFindFirstOrThrowArgs<ExtArgs>>): Prisma__RepasseClient<$Result.GetResult<Prisma.$RepassePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Repasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepasseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Repasses
     * const repasses = await prisma.repasse.findMany()
     * 
     * // Get first 10 Repasses
     * const repasses = await prisma.repasse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const repasseWithIdOnly = await prisma.repasse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RepasseFindManyArgs>(args?: SelectSubset<T, RepasseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepassePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Repasse.
     * @param {RepasseCreateArgs} args - Arguments to create a Repasse.
     * @example
     * // Create one Repasse
     * const Repasse = await prisma.repasse.create({
     *   data: {
     *     // ... data to create a Repasse
     *   }
     * })
     * 
     */
    create<T extends RepasseCreateArgs>(args: SelectSubset<T, RepasseCreateArgs<ExtArgs>>): Prisma__RepasseClient<$Result.GetResult<Prisma.$RepassePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Repasses.
     * @param {RepasseCreateManyArgs} args - Arguments to create many Repasses.
     * @example
     * // Create many Repasses
     * const repasse = await prisma.repasse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RepasseCreateManyArgs>(args?: SelectSubset<T, RepasseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Repasses and returns the data saved in the database.
     * @param {RepasseCreateManyAndReturnArgs} args - Arguments to create many Repasses.
     * @example
     * // Create many Repasses
     * const repasse = await prisma.repasse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Repasses and only return the `id`
     * const repasseWithIdOnly = await prisma.repasse.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RepasseCreateManyAndReturnArgs>(args?: SelectSubset<T, RepasseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepassePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Repasse.
     * @param {RepasseDeleteArgs} args - Arguments to delete one Repasse.
     * @example
     * // Delete one Repasse
     * const Repasse = await prisma.repasse.delete({
     *   where: {
     *     // ... filter to delete one Repasse
     *   }
     * })
     * 
     */
    delete<T extends RepasseDeleteArgs>(args: SelectSubset<T, RepasseDeleteArgs<ExtArgs>>): Prisma__RepasseClient<$Result.GetResult<Prisma.$RepassePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Repasse.
     * @param {RepasseUpdateArgs} args - Arguments to update one Repasse.
     * @example
     * // Update one Repasse
     * const repasse = await prisma.repasse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RepasseUpdateArgs>(args: SelectSubset<T, RepasseUpdateArgs<ExtArgs>>): Prisma__RepasseClient<$Result.GetResult<Prisma.$RepassePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Repasses.
     * @param {RepasseDeleteManyArgs} args - Arguments to filter Repasses to delete.
     * @example
     * // Delete a few Repasses
     * const { count } = await prisma.repasse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RepasseDeleteManyArgs>(args?: SelectSubset<T, RepasseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Repasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepasseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Repasses
     * const repasse = await prisma.repasse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RepasseUpdateManyArgs>(args: SelectSubset<T, RepasseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Repasse.
     * @param {RepasseUpsertArgs} args - Arguments to update or create a Repasse.
     * @example
     * // Update or create a Repasse
     * const repasse = await prisma.repasse.upsert({
     *   create: {
     *     // ... data to create a Repasse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Repasse we want to update
     *   }
     * })
     */
    upsert<T extends RepasseUpsertArgs>(args: SelectSubset<T, RepasseUpsertArgs<ExtArgs>>): Prisma__RepasseClient<$Result.GetResult<Prisma.$RepassePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Repasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepasseCountArgs} args - Arguments to filter Repasses to count.
     * @example
     * // Count the number of Repasses
     * const count = await prisma.repasse.count({
     *   where: {
     *     // ... the filter for the Repasses we want to count
     *   }
     * })
    **/
    count<T extends RepasseCountArgs>(
      args?: Subset<T, RepasseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RepasseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Repasse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepasseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RepasseAggregateArgs>(args: Subset<T, RepasseAggregateArgs>): Prisma.PrismaPromise<GetRepasseAggregateType<T>>

    /**
     * Group by Repasse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepasseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RepasseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RepasseGroupByArgs['orderBy'] }
        : { orderBy?: RepasseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RepasseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRepasseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Repasse model
   */
  readonly fields: RepasseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Repasse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RepasseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    advogado<T extends AdvogadoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdvogadoDefaultArgs<ExtArgs>>): Prisma__AdvogadoClient<$Result.GetResult<Prisma.$AdvogadoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ordemPagamento<T extends Repasse$ordemPagamentoArgs<ExtArgs> = {}>(args?: Subset<T, Repasse$ordemPagamentoArgs<ExtArgs>>): Prisma__OrdemPagamentoClient<$Result.GetResult<Prisma.$OrdemPagamentoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Repasse model
   */ 
  interface RepasseFieldRefs {
    readonly id: FieldRef<"Repasse", 'Int'>
    readonly createdAt: FieldRef<"Repasse", 'DateTime'>
    readonly updatedAt: FieldRef<"Repasse", 'DateTime'>
    readonly advogadoId: FieldRef<"Repasse", 'Int'>
    readonly ordemPagamentoId: FieldRef<"Repasse", 'Int'>
    readonly referenciaCompetencia: FieldRef<"Repasse", 'String'>
    readonly valorDevido: FieldRef<"Repasse", 'Decimal'>
    readonly valorPago: FieldRef<"Repasse", 'Decimal'>
    readonly dataPagamento: FieldRef<"Repasse", 'DateTime'>
    readonly saldoAReceber: FieldRef<"Repasse", 'Decimal'>
    readonly origem: FieldRef<"Repasse", 'OrigemRepasse'>
    readonly modeloDistribuicaoCodigo: FieldRef<"Repasse", 'String'>
    readonly observacoes: FieldRef<"Repasse", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Repasse findUnique
   */
  export type RepasseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repasse
     */
    select?: RepasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepasseInclude<ExtArgs> | null
    /**
     * Filter, which Repasse to fetch.
     */
    where: RepasseWhereUniqueInput
  }

  /**
   * Repasse findUniqueOrThrow
   */
  export type RepasseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repasse
     */
    select?: RepasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepasseInclude<ExtArgs> | null
    /**
     * Filter, which Repasse to fetch.
     */
    where: RepasseWhereUniqueInput
  }

  /**
   * Repasse findFirst
   */
  export type RepasseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repasse
     */
    select?: RepasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepasseInclude<ExtArgs> | null
    /**
     * Filter, which Repasse to fetch.
     */
    where?: RepasseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Repasses to fetch.
     */
    orderBy?: RepasseOrderByWithRelationInput | RepasseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Repasses.
     */
    cursor?: RepasseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Repasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Repasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Repasses.
     */
    distinct?: RepasseScalarFieldEnum | RepasseScalarFieldEnum[]
  }

  /**
   * Repasse findFirstOrThrow
   */
  export type RepasseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repasse
     */
    select?: RepasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepasseInclude<ExtArgs> | null
    /**
     * Filter, which Repasse to fetch.
     */
    where?: RepasseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Repasses to fetch.
     */
    orderBy?: RepasseOrderByWithRelationInput | RepasseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Repasses.
     */
    cursor?: RepasseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Repasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Repasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Repasses.
     */
    distinct?: RepasseScalarFieldEnum | RepasseScalarFieldEnum[]
  }

  /**
   * Repasse findMany
   */
  export type RepasseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repasse
     */
    select?: RepasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepasseInclude<ExtArgs> | null
    /**
     * Filter, which Repasses to fetch.
     */
    where?: RepasseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Repasses to fetch.
     */
    orderBy?: RepasseOrderByWithRelationInput | RepasseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Repasses.
     */
    cursor?: RepasseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Repasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Repasses.
     */
    skip?: number
    distinct?: RepasseScalarFieldEnum | RepasseScalarFieldEnum[]
  }

  /**
   * Repasse create
   */
  export type RepasseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repasse
     */
    select?: RepasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepasseInclude<ExtArgs> | null
    /**
     * The data needed to create a Repasse.
     */
    data: XOR<RepasseCreateInput, RepasseUncheckedCreateInput>
  }

  /**
   * Repasse createMany
   */
  export type RepasseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Repasses.
     */
    data: RepasseCreateManyInput | RepasseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Repasse createManyAndReturn
   */
  export type RepasseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repasse
     */
    select?: RepasseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Repasses.
     */
    data: RepasseCreateManyInput | RepasseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepasseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Repasse update
   */
  export type RepasseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repasse
     */
    select?: RepasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepasseInclude<ExtArgs> | null
    /**
     * The data needed to update a Repasse.
     */
    data: XOR<RepasseUpdateInput, RepasseUncheckedUpdateInput>
    /**
     * Choose, which Repasse to update.
     */
    where: RepasseWhereUniqueInput
  }

  /**
   * Repasse updateMany
   */
  export type RepasseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Repasses.
     */
    data: XOR<RepasseUpdateManyMutationInput, RepasseUncheckedUpdateManyInput>
    /**
     * Filter which Repasses to update
     */
    where?: RepasseWhereInput
  }

  /**
   * Repasse upsert
   */
  export type RepasseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repasse
     */
    select?: RepasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepasseInclude<ExtArgs> | null
    /**
     * The filter to search for the Repasse to update in case it exists.
     */
    where: RepasseWhereUniqueInput
    /**
     * In case the Repasse found by the `where` argument doesn't exist, create a new Repasse with this data.
     */
    create: XOR<RepasseCreateInput, RepasseUncheckedCreateInput>
    /**
     * In case the Repasse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RepasseUpdateInput, RepasseUncheckedUpdateInput>
  }

  /**
   * Repasse delete
   */
  export type RepasseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repasse
     */
    select?: RepasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepasseInclude<ExtArgs> | null
    /**
     * Filter which Repasse to delete.
     */
    where: RepasseWhereUniqueInput
  }

  /**
   * Repasse deleteMany
   */
  export type RepasseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Repasses to delete
     */
    where?: RepasseWhereInput
  }

  /**
   * Repasse.ordemPagamento
   */
  export type Repasse$ordemPagamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdemPagamento
     */
    select?: OrdemPagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdemPagamentoInclude<ExtArgs> | null
    where?: OrdemPagamentoWhereInput
  }

  /**
   * Repasse without action
   */
  export type RepasseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repasse
     */
    select?: RepasseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepasseInclude<ExtArgs> | null
  }


  /**
   * Model Estagiario
   */

  export type AggregateEstagiario = {
    _count: EstagiarioCountAggregateOutputType | null
    _avg: EstagiarioAvgAggregateOutputType | null
    _sum: EstagiarioSumAggregateOutputType | null
    _min: EstagiarioMinAggregateOutputType | null
    _max: EstagiarioMaxAggregateOutputType | null
  }

  export type EstagiarioAvgAggregateOutputType = {
    id: number | null
    auxilioTransporteValor: Decimal | null
    auxilioEstagioValor: Decimal | null
  }

  export type EstagiarioSumAggregateOutputType = {
    id: number | null
    auxilioTransporteValor: Decimal | null
    auxilioEstagioValor: Decimal | null
  }

  export type EstagiarioMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nome: string | null
    cpf: string | null
    email: string | null
    telefone: string | null
    auxilioTransporteValor: Decimal | null
    auxilioEstagioValor: Decimal | null
    ativo: boolean | null
  }

  export type EstagiarioMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nome: string | null
    cpf: string | null
    email: string | null
    telefone: string | null
    auxilioTransporteValor: Decimal | null
    auxilioEstagioValor: Decimal | null
    ativo: boolean | null
  }

  export type EstagiarioCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    nome: number
    cpf: number
    email: number
    telefone: number
    auxilioTransporteValor: number
    auxilioEstagioValor: number
    ativo: number
    _all: number
  }


  export type EstagiarioAvgAggregateInputType = {
    id?: true
    auxilioTransporteValor?: true
    auxilioEstagioValor?: true
  }

  export type EstagiarioSumAggregateInputType = {
    id?: true
    auxilioTransporteValor?: true
    auxilioEstagioValor?: true
  }

  export type EstagiarioMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nome?: true
    cpf?: true
    email?: true
    telefone?: true
    auxilioTransporteValor?: true
    auxilioEstagioValor?: true
    ativo?: true
  }

  export type EstagiarioMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nome?: true
    cpf?: true
    email?: true
    telefone?: true
    auxilioTransporteValor?: true
    auxilioEstagioValor?: true
    ativo?: true
  }

  export type EstagiarioCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nome?: true
    cpf?: true
    email?: true
    telefone?: true
    auxilioTransporteValor?: true
    auxilioEstagioValor?: true
    ativo?: true
    _all?: true
  }

  export type EstagiarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Estagiario to aggregate.
     */
    where?: EstagiarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estagiarios to fetch.
     */
    orderBy?: EstagiarioOrderByWithRelationInput | EstagiarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EstagiarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estagiarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estagiarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Estagiarios
    **/
    _count?: true | EstagiarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EstagiarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EstagiarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EstagiarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EstagiarioMaxAggregateInputType
  }

  export type GetEstagiarioAggregateType<T extends EstagiarioAggregateArgs> = {
        [P in keyof T & keyof AggregateEstagiario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstagiario[P]>
      : GetScalarType<T[P], AggregateEstagiario[P]>
  }




  export type EstagiarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EstagiarioWhereInput
    orderBy?: EstagiarioOrderByWithAggregationInput | EstagiarioOrderByWithAggregationInput[]
    by: EstagiarioScalarFieldEnum[] | EstagiarioScalarFieldEnum
    having?: EstagiarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EstagiarioCountAggregateInputType | true
    _avg?: EstagiarioAvgAggregateInputType
    _sum?: EstagiarioSumAggregateInputType
    _min?: EstagiarioMinAggregateInputType
    _max?: EstagiarioMaxAggregateInputType
  }

  export type EstagiarioGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    nome: string
    cpf: string | null
    email: string | null
    telefone: string | null
    auxilioTransporteValor: Decimal | null
    auxilioEstagioValor: Decimal | null
    ativo: boolean
    _count: EstagiarioCountAggregateOutputType | null
    _avg: EstagiarioAvgAggregateOutputType | null
    _sum: EstagiarioSumAggregateOutputType | null
    _min: EstagiarioMinAggregateOutputType | null
    _max: EstagiarioMaxAggregateOutputType | null
  }

  type GetEstagiarioGroupByPayload<T extends EstagiarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EstagiarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EstagiarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EstagiarioGroupByOutputType[P]>
            : GetScalarType<T[P], EstagiarioGroupByOutputType[P]>
        }
      >
    >


  export type EstagiarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nome?: boolean
    cpf?: boolean
    email?: boolean
    telefone?: boolean
    auxilioTransporteValor?: boolean
    auxilioEstagioValor?: boolean
    ativo?: boolean
  }, ExtArgs["result"]["estagiario"]>

  export type EstagiarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nome?: boolean
    cpf?: boolean
    email?: boolean
    telefone?: boolean
    auxilioTransporteValor?: boolean
    auxilioEstagioValor?: boolean
    ativo?: boolean
  }, ExtArgs["result"]["estagiario"]>

  export type EstagiarioSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nome?: boolean
    cpf?: boolean
    email?: boolean
    telefone?: boolean
    auxilioTransporteValor?: boolean
    auxilioEstagioValor?: boolean
    ativo?: boolean
  }


  export type $EstagiarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Estagiario"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      nome: string
      cpf: string | null
      email: string | null
      telefone: string | null
      auxilioTransporteValor: Prisma.Decimal | null
      auxilioEstagioValor: Prisma.Decimal | null
      ativo: boolean
    }, ExtArgs["result"]["estagiario"]>
    composites: {}
  }

  type EstagiarioGetPayload<S extends boolean | null | undefined | EstagiarioDefaultArgs> = $Result.GetResult<Prisma.$EstagiarioPayload, S>

  type EstagiarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EstagiarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EstagiarioCountAggregateInputType | true
    }

  export interface EstagiarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Estagiario'], meta: { name: 'Estagiario' } }
    /**
     * Find zero or one Estagiario that matches the filter.
     * @param {EstagiarioFindUniqueArgs} args - Arguments to find a Estagiario
     * @example
     * // Get one Estagiario
     * const estagiario = await prisma.estagiario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EstagiarioFindUniqueArgs>(args: SelectSubset<T, EstagiarioFindUniqueArgs<ExtArgs>>): Prisma__EstagiarioClient<$Result.GetResult<Prisma.$EstagiarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Estagiario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EstagiarioFindUniqueOrThrowArgs} args - Arguments to find a Estagiario
     * @example
     * // Get one Estagiario
     * const estagiario = await prisma.estagiario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EstagiarioFindUniqueOrThrowArgs>(args: SelectSubset<T, EstagiarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EstagiarioClient<$Result.GetResult<Prisma.$EstagiarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Estagiario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstagiarioFindFirstArgs} args - Arguments to find a Estagiario
     * @example
     * // Get one Estagiario
     * const estagiario = await prisma.estagiario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EstagiarioFindFirstArgs>(args?: SelectSubset<T, EstagiarioFindFirstArgs<ExtArgs>>): Prisma__EstagiarioClient<$Result.GetResult<Prisma.$EstagiarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Estagiario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstagiarioFindFirstOrThrowArgs} args - Arguments to find a Estagiario
     * @example
     * // Get one Estagiario
     * const estagiario = await prisma.estagiario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EstagiarioFindFirstOrThrowArgs>(args?: SelectSubset<T, EstagiarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__EstagiarioClient<$Result.GetResult<Prisma.$EstagiarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Estagiarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstagiarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Estagiarios
     * const estagiarios = await prisma.estagiario.findMany()
     * 
     * // Get first 10 Estagiarios
     * const estagiarios = await prisma.estagiario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const estagiarioWithIdOnly = await prisma.estagiario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EstagiarioFindManyArgs>(args?: SelectSubset<T, EstagiarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstagiarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Estagiario.
     * @param {EstagiarioCreateArgs} args - Arguments to create a Estagiario.
     * @example
     * // Create one Estagiario
     * const Estagiario = await prisma.estagiario.create({
     *   data: {
     *     // ... data to create a Estagiario
     *   }
     * })
     * 
     */
    create<T extends EstagiarioCreateArgs>(args: SelectSubset<T, EstagiarioCreateArgs<ExtArgs>>): Prisma__EstagiarioClient<$Result.GetResult<Prisma.$EstagiarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Estagiarios.
     * @param {EstagiarioCreateManyArgs} args - Arguments to create many Estagiarios.
     * @example
     * // Create many Estagiarios
     * const estagiario = await prisma.estagiario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EstagiarioCreateManyArgs>(args?: SelectSubset<T, EstagiarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Estagiarios and returns the data saved in the database.
     * @param {EstagiarioCreateManyAndReturnArgs} args - Arguments to create many Estagiarios.
     * @example
     * // Create many Estagiarios
     * const estagiario = await prisma.estagiario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Estagiarios and only return the `id`
     * const estagiarioWithIdOnly = await prisma.estagiario.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EstagiarioCreateManyAndReturnArgs>(args?: SelectSubset<T, EstagiarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EstagiarioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Estagiario.
     * @param {EstagiarioDeleteArgs} args - Arguments to delete one Estagiario.
     * @example
     * // Delete one Estagiario
     * const Estagiario = await prisma.estagiario.delete({
     *   where: {
     *     // ... filter to delete one Estagiario
     *   }
     * })
     * 
     */
    delete<T extends EstagiarioDeleteArgs>(args: SelectSubset<T, EstagiarioDeleteArgs<ExtArgs>>): Prisma__EstagiarioClient<$Result.GetResult<Prisma.$EstagiarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Estagiario.
     * @param {EstagiarioUpdateArgs} args - Arguments to update one Estagiario.
     * @example
     * // Update one Estagiario
     * const estagiario = await prisma.estagiario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EstagiarioUpdateArgs>(args: SelectSubset<T, EstagiarioUpdateArgs<ExtArgs>>): Prisma__EstagiarioClient<$Result.GetResult<Prisma.$EstagiarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Estagiarios.
     * @param {EstagiarioDeleteManyArgs} args - Arguments to filter Estagiarios to delete.
     * @example
     * // Delete a few Estagiarios
     * const { count } = await prisma.estagiario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EstagiarioDeleteManyArgs>(args?: SelectSubset<T, EstagiarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estagiarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstagiarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Estagiarios
     * const estagiario = await prisma.estagiario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EstagiarioUpdateManyArgs>(args: SelectSubset<T, EstagiarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Estagiario.
     * @param {EstagiarioUpsertArgs} args - Arguments to update or create a Estagiario.
     * @example
     * // Update or create a Estagiario
     * const estagiario = await prisma.estagiario.upsert({
     *   create: {
     *     // ... data to create a Estagiario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Estagiario we want to update
     *   }
     * })
     */
    upsert<T extends EstagiarioUpsertArgs>(args: SelectSubset<T, EstagiarioUpsertArgs<ExtArgs>>): Prisma__EstagiarioClient<$Result.GetResult<Prisma.$EstagiarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Estagiarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstagiarioCountArgs} args - Arguments to filter Estagiarios to count.
     * @example
     * // Count the number of Estagiarios
     * const count = await prisma.estagiario.count({
     *   where: {
     *     // ... the filter for the Estagiarios we want to count
     *   }
     * })
    **/
    count<T extends EstagiarioCountArgs>(
      args?: Subset<T, EstagiarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EstagiarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Estagiario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstagiarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EstagiarioAggregateArgs>(args: Subset<T, EstagiarioAggregateArgs>): Prisma.PrismaPromise<GetEstagiarioAggregateType<T>>

    /**
     * Group by Estagiario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstagiarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EstagiarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EstagiarioGroupByArgs['orderBy'] }
        : { orderBy?: EstagiarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EstagiarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstagiarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Estagiario model
   */
  readonly fields: EstagiarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Estagiario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EstagiarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Estagiario model
   */ 
  interface EstagiarioFieldRefs {
    readonly id: FieldRef<"Estagiario", 'Int'>
    readonly createdAt: FieldRef<"Estagiario", 'DateTime'>
    readonly updatedAt: FieldRef<"Estagiario", 'DateTime'>
    readonly nome: FieldRef<"Estagiario", 'String'>
    readonly cpf: FieldRef<"Estagiario", 'String'>
    readonly email: FieldRef<"Estagiario", 'String'>
    readonly telefone: FieldRef<"Estagiario", 'String'>
    readonly auxilioTransporteValor: FieldRef<"Estagiario", 'Decimal'>
    readonly auxilioEstagioValor: FieldRef<"Estagiario", 'Decimal'>
    readonly ativo: FieldRef<"Estagiario", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Estagiario findUnique
   */
  export type EstagiarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estagiario
     */
    select?: EstagiarioSelect<ExtArgs> | null
    /**
     * Filter, which Estagiario to fetch.
     */
    where: EstagiarioWhereUniqueInput
  }

  /**
   * Estagiario findUniqueOrThrow
   */
  export type EstagiarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estagiario
     */
    select?: EstagiarioSelect<ExtArgs> | null
    /**
     * Filter, which Estagiario to fetch.
     */
    where: EstagiarioWhereUniqueInput
  }

  /**
   * Estagiario findFirst
   */
  export type EstagiarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estagiario
     */
    select?: EstagiarioSelect<ExtArgs> | null
    /**
     * Filter, which Estagiario to fetch.
     */
    where?: EstagiarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estagiarios to fetch.
     */
    orderBy?: EstagiarioOrderByWithRelationInput | EstagiarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Estagiarios.
     */
    cursor?: EstagiarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estagiarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estagiarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Estagiarios.
     */
    distinct?: EstagiarioScalarFieldEnum | EstagiarioScalarFieldEnum[]
  }

  /**
   * Estagiario findFirstOrThrow
   */
  export type EstagiarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estagiario
     */
    select?: EstagiarioSelect<ExtArgs> | null
    /**
     * Filter, which Estagiario to fetch.
     */
    where?: EstagiarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estagiarios to fetch.
     */
    orderBy?: EstagiarioOrderByWithRelationInput | EstagiarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Estagiarios.
     */
    cursor?: EstagiarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estagiarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estagiarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Estagiarios.
     */
    distinct?: EstagiarioScalarFieldEnum | EstagiarioScalarFieldEnum[]
  }

  /**
   * Estagiario findMany
   */
  export type EstagiarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estagiario
     */
    select?: EstagiarioSelect<ExtArgs> | null
    /**
     * Filter, which Estagiarios to fetch.
     */
    where?: EstagiarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Estagiarios to fetch.
     */
    orderBy?: EstagiarioOrderByWithRelationInput | EstagiarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Estagiarios.
     */
    cursor?: EstagiarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estagiarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estagiarios.
     */
    skip?: number
    distinct?: EstagiarioScalarFieldEnum | EstagiarioScalarFieldEnum[]
  }

  /**
   * Estagiario create
   */
  export type EstagiarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estagiario
     */
    select?: EstagiarioSelect<ExtArgs> | null
    /**
     * The data needed to create a Estagiario.
     */
    data: XOR<EstagiarioCreateInput, EstagiarioUncheckedCreateInput>
  }

  /**
   * Estagiario createMany
   */
  export type EstagiarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Estagiarios.
     */
    data: EstagiarioCreateManyInput | EstagiarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Estagiario createManyAndReturn
   */
  export type EstagiarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estagiario
     */
    select?: EstagiarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Estagiarios.
     */
    data: EstagiarioCreateManyInput | EstagiarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Estagiario update
   */
  export type EstagiarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estagiario
     */
    select?: EstagiarioSelect<ExtArgs> | null
    /**
     * The data needed to update a Estagiario.
     */
    data: XOR<EstagiarioUpdateInput, EstagiarioUncheckedUpdateInput>
    /**
     * Choose, which Estagiario to update.
     */
    where: EstagiarioWhereUniqueInput
  }

  /**
   * Estagiario updateMany
   */
  export type EstagiarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Estagiarios.
     */
    data: XOR<EstagiarioUpdateManyMutationInput, EstagiarioUncheckedUpdateManyInput>
    /**
     * Filter which Estagiarios to update
     */
    where?: EstagiarioWhereInput
  }

  /**
   * Estagiario upsert
   */
  export type EstagiarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estagiario
     */
    select?: EstagiarioSelect<ExtArgs> | null
    /**
     * The filter to search for the Estagiario to update in case it exists.
     */
    where: EstagiarioWhereUniqueInput
    /**
     * In case the Estagiario found by the `where` argument doesn't exist, create a new Estagiario with this data.
     */
    create: XOR<EstagiarioCreateInput, EstagiarioUncheckedCreateInput>
    /**
     * In case the Estagiario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EstagiarioUpdateInput, EstagiarioUncheckedUpdateInput>
  }

  /**
   * Estagiario delete
   */
  export type EstagiarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estagiario
     */
    select?: EstagiarioSelect<ExtArgs> | null
    /**
     * Filter which Estagiario to delete.
     */
    where: EstagiarioWhereUniqueInput
  }

  /**
   * Estagiario deleteMany
   */
  export type EstagiarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Estagiarios to delete
     */
    where?: EstagiarioWhereInput
  }

  /**
   * Estagiario without action
   */
  export type EstagiarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Estagiario
     */
    select?: EstagiarioSelect<ExtArgs> | null
  }


  /**
   * Model PrestadorServico
   */

  export type AggregatePrestadorServico = {
    _count: PrestadorServicoCountAggregateOutputType | null
    _avg: PrestadorServicoAvgAggregateOutputType | null
    _sum: PrestadorServicoSumAggregateOutputType | null
    _min: PrestadorServicoMinAggregateOutputType | null
    _max: PrestadorServicoMaxAggregateOutputType | null
  }

  export type PrestadorServicoAvgAggregateOutputType = {
    id: number | null
    valorRecorrente: Decimal | null
  }

  export type PrestadorServicoSumAggregateOutputType = {
    id: number | null
    valorRecorrente: Decimal | null
  }

  export type PrestadorServicoMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nomeRazaoSocial: string | null
    cpfCnpj: string | null
    tipo: string | null
    valorRecorrente: Decimal | null
    observacoes: string | null
    ativo: boolean | null
  }

  export type PrestadorServicoMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nomeRazaoSocial: string | null
    cpfCnpj: string | null
    tipo: string | null
    valorRecorrente: Decimal | null
    observacoes: string | null
    ativo: boolean | null
  }

  export type PrestadorServicoCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    nomeRazaoSocial: number
    cpfCnpj: number
    tipo: number
    valorRecorrente: number
    observacoes: number
    ativo: number
    _all: number
  }


  export type PrestadorServicoAvgAggregateInputType = {
    id?: true
    valorRecorrente?: true
  }

  export type PrestadorServicoSumAggregateInputType = {
    id?: true
    valorRecorrente?: true
  }

  export type PrestadorServicoMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nomeRazaoSocial?: true
    cpfCnpj?: true
    tipo?: true
    valorRecorrente?: true
    observacoes?: true
    ativo?: true
  }

  export type PrestadorServicoMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nomeRazaoSocial?: true
    cpfCnpj?: true
    tipo?: true
    valorRecorrente?: true
    observacoes?: true
    ativo?: true
  }

  export type PrestadorServicoCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nomeRazaoSocial?: true
    cpfCnpj?: true
    tipo?: true
    valorRecorrente?: true
    observacoes?: true
    ativo?: true
    _all?: true
  }

  export type PrestadorServicoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrestadorServico to aggregate.
     */
    where?: PrestadorServicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrestadorServicos to fetch.
     */
    orderBy?: PrestadorServicoOrderByWithRelationInput | PrestadorServicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrestadorServicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrestadorServicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrestadorServicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrestadorServicos
    **/
    _count?: true | PrestadorServicoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrestadorServicoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrestadorServicoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrestadorServicoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrestadorServicoMaxAggregateInputType
  }

  export type GetPrestadorServicoAggregateType<T extends PrestadorServicoAggregateArgs> = {
        [P in keyof T & keyof AggregatePrestadorServico]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrestadorServico[P]>
      : GetScalarType<T[P], AggregatePrestadorServico[P]>
  }




  export type PrestadorServicoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrestadorServicoWhereInput
    orderBy?: PrestadorServicoOrderByWithAggregationInput | PrestadorServicoOrderByWithAggregationInput[]
    by: PrestadorServicoScalarFieldEnum[] | PrestadorServicoScalarFieldEnum
    having?: PrestadorServicoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrestadorServicoCountAggregateInputType | true
    _avg?: PrestadorServicoAvgAggregateInputType
    _sum?: PrestadorServicoSumAggregateInputType
    _min?: PrestadorServicoMinAggregateInputType
    _max?: PrestadorServicoMaxAggregateInputType
  }

  export type PrestadorServicoGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    nomeRazaoSocial: string
    cpfCnpj: string | null
    tipo: string
    valorRecorrente: Decimal | null
    observacoes: string | null
    ativo: boolean
    _count: PrestadorServicoCountAggregateOutputType | null
    _avg: PrestadorServicoAvgAggregateOutputType | null
    _sum: PrestadorServicoSumAggregateOutputType | null
    _min: PrestadorServicoMinAggregateOutputType | null
    _max: PrestadorServicoMaxAggregateOutputType | null
  }

  type GetPrestadorServicoGroupByPayload<T extends PrestadorServicoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrestadorServicoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrestadorServicoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrestadorServicoGroupByOutputType[P]>
            : GetScalarType<T[P], PrestadorServicoGroupByOutputType[P]>
        }
      >
    >


  export type PrestadorServicoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nomeRazaoSocial?: boolean
    cpfCnpj?: boolean
    tipo?: boolean
    valorRecorrente?: boolean
    observacoes?: boolean
    ativo?: boolean
  }, ExtArgs["result"]["prestadorServico"]>

  export type PrestadorServicoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nomeRazaoSocial?: boolean
    cpfCnpj?: boolean
    tipo?: boolean
    valorRecorrente?: boolean
    observacoes?: boolean
    ativo?: boolean
  }, ExtArgs["result"]["prestadorServico"]>

  export type PrestadorServicoSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nomeRazaoSocial?: boolean
    cpfCnpj?: boolean
    tipo?: boolean
    valorRecorrente?: boolean
    observacoes?: boolean
    ativo?: boolean
  }


  export type $PrestadorServicoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrestadorServico"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      nomeRazaoSocial: string
      cpfCnpj: string | null
      tipo: string
      valorRecorrente: Prisma.Decimal | null
      observacoes: string | null
      ativo: boolean
    }, ExtArgs["result"]["prestadorServico"]>
    composites: {}
  }

  type PrestadorServicoGetPayload<S extends boolean | null | undefined | PrestadorServicoDefaultArgs> = $Result.GetResult<Prisma.$PrestadorServicoPayload, S>

  type PrestadorServicoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PrestadorServicoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PrestadorServicoCountAggregateInputType | true
    }

  export interface PrestadorServicoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrestadorServico'], meta: { name: 'PrestadorServico' } }
    /**
     * Find zero or one PrestadorServico that matches the filter.
     * @param {PrestadorServicoFindUniqueArgs} args - Arguments to find a PrestadorServico
     * @example
     * // Get one PrestadorServico
     * const prestadorServico = await prisma.prestadorServico.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrestadorServicoFindUniqueArgs>(args: SelectSubset<T, PrestadorServicoFindUniqueArgs<ExtArgs>>): Prisma__PrestadorServicoClient<$Result.GetResult<Prisma.$PrestadorServicoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PrestadorServico that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PrestadorServicoFindUniqueOrThrowArgs} args - Arguments to find a PrestadorServico
     * @example
     * // Get one PrestadorServico
     * const prestadorServico = await prisma.prestadorServico.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrestadorServicoFindUniqueOrThrowArgs>(args: SelectSubset<T, PrestadorServicoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrestadorServicoClient<$Result.GetResult<Prisma.$PrestadorServicoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PrestadorServico that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorServicoFindFirstArgs} args - Arguments to find a PrestadorServico
     * @example
     * // Get one PrestadorServico
     * const prestadorServico = await prisma.prestadorServico.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrestadorServicoFindFirstArgs>(args?: SelectSubset<T, PrestadorServicoFindFirstArgs<ExtArgs>>): Prisma__PrestadorServicoClient<$Result.GetResult<Prisma.$PrestadorServicoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PrestadorServico that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorServicoFindFirstOrThrowArgs} args - Arguments to find a PrestadorServico
     * @example
     * // Get one PrestadorServico
     * const prestadorServico = await prisma.prestadorServico.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrestadorServicoFindFirstOrThrowArgs>(args?: SelectSubset<T, PrestadorServicoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrestadorServicoClient<$Result.GetResult<Prisma.$PrestadorServicoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PrestadorServicos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorServicoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrestadorServicos
     * const prestadorServicos = await prisma.prestadorServico.findMany()
     * 
     * // Get first 10 PrestadorServicos
     * const prestadorServicos = await prisma.prestadorServico.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prestadorServicoWithIdOnly = await prisma.prestadorServico.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrestadorServicoFindManyArgs>(args?: SelectSubset<T, PrestadorServicoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrestadorServicoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PrestadorServico.
     * @param {PrestadorServicoCreateArgs} args - Arguments to create a PrestadorServico.
     * @example
     * // Create one PrestadorServico
     * const PrestadorServico = await prisma.prestadorServico.create({
     *   data: {
     *     // ... data to create a PrestadorServico
     *   }
     * })
     * 
     */
    create<T extends PrestadorServicoCreateArgs>(args: SelectSubset<T, PrestadorServicoCreateArgs<ExtArgs>>): Prisma__PrestadorServicoClient<$Result.GetResult<Prisma.$PrestadorServicoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PrestadorServicos.
     * @param {PrestadorServicoCreateManyArgs} args - Arguments to create many PrestadorServicos.
     * @example
     * // Create many PrestadorServicos
     * const prestadorServico = await prisma.prestadorServico.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrestadorServicoCreateManyArgs>(args?: SelectSubset<T, PrestadorServicoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PrestadorServicos and returns the data saved in the database.
     * @param {PrestadorServicoCreateManyAndReturnArgs} args - Arguments to create many PrestadorServicos.
     * @example
     * // Create many PrestadorServicos
     * const prestadorServico = await prisma.prestadorServico.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PrestadorServicos and only return the `id`
     * const prestadorServicoWithIdOnly = await prisma.prestadorServico.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrestadorServicoCreateManyAndReturnArgs>(args?: SelectSubset<T, PrestadorServicoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrestadorServicoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PrestadorServico.
     * @param {PrestadorServicoDeleteArgs} args - Arguments to delete one PrestadorServico.
     * @example
     * // Delete one PrestadorServico
     * const PrestadorServico = await prisma.prestadorServico.delete({
     *   where: {
     *     // ... filter to delete one PrestadorServico
     *   }
     * })
     * 
     */
    delete<T extends PrestadorServicoDeleteArgs>(args: SelectSubset<T, PrestadorServicoDeleteArgs<ExtArgs>>): Prisma__PrestadorServicoClient<$Result.GetResult<Prisma.$PrestadorServicoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PrestadorServico.
     * @param {PrestadorServicoUpdateArgs} args - Arguments to update one PrestadorServico.
     * @example
     * // Update one PrestadorServico
     * const prestadorServico = await prisma.prestadorServico.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrestadorServicoUpdateArgs>(args: SelectSubset<T, PrestadorServicoUpdateArgs<ExtArgs>>): Prisma__PrestadorServicoClient<$Result.GetResult<Prisma.$PrestadorServicoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PrestadorServicos.
     * @param {PrestadorServicoDeleteManyArgs} args - Arguments to filter PrestadorServicos to delete.
     * @example
     * // Delete a few PrestadorServicos
     * const { count } = await prisma.prestadorServico.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrestadorServicoDeleteManyArgs>(args?: SelectSubset<T, PrestadorServicoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrestadorServicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorServicoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrestadorServicos
     * const prestadorServico = await prisma.prestadorServico.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrestadorServicoUpdateManyArgs>(args: SelectSubset<T, PrestadorServicoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PrestadorServico.
     * @param {PrestadorServicoUpsertArgs} args - Arguments to update or create a PrestadorServico.
     * @example
     * // Update or create a PrestadorServico
     * const prestadorServico = await prisma.prestadorServico.upsert({
     *   create: {
     *     // ... data to create a PrestadorServico
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrestadorServico we want to update
     *   }
     * })
     */
    upsert<T extends PrestadorServicoUpsertArgs>(args: SelectSubset<T, PrestadorServicoUpsertArgs<ExtArgs>>): Prisma__PrestadorServicoClient<$Result.GetResult<Prisma.$PrestadorServicoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PrestadorServicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorServicoCountArgs} args - Arguments to filter PrestadorServicos to count.
     * @example
     * // Count the number of PrestadorServicos
     * const count = await prisma.prestadorServico.count({
     *   where: {
     *     // ... the filter for the PrestadorServicos we want to count
     *   }
     * })
    **/
    count<T extends PrestadorServicoCountArgs>(
      args?: Subset<T, PrestadorServicoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrestadorServicoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrestadorServico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorServicoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrestadorServicoAggregateArgs>(args: Subset<T, PrestadorServicoAggregateArgs>): Prisma.PrismaPromise<GetPrestadorServicoAggregateType<T>>

    /**
     * Group by PrestadorServico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorServicoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrestadorServicoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrestadorServicoGroupByArgs['orderBy'] }
        : { orderBy?: PrestadorServicoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrestadorServicoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrestadorServicoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrestadorServico model
   */
  readonly fields: PrestadorServicoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrestadorServico.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrestadorServicoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrestadorServico model
   */ 
  interface PrestadorServicoFieldRefs {
    readonly id: FieldRef<"PrestadorServico", 'Int'>
    readonly createdAt: FieldRef<"PrestadorServico", 'DateTime'>
    readonly updatedAt: FieldRef<"PrestadorServico", 'DateTime'>
    readonly nomeRazaoSocial: FieldRef<"PrestadorServico", 'String'>
    readonly cpfCnpj: FieldRef<"PrestadorServico", 'String'>
    readonly tipo: FieldRef<"PrestadorServico", 'String'>
    readonly valorRecorrente: FieldRef<"PrestadorServico", 'Decimal'>
    readonly observacoes: FieldRef<"PrestadorServico", 'String'>
    readonly ativo: FieldRef<"PrestadorServico", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * PrestadorServico findUnique
   */
  export type PrestadorServicoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrestadorServico
     */
    select?: PrestadorServicoSelect<ExtArgs> | null
    /**
     * Filter, which PrestadorServico to fetch.
     */
    where: PrestadorServicoWhereUniqueInput
  }

  /**
   * PrestadorServico findUniqueOrThrow
   */
  export type PrestadorServicoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrestadorServico
     */
    select?: PrestadorServicoSelect<ExtArgs> | null
    /**
     * Filter, which PrestadorServico to fetch.
     */
    where: PrestadorServicoWhereUniqueInput
  }

  /**
   * PrestadorServico findFirst
   */
  export type PrestadorServicoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrestadorServico
     */
    select?: PrestadorServicoSelect<ExtArgs> | null
    /**
     * Filter, which PrestadorServico to fetch.
     */
    where?: PrestadorServicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrestadorServicos to fetch.
     */
    orderBy?: PrestadorServicoOrderByWithRelationInput | PrestadorServicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrestadorServicos.
     */
    cursor?: PrestadorServicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrestadorServicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrestadorServicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrestadorServicos.
     */
    distinct?: PrestadorServicoScalarFieldEnum | PrestadorServicoScalarFieldEnum[]
  }

  /**
   * PrestadorServico findFirstOrThrow
   */
  export type PrestadorServicoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrestadorServico
     */
    select?: PrestadorServicoSelect<ExtArgs> | null
    /**
     * Filter, which PrestadorServico to fetch.
     */
    where?: PrestadorServicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrestadorServicos to fetch.
     */
    orderBy?: PrestadorServicoOrderByWithRelationInput | PrestadorServicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrestadorServicos.
     */
    cursor?: PrestadorServicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrestadorServicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrestadorServicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrestadorServicos.
     */
    distinct?: PrestadorServicoScalarFieldEnum | PrestadorServicoScalarFieldEnum[]
  }

  /**
   * PrestadorServico findMany
   */
  export type PrestadorServicoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrestadorServico
     */
    select?: PrestadorServicoSelect<ExtArgs> | null
    /**
     * Filter, which PrestadorServicos to fetch.
     */
    where?: PrestadorServicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrestadorServicos to fetch.
     */
    orderBy?: PrestadorServicoOrderByWithRelationInput | PrestadorServicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrestadorServicos.
     */
    cursor?: PrestadorServicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrestadorServicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrestadorServicos.
     */
    skip?: number
    distinct?: PrestadorServicoScalarFieldEnum | PrestadorServicoScalarFieldEnum[]
  }

  /**
   * PrestadorServico create
   */
  export type PrestadorServicoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrestadorServico
     */
    select?: PrestadorServicoSelect<ExtArgs> | null
    /**
     * The data needed to create a PrestadorServico.
     */
    data: XOR<PrestadorServicoCreateInput, PrestadorServicoUncheckedCreateInput>
  }

  /**
   * PrestadorServico createMany
   */
  export type PrestadorServicoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrestadorServicos.
     */
    data: PrestadorServicoCreateManyInput | PrestadorServicoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrestadorServico createManyAndReturn
   */
  export type PrestadorServicoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrestadorServico
     */
    select?: PrestadorServicoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PrestadorServicos.
     */
    data: PrestadorServicoCreateManyInput | PrestadorServicoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrestadorServico update
   */
  export type PrestadorServicoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrestadorServico
     */
    select?: PrestadorServicoSelect<ExtArgs> | null
    /**
     * The data needed to update a PrestadorServico.
     */
    data: XOR<PrestadorServicoUpdateInput, PrestadorServicoUncheckedUpdateInput>
    /**
     * Choose, which PrestadorServico to update.
     */
    where: PrestadorServicoWhereUniqueInput
  }

  /**
   * PrestadorServico updateMany
   */
  export type PrestadorServicoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrestadorServicos.
     */
    data: XOR<PrestadorServicoUpdateManyMutationInput, PrestadorServicoUncheckedUpdateManyInput>
    /**
     * Filter which PrestadorServicos to update
     */
    where?: PrestadorServicoWhereInput
  }

  /**
   * PrestadorServico upsert
   */
  export type PrestadorServicoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrestadorServico
     */
    select?: PrestadorServicoSelect<ExtArgs> | null
    /**
     * The filter to search for the PrestadorServico to update in case it exists.
     */
    where: PrestadorServicoWhereUniqueInput
    /**
     * In case the PrestadorServico found by the `where` argument doesn't exist, create a new PrestadorServico with this data.
     */
    create: XOR<PrestadorServicoCreateInput, PrestadorServicoUncheckedCreateInput>
    /**
     * In case the PrestadorServico was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrestadorServicoUpdateInput, PrestadorServicoUncheckedUpdateInput>
  }

  /**
   * PrestadorServico delete
   */
  export type PrestadorServicoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrestadorServico
     */
    select?: PrestadorServicoSelect<ExtArgs> | null
    /**
     * Filter which PrestadorServico to delete.
     */
    where: PrestadorServicoWhereUniqueInput
  }

  /**
   * PrestadorServico deleteMany
   */
  export type PrestadorServicoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrestadorServicos to delete
     */
    where?: PrestadorServicoWhereInput
  }

  /**
   * PrestadorServico without action
   */
  export type PrestadorServicoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrestadorServico
     */
    select?: PrestadorServicoSelect<ExtArgs> | null
  }


  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nome: string | null
    email: string | null
    senhaHash: string | null
    perfil: $Enums.PerfilUsuario | null
    ativo: boolean | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    nome: string | null
    email: string | null
    senhaHash: string | null
    perfil: $Enums.PerfilUsuario | null
    ativo: boolean | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    nome: number
    email: number
    senhaHash: number
    perfil: number
    ativo: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id?: true
  }

  export type UsuarioSumAggregateInputType = {
    id?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nome?: true
    email?: true
    senhaHash?: true
    perfil?: true
    ativo?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nome?: true
    email?: true
    senhaHash?: true
    perfil?: true
    ativo?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    nome?: true
    email?: true
    senhaHash?: true
    perfil?: true
    ativo?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    nome: string
    email: string
    senhaHash: string
    perfil: $Enums.PerfilUsuario
    ativo: boolean
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nome?: boolean
    email?: boolean
    senhaHash?: boolean
    perfil?: boolean
    ativo?: boolean
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nome?: boolean
    email?: boolean
    senhaHash?: boolean
    perfil?: boolean
    ativo?: boolean
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nome?: boolean
    email?: boolean
    senhaHash?: boolean
    perfil?: boolean
    ativo?: boolean
  }


  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      nome: string
      email: string
      senhaHash: string
      perfil: $Enums.PerfilUsuario
      ativo: boolean
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioFindUniqueArgs>(args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioFindFirstArgs>(args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsuarioFindManyArgs>(args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends UsuarioCreateArgs>(args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Usuarios.
     * @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioCreateManyArgs>(args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usuarios and returns the data saved in the database.
     * @param {UsuarioCreateManyAndReturnArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usuarios and only return the `id`
     * const usuarioWithIdOnly = await prisma.usuario.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, UsuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends UsuarioDeleteArgs>(args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioUpdateArgs>(args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioDeleteManyArgs>(args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioUpdateManyArgs>(args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioUpsertArgs>(args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuario model
   */ 
  interface UsuarioFieldRefs {
    readonly id: FieldRef<"Usuario", 'Int'>
    readonly createdAt: FieldRef<"Usuario", 'DateTime'>
    readonly updatedAt: FieldRef<"Usuario", 'DateTime'>
    readonly nome: FieldRef<"Usuario", 'String'>
    readonly email: FieldRef<"Usuario", 'String'>
    readonly senhaHash: FieldRef<"Usuario", 'String'>
    readonly perfil: FieldRef<"Usuario", 'PerfilUsuario'>
    readonly ativo: FieldRef<"Usuario", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }

  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario createManyAndReturn
   */
  export type UsuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }

  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
  }


  /**
   * Model ConfiguracaoCalculo
   */

  export type AggregateConfiguracaoCalculo = {
    _count: ConfiguracaoCalculoCountAggregateOutputType | null
    _avg: ConfiguracaoCalculoAvgAggregateOutputType | null
    _sum: ConfiguracaoCalculoSumAggregateOutputType | null
    _min: ConfiguracaoCalculoMinAggregateOutputType | null
    _max: ConfiguracaoCalculoMaxAggregateOutputType | null
  }

  export type ConfiguracaoCalculoAvgAggregateOutputType = {
    id: number | null
    percentualAdvogado: Decimal | null
    percentualSocio: Decimal | null
    percentualFundoReserva: Decimal | null
    percentualEscritorio: Decimal | null
  }

  export type ConfiguracaoCalculoSumAggregateOutputType = {
    id: number | null
    percentualAdvogado: Decimal | null
    percentualSocio: Decimal | null
    percentualFundoReserva: Decimal | null
    percentualEscritorio: Decimal | null
  }

  export type ConfiguracaoCalculoMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    codigoModelo: string | null
    descricao: string | null
    percentualAdvogado: Decimal | null
    percentualSocio: Decimal | null
    percentualFundoReserva: Decimal | null
    percentualEscritorio: Decimal | null
    vigenciaInicio: Date | null
    vigenciaFim: Date | null
    ativo: boolean | null
  }

  export type ConfiguracaoCalculoMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    codigoModelo: string | null
    descricao: string | null
    percentualAdvogado: Decimal | null
    percentualSocio: Decimal | null
    percentualFundoReserva: Decimal | null
    percentualEscritorio: Decimal | null
    vigenciaInicio: Date | null
    vigenciaFim: Date | null
    ativo: boolean | null
  }

  export type ConfiguracaoCalculoCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    codigoModelo: number
    descricao: number
    percentualAdvogado: number
    percentualSocio: number
    percentualFundoReserva: number
    percentualEscritorio: number
    vigenciaInicio: number
    vigenciaFim: number
    ativo: number
    _all: number
  }


  export type ConfiguracaoCalculoAvgAggregateInputType = {
    id?: true
    percentualAdvogado?: true
    percentualSocio?: true
    percentualFundoReserva?: true
    percentualEscritorio?: true
  }

  export type ConfiguracaoCalculoSumAggregateInputType = {
    id?: true
    percentualAdvogado?: true
    percentualSocio?: true
    percentualFundoReserva?: true
    percentualEscritorio?: true
  }

  export type ConfiguracaoCalculoMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    codigoModelo?: true
    descricao?: true
    percentualAdvogado?: true
    percentualSocio?: true
    percentualFundoReserva?: true
    percentualEscritorio?: true
    vigenciaInicio?: true
    vigenciaFim?: true
    ativo?: true
  }

  export type ConfiguracaoCalculoMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    codigoModelo?: true
    descricao?: true
    percentualAdvogado?: true
    percentualSocio?: true
    percentualFundoReserva?: true
    percentualEscritorio?: true
    vigenciaInicio?: true
    vigenciaFim?: true
    ativo?: true
  }

  export type ConfiguracaoCalculoCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    codigoModelo?: true
    descricao?: true
    percentualAdvogado?: true
    percentualSocio?: true
    percentualFundoReserva?: true
    percentualEscritorio?: true
    vigenciaInicio?: true
    vigenciaFim?: true
    ativo?: true
    _all?: true
  }

  export type ConfiguracaoCalculoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfiguracaoCalculo to aggregate.
     */
    where?: ConfiguracaoCalculoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfiguracaoCalculos to fetch.
     */
    orderBy?: ConfiguracaoCalculoOrderByWithRelationInput | ConfiguracaoCalculoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConfiguracaoCalculoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfiguracaoCalculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfiguracaoCalculos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConfiguracaoCalculos
    **/
    _count?: true | ConfiguracaoCalculoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConfiguracaoCalculoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConfiguracaoCalculoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfiguracaoCalculoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfiguracaoCalculoMaxAggregateInputType
  }

  export type GetConfiguracaoCalculoAggregateType<T extends ConfiguracaoCalculoAggregateArgs> = {
        [P in keyof T & keyof AggregateConfiguracaoCalculo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfiguracaoCalculo[P]>
      : GetScalarType<T[P], AggregateConfiguracaoCalculo[P]>
  }




  export type ConfiguracaoCalculoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfiguracaoCalculoWhereInput
    orderBy?: ConfiguracaoCalculoOrderByWithAggregationInput | ConfiguracaoCalculoOrderByWithAggregationInput[]
    by: ConfiguracaoCalculoScalarFieldEnum[] | ConfiguracaoCalculoScalarFieldEnum
    having?: ConfiguracaoCalculoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfiguracaoCalculoCountAggregateInputType | true
    _avg?: ConfiguracaoCalculoAvgAggregateInputType
    _sum?: ConfiguracaoCalculoSumAggregateInputType
    _min?: ConfiguracaoCalculoMinAggregateInputType
    _max?: ConfiguracaoCalculoMaxAggregateInputType
  }

  export type ConfiguracaoCalculoGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    codigoModelo: string
    descricao: string | null
    percentualAdvogado: Decimal
    percentualSocio: Decimal
    percentualFundoReserva: Decimal
    percentualEscritorio: Decimal
    vigenciaInicio: Date
    vigenciaFim: Date | null
    ativo: boolean
    _count: ConfiguracaoCalculoCountAggregateOutputType | null
    _avg: ConfiguracaoCalculoAvgAggregateOutputType | null
    _sum: ConfiguracaoCalculoSumAggregateOutputType | null
    _min: ConfiguracaoCalculoMinAggregateOutputType | null
    _max: ConfiguracaoCalculoMaxAggregateOutputType | null
  }

  type GetConfiguracaoCalculoGroupByPayload<T extends ConfiguracaoCalculoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfiguracaoCalculoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfiguracaoCalculoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfiguracaoCalculoGroupByOutputType[P]>
            : GetScalarType<T[P], ConfiguracaoCalculoGroupByOutputType[P]>
        }
      >
    >


  export type ConfiguracaoCalculoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    codigoModelo?: boolean
    descricao?: boolean
    percentualAdvogado?: boolean
    percentualSocio?: boolean
    percentualFundoReserva?: boolean
    percentualEscritorio?: boolean
    vigenciaInicio?: boolean
    vigenciaFim?: boolean
    ativo?: boolean
  }, ExtArgs["result"]["configuracaoCalculo"]>

  export type ConfiguracaoCalculoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    codigoModelo?: boolean
    descricao?: boolean
    percentualAdvogado?: boolean
    percentualSocio?: boolean
    percentualFundoReserva?: boolean
    percentualEscritorio?: boolean
    vigenciaInicio?: boolean
    vigenciaFim?: boolean
    ativo?: boolean
  }, ExtArgs["result"]["configuracaoCalculo"]>

  export type ConfiguracaoCalculoSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    codigoModelo?: boolean
    descricao?: boolean
    percentualAdvogado?: boolean
    percentualSocio?: boolean
    percentualFundoReserva?: boolean
    percentualEscritorio?: boolean
    vigenciaInicio?: boolean
    vigenciaFim?: boolean
    ativo?: boolean
  }


  export type $ConfiguracaoCalculoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConfiguracaoCalculo"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      codigoModelo: string
      descricao: string | null
      percentualAdvogado: Prisma.Decimal
      percentualSocio: Prisma.Decimal
      percentualFundoReserva: Prisma.Decimal
      percentualEscritorio: Prisma.Decimal
      vigenciaInicio: Date
      vigenciaFim: Date | null
      ativo: boolean
    }, ExtArgs["result"]["configuracaoCalculo"]>
    composites: {}
  }

  type ConfiguracaoCalculoGetPayload<S extends boolean | null | undefined | ConfiguracaoCalculoDefaultArgs> = $Result.GetResult<Prisma.$ConfiguracaoCalculoPayload, S>

  type ConfiguracaoCalculoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConfiguracaoCalculoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConfiguracaoCalculoCountAggregateInputType | true
    }

  export interface ConfiguracaoCalculoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConfiguracaoCalculo'], meta: { name: 'ConfiguracaoCalculo' } }
    /**
     * Find zero or one ConfiguracaoCalculo that matches the filter.
     * @param {ConfiguracaoCalculoFindUniqueArgs} args - Arguments to find a ConfiguracaoCalculo
     * @example
     * // Get one ConfiguracaoCalculo
     * const configuracaoCalculo = await prisma.configuracaoCalculo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConfiguracaoCalculoFindUniqueArgs>(args: SelectSubset<T, ConfiguracaoCalculoFindUniqueArgs<ExtArgs>>): Prisma__ConfiguracaoCalculoClient<$Result.GetResult<Prisma.$ConfiguracaoCalculoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ConfiguracaoCalculo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConfiguracaoCalculoFindUniqueOrThrowArgs} args - Arguments to find a ConfiguracaoCalculo
     * @example
     * // Get one ConfiguracaoCalculo
     * const configuracaoCalculo = await prisma.configuracaoCalculo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConfiguracaoCalculoFindUniqueOrThrowArgs>(args: SelectSubset<T, ConfiguracaoCalculoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConfiguracaoCalculoClient<$Result.GetResult<Prisma.$ConfiguracaoCalculoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ConfiguracaoCalculo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracaoCalculoFindFirstArgs} args - Arguments to find a ConfiguracaoCalculo
     * @example
     * // Get one ConfiguracaoCalculo
     * const configuracaoCalculo = await prisma.configuracaoCalculo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConfiguracaoCalculoFindFirstArgs>(args?: SelectSubset<T, ConfiguracaoCalculoFindFirstArgs<ExtArgs>>): Prisma__ConfiguracaoCalculoClient<$Result.GetResult<Prisma.$ConfiguracaoCalculoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ConfiguracaoCalculo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracaoCalculoFindFirstOrThrowArgs} args - Arguments to find a ConfiguracaoCalculo
     * @example
     * // Get one ConfiguracaoCalculo
     * const configuracaoCalculo = await prisma.configuracaoCalculo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConfiguracaoCalculoFindFirstOrThrowArgs>(args?: SelectSubset<T, ConfiguracaoCalculoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConfiguracaoCalculoClient<$Result.GetResult<Prisma.$ConfiguracaoCalculoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ConfiguracaoCalculos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracaoCalculoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConfiguracaoCalculos
     * const configuracaoCalculos = await prisma.configuracaoCalculo.findMany()
     * 
     * // Get first 10 ConfiguracaoCalculos
     * const configuracaoCalculos = await prisma.configuracaoCalculo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const configuracaoCalculoWithIdOnly = await prisma.configuracaoCalculo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConfiguracaoCalculoFindManyArgs>(args?: SelectSubset<T, ConfiguracaoCalculoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfiguracaoCalculoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ConfiguracaoCalculo.
     * @param {ConfiguracaoCalculoCreateArgs} args - Arguments to create a ConfiguracaoCalculo.
     * @example
     * // Create one ConfiguracaoCalculo
     * const ConfiguracaoCalculo = await prisma.configuracaoCalculo.create({
     *   data: {
     *     // ... data to create a ConfiguracaoCalculo
     *   }
     * })
     * 
     */
    create<T extends ConfiguracaoCalculoCreateArgs>(args: SelectSubset<T, ConfiguracaoCalculoCreateArgs<ExtArgs>>): Prisma__ConfiguracaoCalculoClient<$Result.GetResult<Prisma.$ConfiguracaoCalculoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ConfiguracaoCalculos.
     * @param {ConfiguracaoCalculoCreateManyArgs} args - Arguments to create many ConfiguracaoCalculos.
     * @example
     * // Create many ConfiguracaoCalculos
     * const configuracaoCalculo = await prisma.configuracaoCalculo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConfiguracaoCalculoCreateManyArgs>(args?: SelectSubset<T, ConfiguracaoCalculoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConfiguracaoCalculos and returns the data saved in the database.
     * @param {ConfiguracaoCalculoCreateManyAndReturnArgs} args - Arguments to create many ConfiguracaoCalculos.
     * @example
     * // Create many ConfiguracaoCalculos
     * const configuracaoCalculo = await prisma.configuracaoCalculo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConfiguracaoCalculos and only return the `id`
     * const configuracaoCalculoWithIdOnly = await prisma.configuracaoCalculo.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConfiguracaoCalculoCreateManyAndReturnArgs>(args?: SelectSubset<T, ConfiguracaoCalculoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfiguracaoCalculoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ConfiguracaoCalculo.
     * @param {ConfiguracaoCalculoDeleteArgs} args - Arguments to delete one ConfiguracaoCalculo.
     * @example
     * // Delete one ConfiguracaoCalculo
     * const ConfiguracaoCalculo = await prisma.configuracaoCalculo.delete({
     *   where: {
     *     // ... filter to delete one ConfiguracaoCalculo
     *   }
     * })
     * 
     */
    delete<T extends ConfiguracaoCalculoDeleteArgs>(args: SelectSubset<T, ConfiguracaoCalculoDeleteArgs<ExtArgs>>): Prisma__ConfiguracaoCalculoClient<$Result.GetResult<Prisma.$ConfiguracaoCalculoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ConfiguracaoCalculo.
     * @param {ConfiguracaoCalculoUpdateArgs} args - Arguments to update one ConfiguracaoCalculo.
     * @example
     * // Update one ConfiguracaoCalculo
     * const configuracaoCalculo = await prisma.configuracaoCalculo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConfiguracaoCalculoUpdateArgs>(args: SelectSubset<T, ConfiguracaoCalculoUpdateArgs<ExtArgs>>): Prisma__ConfiguracaoCalculoClient<$Result.GetResult<Prisma.$ConfiguracaoCalculoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ConfiguracaoCalculos.
     * @param {ConfiguracaoCalculoDeleteManyArgs} args - Arguments to filter ConfiguracaoCalculos to delete.
     * @example
     * // Delete a few ConfiguracaoCalculos
     * const { count } = await prisma.configuracaoCalculo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConfiguracaoCalculoDeleteManyArgs>(args?: SelectSubset<T, ConfiguracaoCalculoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConfiguracaoCalculos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracaoCalculoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConfiguracaoCalculos
     * const configuracaoCalculo = await prisma.configuracaoCalculo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConfiguracaoCalculoUpdateManyArgs>(args: SelectSubset<T, ConfiguracaoCalculoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConfiguracaoCalculo.
     * @param {ConfiguracaoCalculoUpsertArgs} args - Arguments to update or create a ConfiguracaoCalculo.
     * @example
     * // Update or create a ConfiguracaoCalculo
     * const configuracaoCalculo = await prisma.configuracaoCalculo.upsert({
     *   create: {
     *     // ... data to create a ConfiguracaoCalculo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConfiguracaoCalculo we want to update
     *   }
     * })
     */
    upsert<T extends ConfiguracaoCalculoUpsertArgs>(args: SelectSubset<T, ConfiguracaoCalculoUpsertArgs<ExtArgs>>): Prisma__ConfiguracaoCalculoClient<$Result.GetResult<Prisma.$ConfiguracaoCalculoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ConfiguracaoCalculos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracaoCalculoCountArgs} args - Arguments to filter ConfiguracaoCalculos to count.
     * @example
     * // Count the number of ConfiguracaoCalculos
     * const count = await prisma.configuracaoCalculo.count({
     *   where: {
     *     // ... the filter for the ConfiguracaoCalculos we want to count
     *   }
     * })
    **/
    count<T extends ConfiguracaoCalculoCountArgs>(
      args?: Subset<T, ConfiguracaoCalculoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfiguracaoCalculoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConfiguracaoCalculo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracaoCalculoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfiguracaoCalculoAggregateArgs>(args: Subset<T, ConfiguracaoCalculoAggregateArgs>): Prisma.PrismaPromise<GetConfiguracaoCalculoAggregateType<T>>

    /**
     * Group by ConfiguracaoCalculo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracaoCalculoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConfiguracaoCalculoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConfiguracaoCalculoGroupByArgs['orderBy'] }
        : { orderBy?: ConfiguracaoCalculoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConfiguracaoCalculoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfiguracaoCalculoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConfiguracaoCalculo model
   */
  readonly fields: ConfiguracaoCalculoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConfiguracaoCalculo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConfiguracaoCalculoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConfiguracaoCalculo model
   */ 
  interface ConfiguracaoCalculoFieldRefs {
    readonly id: FieldRef<"ConfiguracaoCalculo", 'Int'>
    readonly createdAt: FieldRef<"ConfiguracaoCalculo", 'DateTime'>
    readonly updatedAt: FieldRef<"ConfiguracaoCalculo", 'DateTime'>
    readonly codigoModelo: FieldRef<"ConfiguracaoCalculo", 'String'>
    readonly descricao: FieldRef<"ConfiguracaoCalculo", 'String'>
    readonly percentualAdvogado: FieldRef<"ConfiguracaoCalculo", 'Decimal'>
    readonly percentualSocio: FieldRef<"ConfiguracaoCalculo", 'Decimal'>
    readonly percentualFundoReserva: FieldRef<"ConfiguracaoCalculo", 'Decimal'>
    readonly percentualEscritorio: FieldRef<"ConfiguracaoCalculo", 'Decimal'>
    readonly vigenciaInicio: FieldRef<"ConfiguracaoCalculo", 'DateTime'>
    readonly vigenciaFim: FieldRef<"ConfiguracaoCalculo", 'DateTime'>
    readonly ativo: FieldRef<"ConfiguracaoCalculo", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ConfiguracaoCalculo findUnique
   */
  export type ConfiguracaoCalculoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracaoCalculo
     */
    select?: ConfiguracaoCalculoSelect<ExtArgs> | null
    /**
     * Filter, which ConfiguracaoCalculo to fetch.
     */
    where: ConfiguracaoCalculoWhereUniqueInput
  }

  /**
   * ConfiguracaoCalculo findUniqueOrThrow
   */
  export type ConfiguracaoCalculoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracaoCalculo
     */
    select?: ConfiguracaoCalculoSelect<ExtArgs> | null
    /**
     * Filter, which ConfiguracaoCalculo to fetch.
     */
    where: ConfiguracaoCalculoWhereUniqueInput
  }

  /**
   * ConfiguracaoCalculo findFirst
   */
  export type ConfiguracaoCalculoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracaoCalculo
     */
    select?: ConfiguracaoCalculoSelect<ExtArgs> | null
    /**
     * Filter, which ConfiguracaoCalculo to fetch.
     */
    where?: ConfiguracaoCalculoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfiguracaoCalculos to fetch.
     */
    orderBy?: ConfiguracaoCalculoOrderByWithRelationInput | ConfiguracaoCalculoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfiguracaoCalculos.
     */
    cursor?: ConfiguracaoCalculoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfiguracaoCalculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfiguracaoCalculos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfiguracaoCalculos.
     */
    distinct?: ConfiguracaoCalculoScalarFieldEnum | ConfiguracaoCalculoScalarFieldEnum[]
  }

  /**
   * ConfiguracaoCalculo findFirstOrThrow
   */
  export type ConfiguracaoCalculoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracaoCalculo
     */
    select?: ConfiguracaoCalculoSelect<ExtArgs> | null
    /**
     * Filter, which ConfiguracaoCalculo to fetch.
     */
    where?: ConfiguracaoCalculoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfiguracaoCalculos to fetch.
     */
    orderBy?: ConfiguracaoCalculoOrderByWithRelationInput | ConfiguracaoCalculoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfiguracaoCalculos.
     */
    cursor?: ConfiguracaoCalculoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfiguracaoCalculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfiguracaoCalculos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfiguracaoCalculos.
     */
    distinct?: ConfiguracaoCalculoScalarFieldEnum | ConfiguracaoCalculoScalarFieldEnum[]
  }

  /**
   * ConfiguracaoCalculo findMany
   */
  export type ConfiguracaoCalculoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracaoCalculo
     */
    select?: ConfiguracaoCalculoSelect<ExtArgs> | null
    /**
     * Filter, which ConfiguracaoCalculos to fetch.
     */
    where?: ConfiguracaoCalculoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfiguracaoCalculos to fetch.
     */
    orderBy?: ConfiguracaoCalculoOrderByWithRelationInput | ConfiguracaoCalculoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConfiguracaoCalculos.
     */
    cursor?: ConfiguracaoCalculoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfiguracaoCalculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfiguracaoCalculos.
     */
    skip?: number
    distinct?: ConfiguracaoCalculoScalarFieldEnum | ConfiguracaoCalculoScalarFieldEnum[]
  }

  /**
   * ConfiguracaoCalculo create
   */
  export type ConfiguracaoCalculoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracaoCalculo
     */
    select?: ConfiguracaoCalculoSelect<ExtArgs> | null
    /**
     * The data needed to create a ConfiguracaoCalculo.
     */
    data: XOR<ConfiguracaoCalculoCreateInput, ConfiguracaoCalculoUncheckedCreateInput>
  }

  /**
   * ConfiguracaoCalculo createMany
   */
  export type ConfiguracaoCalculoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConfiguracaoCalculos.
     */
    data: ConfiguracaoCalculoCreateManyInput | ConfiguracaoCalculoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConfiguracaoCalculo createManyAndReturn
   */
  export type ConfiguracaoCalculoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracaoCalculo
     */
    select?: ConfiguracaoCalculoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ConfiguracaoCalculos.
     */
    data: ConfiguracaoCalculoCreateManyInput | ConfiguracaoCalculoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConfiguracaoCalculo update
   */
  export type ConfiguracaoCalculoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracaoCalculo
     */
    select?: ConfiguracaoCalculoSelect<ExtArgs> | null
    /**
     * The data needed to update a ConfiguracaoCalculo.
     */
    data: XOR<ConfiguracaoCalculoUpdateInput, ConfiguracaoCalculoUncheckedUpdateInput>
    /**
     * Choose, which ConfiguracaoCalculo to update.
     */
    where: ConfiguracaoCalculoWhereUniqueInput
  }

  /**
   * ConfiguracaoCalculo updateMany
   */
  export type ConfiguracaoCalculoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConfiguracaoCalculos.
     */
    data: XOR<ConfiguracaoCalculoUpdateManyMutationInput, ConfiguracaoCalculoUncheckedUpdateManyInput>
    /**
     * Filter which ConfiguracaoCalculos to update
     */
    where?: ConfiguracaoCalculoWhereInput
  }

  /**
   * ConfiguracaoCalculo upsert
   */
  export type ConfiguracaoCalculoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracaoCalculo
     */
    select?: ConfiguracaoCalculoSelect<ExtArgs> | null
    /**
     * The filter to search for the ConfiguracaoCalculo to update in case it exists.
     */
    where: ConfiguracaoCalculoWhereUniqueInput
    /**
     * In case the ConfiguracaoCalculo found by the `where` argument doesn't exist, create a new ConfiguracaoCalculo with this data.
     */
    create: XOR<ConfiguracaoCalculoCreateInput, ConfiguracaoCalculoUncheckedCreateInput>
    /**
     * In case the ConfiguracaoCalculo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConfiguracaoCalculoUpdateInput, ConfiguracaoCalculoUncheckedUpdateInput>
  }

  /**
   * ConfiguracaoCalculo delete
   */
  export type ConfiguracaoCalculoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracaoCalculo
     */
    select?: ConfiguracaoCalculoSelect<ExtArgs> | null
    /**
     * Filter which ConfiguracaoCalculo to delete.
     */
    where: ConfiguracaoCalculoWhereUniqueInput
  }

  /**
   * ConfiguracaoCalculo deleteMany
   */
  export type ConfiguracaoCalculoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfiguracaoCalculos to delete
     */
    where?: ConfiguracaoCalculoWhereInput
  }

  /**
   * ConfiguracaoCalculo without action
   */
  export type ConfiguracaoCalculoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracaoCalculo
     */
    select?: ConfiguracaoCalculoSelect<ExtArgs> | null
  }


  /**
   * Model ModeloDistribuicao
   */

  export type AggregateModeloDistribuicao = {
    _count: ModeloDistribuicaoCountAggregateOutputType | null
    _avg: ModeloDistribuicaoAvgAggregateOutputType | null
    _sum: ModeloDistribuicaoSumAggregateOutputType | null
    _min: ModeloDistribuicaoMinAggregateOutputType | null
    _max: ModeloDistribuicaoMaxAggregateOutputType | null
  }

  export type ModeloDistribuicaoAvgAggregateOutputType = {
    id: number | null
    percentual: Decimal | null
  }

  export type ModeloDistribuicaoSumAggregateOutputType = {
    id: number | null
    percentual: Decimal | null
  }

  export type ModeloDistribuicaoMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    codigo: string | null
    origem: string | null
    tipo: string | null
    percentual: Decimal | null
    destinatario: string | null
  }

  export type ModeloDistribuicaoMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    codigo: string | null
    origem: string | null
    tipo: string | null
    percentual: Decimal | null
    destinatario: string | null
  }

  export type ModeloDistribuicaoCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    codigo: number
    origem: number
    tipo: number
    percentual: number
    destinatario: number
    _all: number
  }


  export type ModeloDistribuicaoAvgAggregateInputType = {
    id?: true
    percentual?: true
  }

  export type ModeloDistribuicaoSumAggregateInputType = {
    id?: true
    percentual?: true
  }

  export type ModeloDistribuicaoMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    codigo?: true
    origem?: true
    tipo?: true
    percentual?: true
    destinatario?: true
  }

  export type ModeloDistribuicaoMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    codigo?: true
    origem?: true
    tipo?: true
    percentual?: true
    destinatario?: true
  }

  export type ModeloDistribuicaoCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    codigo?: true
    origem?: true
    tipo?: true
    percentual?: true
    destinatario?: true
    _all?: true
  }

  export type ModeloDistribuicaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModeloDistribuicao to aggregate.
     */
    where?: ModeloDistribuicaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModeloDistribuicaos to fetch.
     */
    orderBy?: ModeloDistribuicaoOrderByWithRelationInput | ModeloDistribuicaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModeloDistribuicaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModeloDistribuicaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModeloDistribuicaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModeloDistribuicaos
    **/
    _count?: true | ModeloDistribuicaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModeloDistribuicaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModeloDistribuicaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModeloDistribuicaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModeloDistribuicaoMaxAggregateInputType
  }

  export type GetModeloDistribuicaoAggregateType<T extends ModeloDistribuicaoAggregateArgs> = {
        [P in keyof T & keyof AggregateModeloDistribuicao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModeloDistribuicao[P]>
      : GetScalarType<T[P], AggregateModeloDistribuicao[P]>
  }




  export type ModeloDistribuicaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModeloDistribuicaoWhereInput
    orderBy?: ModeloDistribuicaoOrderByWithAggregationInput | ModeloDistribuicaoOrderByWithAggregationInput[]
    by: ModeloDistribuicaoScalarFieldEnum[] | ModeloDistribuicaoScalarFieldEnum
    having?: ModeloDistribuicaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModeloDistribuicaoCountAggregateInputType | true
    _avg?: ModeloDistribuicaoAvgAggregateInputType
    _sum?: ModeloDistribuicaoSumAggregateInputType
    _min?: ModeloDistribuicaoMinAggregateInputType
    _max?: ModeloDistribuicaoMaxAggregateInputType
  }

  export type ModeloDistribuicaoGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    codigo: string
    origem: string
    tipo: string
    percentual: Decimal
    destinatario: string
    _count: ModeloDistribuicaoCountAggregateOutputType | null
    _avg: ModeloDistribuicaoAvgAggregateOutputType | null
    _sum: ModeloDistribuicaoSumAggregateOutputType | null
    _min: ModeloDistribuicaoMinAggregateOutputType | null
    _max: ModeloDistribuicaoMaxAggregateOutputType | null
  }

  type GetModeloDistribuicaoGroupByPayload<T extends ModeloDistribuicaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModeloDistribuicaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModeloDistribuicaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModeloDistribuicaoGroupByOutputType[P]>
            : GetScalarType<T[P], ModeloDistribuicaoGroupByOutputType[P]>
        }
      >
    >


  export type ModeloDistribuicaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    codigo?: boolean
    origem?: boolean
    tipo?: boolean
    percentual?: boolean
    destinatario?: boolean
  }, ExtArgs["result"]["modeloDistribuicao"]>

  export type ModeloDistribuicaoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    codigo?: boolean
    origem?: boolean
    tipo?: boolean
    percentual?: boolean
    destinatario?: boolean
  }, ExtArgs["result"]["modeloDistribuicao"]>

  export type ModeloDistribuicaoSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    codigo?: boolean
    origem?: boolean
    tipo?: boolean
    percentual?: boolean
    destinatario?: boolean
  }


  export type $ModeloDistribuicaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModeloDistribuicao"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      codigo: string
      origem: string
      tipo: string
      percentual: Prisma.Decimal
      destinatario: string
    }, ExtArgs["result"]["modeloDistribuicao"]>
    composites: {}
  }

  type ModeloDistribuicaoGetPayload<S extends boolean | null | undefined | ModeloDistribuicaoDefaultArgs> = $Result.GetResult<Prisma.$ModeloDistribuicaoPayload, S>

  type ModeloDistribuicaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ModeloDistribuicaoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ModeloDistribuicaoCountAggregateInputType | true
    }

  export interface ModeloDistribuicaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModeloDistribuicao'], meta: { name: 'ModeloDistribuicao' } }
    /**
     * Find zero or one ModeloDistribuicao that matches the filter.
     * @param {ModeloDistribuicaoFindUniqueArgs} args - Arguments to find a ModeloDistribuicao
     * @example
     * // Get one ModeloDistribuicao
     * const modeloDistribuicao = await prisma.modeloDistribuicao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModeloDistribuicaoFindUniqueArgs>(args: SelectSubset<T, ModeloDistribuicaoFindUniqueArgs<ExtArgs>>): Prisma__ModeloDistribuicaoClient<$Result.GetResult<Prisma.$ModeloDistribuicaoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ModeloDistribuicao that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ModeloDistribuicaoFindUniqueOrThrowArgs} args - Arguments to find a ModeloDistribuicao
     * @example
     * // Get one ModeloDistribuicao
     * const modeloDistribuicao = await prisma.modeloDistribuicao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModeloDistribuicaoFindUniqueOrThrowArgs>(args: SelectSubset<T, ModeloDistribuicaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModeloDistribuicaoClient<$Result.GetResult<Prisma.$ModeloDistribuicaoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ModeloDistribuicao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModeloDistribuicaoFindFirstArgs} args - Arguments to find a ModeloDistribuicao
     * @example
     * // Get one ModeloDistribuicao
     * const modeloDistribuicao = await prisma.modeloDistribuicao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModeloDistribuicaoFindFirstArgs>(args?: SelectSubset<T, ModeloDistribuicaoFindFirstArgs<ExtArgs>>): Prisma__ModeloDistribuicaoClient<$Result.GetResult<Prisma.$ModeloDistribuicaoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ModeloDistribuicao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModeloDistribuicaoFindFirstOrThrowArgs} args - Arguments to find a ModeloDistribuicao
     * @example
     * // Get one ModeloDistribuicao
     * const modeloDistribuicao = await prisma.modeloDistribuicao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModeloDistribuicaoFindFirstOrThrowArgs>(args?: SelectSubset<T, ModeloDistribuicaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModeloDistribuicaoClient<$Result.GetResult<Prisma.$ModeloDistribuicaoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ModeloDistribuicaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModeloDistribuicaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModeloDistribuicaos
     * const modeloDistribuicaos = await prisma.modeloDistribuicao.findMany()
     * 
     * // Get first 10 ModeloDistribuicaos
     * const modeloDistribuicaos = await prisma.modeloDistribuicao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modeloDistribuicaoWithIdOnly = await prisma.modeloDistribuicao.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModeloDistribuicaoFindManyArgs>(args?: SelectSubset<T, ModeloDistribuicaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModeloDistribuicaoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ModeloDistribuicao.
     * @param {ModeloDistribuicaoCreateArgs} args - Arguments to create a ModeloDistribuicao.
     * @example
     * // Create one ModeloDistribuicao
     * const ModeloDistribuicao = await prisma.modeloDistribuicao.create({
     *   data: {
     *     // ... data to create a ModeloDistribuicao
     *   }
     * })
     * 
     */
    create<T extends ModeloDistribuicaoCreateArgs>(args: SelectSubset<T, ModeloDistribuicaoCreateArgs<ExtArgs>>): Prisma__ModeloDistribuicaoClient<$Result.GetResult<Prisma.$ModeloDistribuicaoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ModeloDistribuicaos.
     * @param {ModeloDistribuicaoCreateManyArgs} args - Arguments to create many ModeloDistribuicaos.
     * @example
     * // Create many ModeloDistribuicaos
     * const modeloDistribuicao = await prisma.modeloDistribuicao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModeloDistribuicaoCreateManyArgs>(args?: SelectSubset<T, ModeloDistribuicaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModeloDistribuicaos and returns the data saved in the database.
     * @param {ModeloDistribuicaoCreateManyAndReturnArgs} args - Arguments to create many ModeloDistribuicaos.
     * @example
     * // Create many ModeloDistribuicaos
     * const modeloDistribuicao = await prisma.modeloDistribuicao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModeloDistribuicaos and only return the `id`
     * const modeloDistribuicaoWithIdOnly = await prisma.modeloDistribuicao.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModeloDistribuicaoCreateManyAndReturnArgs>(args?: SelectSubset<T, ModeloDistribuicaoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModeloDistribuicaoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ModeloDistribuicao.
     * @param {ModeloDistribuicaoDeleteArgs} args - Arguments to delete one ModeloDistribuicao.
     * @example
     * // Delete one ModeloDistribuicao
     * const ModeloDistribuicao = await prisma.modeloDistribuicao.delete({
     *   where: {
     *     // ... filter to delete one ModeloDistribuicao
     *   }
     * })
     * 
     */
    delete<T extends ModeloDistribuicaoDeleteArgs>(args: SelectSubset<T, ModeloDistribuicaoDeleteArgs<ExtArgs>>): Prisma__ModeloDistribuicaoClient<$Result.GetResult<Prisma.$ModeloDistribuicaoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ModeloDistribuicao.
     * @param {ModeloDistribuicaoUpdateArgs} args - Arguments to update one ModeloDistribuicao.
     * @example
     * // Update one ModeloDistribuicao
     * const modeloDistribuicao = await prisma.modeloDistribuicao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModeloDistribuicaoUpdateArgs>(args: SelectSubset<T, ModeloDistribuicaoUpdateArgs<ExtArgs>>): Prisma__ModeloDistribuicaoClient<$Result.GetResult<Prisma.$ModeloDistribuicaoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ModeloDistribuicaos.
     * @param {ModeloDistribuicaoDeleteManyArgs} args - Arguments to filter ModeloDistribuicaos to delete.
     * @example
     * // Delete a few ModeloDistribuicaos
     * const { count } = await prisma.modeloDistribuicao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModeloDistribuicaoDeleteManyArgs>(args?: SelectSubset<T, ModeloDistribuicaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModeloDistribuicaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModeloDistribuicaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModeloDistribuicaos
     * const modeloDistribuicao = await prisma.modeloDistribuicao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModeloDistribuicaoUpdateManyArgs>(args: SelectSubset<T, ModeloDistribuicaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ModeloDistribuicao.
     * @param {ModeloDistribuicaoUpsertArgs} args - Arguments to update or create a ModeloDistribuicao.
     * @example
     * // Update or create a ModeloDistribuicao
     * const modeloDistribuicao = await prisma.modeloDistribuicao.upsert({
     *   create: {
     *     // ... data to create a ModeloDistribuicao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModeloDistribuicao we want to update
     *   }
     * })
     */
    upsert<T extends ModeloDistribuicaoUpsertArgs>(args: SelectSubset<T, ModeloDistribuicaoUpsertArgs<ExtArgs>>): Prisma__ModeloDistribuicaoClient<$Result.GetResult<Prisma.$ModeloDistribuicaoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ModeloDistribuicaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModeloDistribuicaoCountArgs} args - Arguments to filter ModeloDistribuicaos to count.
     * @example
     * // Count the number of ModeloDistribuicaos
     * const count = await prisma.modeloDistribuicao.count({
     *   where: {
     *     // ... the filter for the ModeloDistribuicaos we want to count
     *   }
     * })
    **/
    count<T extends ModeloDistribuicaoCountArgs>(
      args?: Subset<T, ModeloDistribuicaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModeloDistribuicaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModeloDistribuicao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModeloDistribuicaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModeloDistribuicaoAggregateArgs>(args: Subset<T, ModeloDistribuicaoAggregateArgs>): Prisma.PrismaPromise<GetModeloDistribuicaoAggregateType<T>>

    /**
     * Group by ModeloDistribuicao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModeloDistribuicaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModeloDistribuicaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModeloDistribuicaoGroupByArgs['orderBy'] }
        : { orderBy?: ModeloDistribuicaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModeloDistribuicaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModeloDistribuicaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModeloDistribuicao model
   */
  readonly fields: ModeloDistribuicaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModeloDistribuicao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModeloDistribuicaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModeloDistribuicao model
   */ 
  interface ModeloDistribuicaoFieldRefs {
    readonly id: FieldRef<"ModeloDistribuicao", 'Int'>
    readonly createdAt: FieldRef<"ModeloDistribuicao", 'DateTime'>
    readonly updatedAt: FieldRef<"ModeloDistribuicao", 'DateTime'>
    readonly codigo: FieldRef<"ModeloDistribuicao", 'String'>
    readonly origem: FieldRef<"ModeloDistribuicao", 'String'>
    readonly tipo: FieldRef<"ModeloDistribuicao", 'String'>
    readonly percentual: FieldRef<"ModeloDistribuicao", 'Decimal'>
    readonly destinatario: FieldRef<"ModeloDistribuicao", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ModeloDistribuicao findUnique
   */
  export type ModeloDistribuicaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeloDistribuicao
     */
    select?: ModeloDistribuicaoSelect<ExtArgs> | null
    /**
     * Filter, which ModeloDistribuicao to fetch.
     */
    where: ModeloDistribuicaoWhereUniqueInput
  }

  /**
   * ModeloDistribuicao findUniqueOrThrow
   */
  export type ModeloDistribuicaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeloDistribuicao
     */
    select?: ModeloDistribuicaoSelect<ExtArgs> | null
    /**
     * Filter, which ModeloDistribuicao to fetch.
     */
    where: ModeloDistribuicaoWhereUniqueInput
  }

  /**
   * ModeloDistribuicao findFirst
   */
  export type ModeloDistribuicaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeloDistribuicao
     */
    select?: ModeloDistribuicaoSelect<ExtArgs> | null
    /**
     * Filter, which ModeloDistribuicao to fetch.
     */
    where?: ModeloDistribuicaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModeloDistribuicaos to fetch.
     */
    orderBy?: ModeloDistribuicaoOrderByWithRelationInput | ModeloDistribuicaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModeloDistribuicaos.
     */
    cursor?: ModeloDistribuicaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModeloDistribuicaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModeloDistribuicaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModeloDistribuicaos.
     */
    distinct?: ModeloDistribuicaoScalarFieldEnum | ModeloDistribuicaoScalarFieldEnum[]
  }

  /**
   * ModeloDistribuicao findFirstOrThrow
   */
  export type ModeloDistribuicaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeloDistribuicao
     */
    select?: ModeloDistribuicaoSelect<ExtArgs> | null
    /**
     * Filter, which ModeloDistribuicao to fetch.
     */
    where?: ModeloDistribuicaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModeloDistribuicaos to fetch.
     */
    orderBy?: ModeloDistribuicaoOrderByWithRelationInput | ModeloDistribuicaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModeloDistribuicaos.
     */
    cursor?: ModeloDistribuicaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModeloDistribuicaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModeloDistribuicaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModeloDistribuicaos.
     */
    distinct?: ModeloDistribuicaoScalarFieldEnum | ModeloDistribuicaoScalarFieldEnum[]
  }

  /**
   * ModeloDistribuicao findMany
   */
  export type ModeloDistribuicaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeloDistribuicao
     */
    select?: ModeloDistribuicaoSelect<ExtArgs> | null
    /**
     * Filter, which ModeloDistribuicaos to fetch.
     */
    where?: ModeloDistribuicaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModeloDistribuicaos to fetch.
     */
    orderBy?: ModeloDistribuicaoOrderByWithRelationInput | ModeloDistribuicaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModeloDistribuicaos.
     */
    cursor?: ModeloDistribuicaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModeloDistribuicaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModeloDistribuicaos.
     */
    skip?: number
    distinct?: ModeloDistribuicaoScalarFieldEnum | ModeloDistribuicaoScalarFieldEnum[]
  }

  /**
   * ModeloDistribuicao create
   */
  export type ModeloDistribuicaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeloDistribuicao
     */
    select?: ModeloDistribuicaoSelect<ExtArgs> | null
    /**
     * The data needed to create a ModeloDistribuicao.
     */
    data: XOR<ModeloDistribuicaoCreateInput, ModeloDistribuicaoUncheckedCreateInput>
  }

  /**
   * ModeloDistribuicao createMany
   */
  export type ModeloDistribuicaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModeloDistribuicaos.
     */
    data: ModeloDistribuicaoCreateManyInput | ModeloDistribuicaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModeloDistribuicao createManyAndReturn
   */
  export type ModeloDistribuicaoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeloDistribuicao
     */
    select?: ModeloDistribuicaoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ModeloDistribuicaos.
     */
    data: ModeloDistribuicaoCreateManyInput | ModeloDistribuicaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModeloDistribuicao update
   */
  export type ModeloDistribuicaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeloDistribuicao
     */
    select?: ModeloDistribuicaoSelect<ExtArgs> | null
    /**
     * The data needed to update a ModeloDistribuicao.
     */
    data: XOR<ModeloDistribuicaoUpdateInput, ModeloDistribuicaoUncheckedUpdateInput>
    /**
     * Choose, which ModeloDistribuicao to update.
     */
    where: ModeloDistribuicaoWhereUniqueInput
  }

  /**
   * ModeloDistribuicao updateMany
   */
  export type ModeloDistribuicaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModeloDistribuicaos.
     */
    data: XOR<ModeloDistribuicaoUpdateManyMutationInput, ModeloDistribuicaoUncheckedUpdateManyInput>
    /**
     * Filter which ModeloDistribuicaos to update
     */
    where?: ModeloDistribuicaoWhereInput
  }

  /**
   * ModeloDistribuicao upsert
   */
  export type ModeloDistribuicaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeloDistribuicao
     */
    select?: ModeloDistribuicaoSelect<ExtArgs> | null
    /**
     * The filter to search for the ModeloDistribuicao to update in case it exists.
     */
    where: ModeloDistribuicaoWhereUniqueInput
    /**
     * In case the ModeloDistribuicao found by the `where` argument doesn't exist, create a new ModeloDistribuicao with this data.
     */
    create: XOR<ModeloDistribuicaoCreateInput, ModeloDistribuicaoUncheckedCreateInput>
    /**
     * In case the ModeloDistribuicao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModeloDistribuicaoUpdateInput, ModeloDistribuicaoUncheckedUpdateInput>
  }

  /**
   * ModeloDistribuicao delete
   */
  export type ModeloDistribuicaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeloDistribuicao
     */
    select?: ModeloDistribuicaoSelect<ExtArgs> | null
    /**
     * Filter which ModeloDistribuicao to delete.
     */
    where: ModeloDistribuicaoWhereUniqueInput
  }

  /**
   * ModeloDistribuicao deleteMany
   */
  export type ModeloDistribuicaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModeloDistribuicaos to delete
     */
    where?: ModeloDistribuicaoWhereInput
  }

  /**
   * ModeloDistribuicao without action
   */
  export type ModeloDistribuicaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeloDistribuicao
     */
    select?: ModeloDistribuicaoSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ClienteScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    cpfCnpj: 'cpfCnpj',
    nomeRazaoSocial: 'nomeRazaoSocial',
    email: 'email',
    telefone: 'telefone',
    observacoes: 'observacoes',
    ativo: 'ativo'
  };

  export type ClienteScalarFieldEnum = (typeof ClienteScalarFieldEnum)[keyof typeof ClienteScalarFieldEnum]


  export const OrdemPagamentoScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    clienteId: 'clienteId',
    sequenciaCliente: 'sequenciaCliente',
    codigoInterno: 'codigoInterno',
    descricao: 'descricao',
    tipoContrato: 'tipoContrato',
    valorTotalPrevisto: 'valorTotalPrevisto',
    modeloPagamento: 'modeloPagamento',
    dataInicio: 'dataInicio',
    dataFimPrevista: 'dataFimPrevista',
    status: 'status'
  };

  export type OrdemPagamentoScalarFieldEnum = (typeof OrdemPagamentoScalarFieldEnum)[keyof typeof OrdemPagamentoScalarFieldEnum]


  export const PagamentoScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ordemPagamentoId: 'ordemPagamentoId',
    numeroParcela: 'numeroParcela',
    dataPrevista: 'dataPrevista',
    dataEfetiva: 'dataEfetiva',
    valorPrevisto: 'valorPrevisto',
    valorPago: 'valorPago',
    formaPagamento: 'formaPagamento',
    status: 'status',
    observacoes: 'observacoes'
  };

  export type PagamentoScalarFieldEnum = (typeof PagamentoScalarFieldEnum)[keyof typeof PagamentoScalarFieldEnum]


  export const AdvogadoScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    nome: 'nome',
    cpf: 'cpf',
    email: 'email',
    telefone: 'telefone',
    tipo: 'tipo',
    possuiFixoMensal: 'possuiFixoMensal',
    valorFixoMensal: 'valorFixoMensal',
    ativo: 'ativo'
  };

  export type AdvogadoScalarFieldEnum = (typeof AdvogadoScalarFieldEnum)[keyof typeof AdvogadoScalarFieldEnum]


  export const RepasseScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    advogadoId: 'advogadoId',
    ordemPagamentoId: 'ordemPagamentoId',
    referenciaCompetencia: 'referenciaCompetencia',
    valorDevido: 'valorDevido',
    valorPago: 'valorPago',
    dataPagamento: 'dataPagamento',
    saldoAReceber: 'saldoAReceber',
    origem: 'origem',
    modeloDistribuicaoCodigo: 'modeloDistribuicaoCodigo',
    observacoes: 'observacoes'
  };

  export type RepasseScalarFieldEnum = (typeof RepasseScalarFieldEnum)[keyof typeof RepasseScalarFieldEnum]


  export const EstagiarioScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    nome: 'nome',
    cpf: 'cpf',
    email: 'email',
    telefone: 'telefone',
    auxilioTransporteValor: 'auxilioTransporteValor',
    auxilioEstagioValor: 'auxilioEstagioValor',
    ativo: 'ativo'
  };

  export type EstagiarioScalarFieldEnum = (typeof EstagiarioScalarFieldEnum)[keyof typeof EstagiarioScalarFieldEnum]


  export const PrestadorServicoScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    nomeRazaoSocial: 'nomeRazaoSocial',
    cpfCnpj: 'cpfCnpj',
    tipo: 'tipo',
    valorRecorrente: 'valorRecorrente',
    observacoes: 'observacoes',
    ativo: 'ativo'
  };

  export type PrestadorServicoScalarFieldEnum = (typeof PrestadorServicoScalarFieldEnum)[keyof typeof PrestadorServicoScalarFieldEnum]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    nome: 'nome',
    email: 'email',
    senhaHash: 'senhaHash',
    perfil: 'perfil',
    ativo: 'ativo'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const ConfiguracaoCalculoScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    codigoModelo: 'codigoModelo',
    descricao: 'descricao',
    percentualAdvogado: 'percentualAdvogado',
    percentualSocio: 'percentualSocio',
    percentualFundoReserva: 'percentualFundoReserva',
    percentualEscritorio: 'percentualEscritorio',
    vigenciaInicio: 'vigenciaInicio',
    vigenciaFim: 'vigenciaFim',
    ativo: 'ativo'
  };

  export type ConfiguracaoCalculoScalarFieldEnum = (typeof ConfiguracaoCalculoScalarFieldEnum)[keyof typeof ConfiguracaoCalculoScalarFieldEnum]


  export const ModeloDistribuicaoScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    codigo: 'codigo',
    origem: 'origem',
    tipo: 'tipo',
    percentual: 'percentual',
    destinatario: 'destinatario'
  };

  export type ModeloDistribuicaoScalarFieldEnum = (typeof ModeloDistribuicaoScalarFieldEnum)[keyof typeof ModeloDistribuicaoScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'ModeloPagamento'
   */
  export type EnumModeloPagamentoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ModeloPagamento'>
    


  /**
   * Reference to a field of type 'ModeloPagamento[]'
   */
  export type ListEnumModeloPagamentoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ModeloPagamento[]'>
    


  /**
   * Reference to a field of type 'StatusOrdem'
   */
  export type EnumStatusOrdemFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusOrdem'>
    


  /**
   * Reference to a field of type 'StatusOrdem[]'
   */
  export type ListEnumStatusOrdemFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusOrdem[]'>
    


  /**
   * Reference to a field of type 'StatusPagamento'
   */
  export type EnumStatusPagamentoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusPagamento'>
    


  /**
   * Reference to a field of type 'StatusPagamento[]'
   */
  export type ListEnumStatusPagamentoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusPagamento[]'>
    


  /**
   * Reference to a field of type 'TipoAdvogado'
   */
  export type EnumTipoAdvogadoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoAdvogado'>
    


  /**
   * Reference to a field of type 'TipoAdvogado[]'
   */
  export type ListEnumTipoAdvogadoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoAdvogado[]'>
    


  /**
   * Reference to a field of type 'OrigemRepasse'
   */
  export type EnumOrigemRepasseFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrigemRepasse'>
    


  /**
   * Reference to a field of type 'OrigemRepasse[]'
   */
  export type ListEnumOrigemRepasseFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrigemRepasse[]'>
    


  /**
   * Reference to a field of type 'PerfilUsuario'
   */
  export type EnumPerfilUsuarioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PerfilUsuario'>
    


  /**
   * Reference to a field of type 'PerfilUsuario[]'
   */
  export type ListEnumPerfilUsuarioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PerfilUsuario[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type ClienteWhereInput = {
    AND?: ClienteWhereInput | ClienteWhereInput[]
    OR?: ClienteWhereInput[]
    NOT?: ClienteWhereInput | ClienteWhereInput[]
    id?: IntFilter<"Cliente"> | number
    createdAt?: DateTimeFilter<"Cliente"> | Date | string
    updatedAt?: DateTimeFilter<"Cliente"> | Date | string
    cpfCnpj?: StringFilter<"Cliente"> | string
    nomeRazaoSocial?: StringFilter<"Cliente"> | string
    email?: StringNullableFilter<"Cliente"> | string | null
    telefone?: StringNullableFilter<"Cliente"> | string | null
    observacoes?: StringNullableFilter<"Cliente"> | string | null
    ativo?: BoolFilter<"Cliente"> | boolean
    ordens?: OrdemPagamentoListRelationFilter
  }

  export type ClienteOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cpfCnpj?: SortOrder
    nomeRazaoSocial?: SortOrder
    email?: SortOrderInput | SortOrder
    telefone?: SortOrderInput | SortOrder
    observacoes?: SortOrderInput | SortOrder
    ativo?: SortOrder
    ordens?: OrdemPagamentoOrderByRelationAggregateInput
  }

  export type ClienteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClienteWhereInput | ClienteWhereInput[]
    OR?: ClienteWhereInput[]
    NOT?: ClienteWhereInput | ClienteWhereInput[]
    createdAt?: DateTimeFilter<"Cliente"> | Date | string
    updatedAt?: DateTimeFilter<"Cliente"> | Date | string
    cpfCnpj?: StringFilter<"Cliente"> | string
    nomeRazaoSocial?: StringFilter<"Cliente"> | string
    email?: StringNullableFilter<"Cliente"> | string | null
    telefone?: StringNullableFilter<"Cliente"> | string | null
    observacoes?: StringNullableFilter<"Cliente"> | string | null
    ativo?: BoolFilter<"Cliente"> | boolean
    ordens?: OrdemPagamentoListRelationFilter
  }, "id">

  export type ClienteOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cpfCnpj?: SortOrder
    nomeRazaoSocial?: SortOrder
    email?: SortOrderInput | SortOrder
    telefone?: SortOrderInput | SortOrder
    observacoes?: SortOrderInput | SortOrder
    ativo?: SortOrder
    _count?: ClienteCountOrderByAggregateInput
    _avg?: ClienteAvgOrderByAggregateInput
    _max?: ClienteMaxOrderByAggregateInput
    _min?: ClienteMinOrderByAggregateInput
    _sum?: ClienteSumOrderByAggregateInput
  }

  export type ClienteScalarWhereWithAggregatesInput = {
    AND?: ClienteScalarWhereWithAggregatesInput | ClienteScalarWhereWithAggregatesInput[]
    OR?: ClienteScalarWhereWithAggregatesInput[]
    NOT?: ClienteScalarWhereWithAggregatesInput | ClienteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Cliente"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Cliente"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Cliente"> | Date | string
    cpfCnpj?: StringWithAggregatesFilter<"Cliente"> | string
    nomeRazaoSocial?: StringWithAggregatesFilter<"Cliente"> | string
    email?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
    telefone?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
    observacoes?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
    ativo?: BoolWithAggregatesFilter<"Cliente"> | boolean
  }

  export type OrdemPagamentoWhereInput = {
    AND?: OrdemPagamentoWhereInput | OrdemPagamentoWhereInput[]
    OR?: OrdemPagamentoWhereInput[]
    NOT?: OrdemPagamentoWhereInput | OrdemPagamentoWhereInput[]
    id?: IntFilter<"OrdemPagamento"> | number
    createdAt?: DateTimeFilter<"OrdemPagamento"> | Date | string
    updatedAt?: DateTimeFilter<"OrdemPagamento"> | Date | string
    clienteId?: IntFilter<"OrdemPagamento"> | number
    sequenciaCliente?: IntFilter<"OrdemPagamento"> | number
    codigoInterno?: StringNullableFilter<"OrdemPagamento"> | string | null
    descricao?: StringNullableFilter<"OrdemPagamento"> | string | null
    tipoContrato?: StringNullableFilter<"OrdemPagamento"> | string | null
    valorTotalPrevisto?: DecimalNullableFilter<"OrdemPagamento"> | Decimal | DecimalJsLike | number | string | null
    modeloPagamento?: EnumModeloPagamentoFilter<"OrdemPagamento"> | $Enums.ModeloPagamento
    dataInicio?: DateTimeFilter<"OrdemPagamento"> | Date | string
    dataFimPrevista?: DateTimeNullableFilter<"OrdemPagamento"> | Date | string | null
    status?: EnumStatusOrdemFilter<"OrdemPagamento"> | $Enums.StatusOrdem
    cliente?: XOR<ClienteRelationFilter, ClienteWhereInput>
    pagamentos?: PagamentoListRelationFilter
    repasses?: RepasseListRelationFilter
  }

  export type OrdemPagamentoOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clienteId?: SortOrder
    sequenciaCliente?: SortOrder
    codigoInterno?: SortOrderInput | SortOrder
    descricao?: SortOrderInput | SortOrder
    tipoContrato?: SortOrderInput | SortOrder
    valorTotalPrevisto?: SortOrderInput | SortOrder
    modeloPagamento?: SortOrder
    dataInicio?: SortOrder
    dataFimPrevista?: SortOrderInput | SortOrder
    status?: SortOrder
    cliente?: ClienteOrderByWithRelationInput
    pagamentos?: PagamentoOrderByRelationAggregateInput
    repasses?: RepasseOrderByRelationAggregateInput
  }

  export type OrdemPagamentoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrdemPagamentoWhereInput | OrdemPagamentoWhereInput[]
    OR?: OrdemPagamentoWhereInput[]
    NOT?: OrdemPagamentoWhereInput | OrdemPagamentoWhereInput[]
    createdAt?: DateTimeFilter<"OrdemPagamento"> | Date | string
    updatedAt?: DateTimeFilter<"OrdemPagamento"> | Date | string
    clienteId?: IntFilter<"OrdemPagamento"> | number
    sequenciaCliente?: IntFilter<"OrdemPagamento"> | number
    codigoInterno?: StringNullableFilter<"OrdemPagamento"> | string | null
    descricao?: StringNullableFilter<"OrdemPagamento"> | string | null
    tipoContrato?: StringNullableFilter<"OrdemPagamento"> | string | null
    valorTotalPrevisto?: DecimalNullableFilter<"OrdemPagamento"> | Decimal | DecimalJsLike | number | string | null
    modeloPagamento?: EnumModeloPagamentoFilter<"OrdemPagamento"> | $Enums.ModeloPagamento
    dataInicio?: DateTimeFilter<"OrdemPagamento"> | Date | string
    dataFimPrevista?: DateTimeNullableFilter<"OrdemPagamento"> | Date | string | null
    status?: EnumStatusOrdemFilter<"OrdemPagamento"> | $Enums.StatusOrdem
    cliente?: XOR<ClienteRelationFilter, ClienteWhereInput>
    pagamentos?: PagamentoListRelationFilter
    repasses?: RepasseListRelationFilter
  }, "id">

  export type OrdemPagamentoOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clienteId?: SortOrder
    sequenciaCliente?: SortOrder
    codigoInterno?: SortOrderInput | SortOrder
    descricao?: SortOrderInput | SortOrder
    tipoContrato?: SortOrderInput | SortOrder
    valorTotalPrevisto?: SortOrderInput | SortOrder
    modeloPagamento?: SortOrder
    dataInicio?: SortOrder
    dataFimPrevista?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: OrdemPagamentoCountOrderByAggregateInput
    _avg?: OrdemPagamentoAvgOrderByAggregateInput
    _max?: OrdemPagamentoMaxOrderByAggregateInput
    _min?: OrdemPagamentoMinOrderByAggregateInput
    _sum?: OrdemPagamentoSumOrderByAggregateInput
  }

  export type OrdemPagamentoScalarWhereWithAggregatesInput = {
    AND?: OrdemPagamentoScalarWhereWithAggregatesInput | OrdemPagamentoScalarWhereWithAggregatesInput[]
    OR?: OrdemPagamentoScalarWhereWithAggregatesInput[]
    NOT?: OrdemPagamentoScalarWhereWithAggregatesInput | OrdemPagamentoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrdemPagamento"> | number
    createdAt?: DateTimeWithAggregatesFilter<"OrdemPagamento"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrdemPagamento"> | Date | string
    clienteId?: IntWithAggregatesFilter<"OrdemPagamento"> | number
    sequenciaCliente?: IntWithAggregatesFilter<"OrdemPagamento"> | number
    codigoInterno?: StringNullableWithAggregatesFilter<"OrdemPagamento"> | string | null
    descricao?: StringNullableWithAggregatesFilter<"OrdemPagamento"> | string | null
    tipoContrato?: StringNullableWithAggregatesFilter<"OrdemPagamento"> | string | null
    valorTotalPrevisto?: DecimalNullableWithAggregatesFilter<"OrdemPagamento"> | Decimal | DecimalJsLike | number | string | null
    modeloPagamento?: EnumModeloPagamentoWithAggregatesFilter<"OrdemPagamento"> | $Enums.ModeloPagamento
    dataInicio?: DateTimeWithAggregatesFilter<"OrdemPagamento"> | Date | string
    dataFimPrevista?: DateTimeNullableWithAggregatesFilter<"OrdemPagamento"> | Date | string | null
    status?: EnumStatusOrdemWithAggregatesFilter<"OrdemPagamento"> | $Enums.StatusOrdem
  }

  export type PagamentoWhereInput = {
    AND?: PagamentoWhereInput | PagamentoWhereInput[]
    OR?: PagamentoWhereInput[]
    NOT?: PagamentoWhereInput | PagamentoWhereInput[]
    id?: IntFilter<"Pagamento"> | number
    createdAt?: DateTimeFilter<"Pagamento"> | Date | string
    updatedAt?: DateTimeFilter<"Pagamento"> | Date | string
    ordemPagamentoId?: IntFilter<"Pagamento"> | number
    numeroParcela?: IntFilter<"Pagamento"> | number
    dataPrevista?: DateTimeFilter<"Pagamento"> | Date | string
    dataEfetiva?: DateTimeNullableFilter<"Pagamento"> | Date | string | null
    valorPrevisto?: DecimalFilter<"Pagamento"> | Decimal | DecimalJsLike | number | string
    valorPago?: DecimalNullableFilter<"Pagamento"> | Decimal | DecimalJsLike | number | string | null
    formaPagamento?: StringNullableFilter<"Pagamento"> | string | null
    status?: EnumStatusPagamentoFilter<"Pagamento"> | $Enums.StatusPagamento
    observacoes?: StringNullableFilter<"Pagamento"> | string | null
    ordemPagamento?: XOR<OrdemPagamentoRelationFilter, OrdemPagamentoWhereInput>
  }

  export type PagamentoOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ordemPagamentoId?: SortOrder
    numeroParcela?: SortOrder
    dataPrevista?: SortOrder
    dataEfetiva?: SortOrderInput | SortOrder
    valorPrevisto?: SortOrder
    valorPago?: SortOrderInput | SortOrder
    formaPagamento?: SortOrderInput | SortOrder
    status?: SortOrder
    observacoes?: SortOrderInput | SortOrder
    ordemPagamento?: OrdemPagamentoOrderByWithRelationInput
  }

  export type PagamentoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PagamentoWhereInput | PagamentoWhereInput[]
    OR?: PagamentoWhereInput[]
    NOT?: PagamentoWhereInput | PagamentoWhereInput[]
    createdAt?: DateTimeFilter<"Pagamento"> | Date | string
    updatedAt?: DateTimeFilter<"Pagamento"> | Date | string
    ordemPagamentoId?: IntFilter<"Pagamento"> | number
    numeroParcela?: IntFilter<"Pagamento"> | number
    dataPrevista?: DateTimeFilter<"Pagamento"> | Date | string
    dataEfetiva?: DateTimeNullableFilter<"Pagamento"> | Date | string | null
    valorPrevisto?: DecimalFilter<"Pagamento"> | Decimal | DecimalJsLike | number | string
    valorPago?: DecimalNullableFilter<"Pagamento"> | Decimal | DecimalJsLike | number | string | null
    formaPagamento?: StringNullableFilter<"Pagamento"> | string | null
    status?: EnumStatusPagamentoFilter<"Pagamento"> | $Enums.StatusPagamento
    observacoes?: StringNullableFilter<"Pagamento"> | string | null
    ordemPagamento?: XOR<OrdemPagamentoRelationFilter, OrdemPagamentoWhereInput>
  }, "id">

  export type PagamentoOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ordemPagamentoId?: SortOrder
    numeroParcela?: SortOrder
    dataPrevista?: SortOrder
    dataEfetiva?: SortOrderInput | SortOrder
    valorPrevisto?: SortOrder
    valorPago?: SortOrderInput | SortOrder
    formaPagamento?: SortOrderInput | SortOrder
    status?: SortOrder
    observacoes?: SortOrderInput | SortOrder
    _count?: PagamentoCountOrderByAggregateInput
    _avg?: PagamentoAvgOrderByAggregateInput
    _max?: PagamentoMaxOrderByAggregateInput
    _min?: PagamentoMinOrderByAggregateInput
    _sum?: PagamentoSumOrderByAggregateInput
  }

  export type PagamentoScalarWhereWithAggregatesInput = {
    AND?: PagamentoScalarWhereWithAggregatesInput | PagamentoScalarWhereWithAggregatesInput[]
    OR?: PagamentoScalarWhereWithAggregatesInput[]
    NOT?: PagamentoScalarWhereWithAggregatesInput | PagamentoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Pagamento"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Pagamento"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Pagamento"> | Date | string
    ordemPagamentoId?: IntWithAggregatesFilter<"Pagamento"> | number
    numeroParcela?: IntWithAggregatesFilter<"Pagamento"> | number
    dataPrevista?: DateTimeWithAggregatesFilter<"Pagamento"> | Date | string
    dataEfetiva?: DateTimeNullableWithAggregatesFilter<"Pagamento"> | Date | string | null
    valorPrevisto?: DecimalWithAggregatesFilter<"Pagamento"> | Decimal | DecimalJsLike | number | string
    valorPago?: DecimalNullableWithAggregatesFilter<"Pagamento"> | Decimal | DecimalJsLike | number | string | null
    formaPagamento?: StringNullableWithAggregatesFilter<"Pagamento"> | string | null
    status?: EnumStatusPagamentoWithAggregatesFilter<"Pagamento"> | $Enums.StatusPagamento
    observacoes?: StringNullableWithAggregatesFilter<"Pagamento"> | string | null
  }

  export type AdvogadoWhereInput = {
    AND?: AdvogadoWhereInput | AdvogadoWhereInput[]
    OR?: AdvogadoWhereInput[]
    NOT?: AdvogadoWhereInput | AdvogadoWhereInput[]
    id?: IntFilter<"Advogado"> | number
    createdAt?: DateTimeFilter<"Advogado"> | Date | string
    updatedAt?: DateTimeFilter<"Advogado"> | Date | string
    nome?: StringFilter<"Advogado"> | string
    cpf?: StringNullableFilter<"Advogado"> | string | null
    email?: StringNullableFilter<"Advogado"> | string | null
    telefone?: StringNullableFilter<"Advogado"> | string | null
    tipo?: EnumTipoAdvogadoFilter<"Advogado"> | $Enums.TipoAdvogado
    possuiFixoMensal?: BoolFilter<"Advogado"> | boolean
    valorFixoMensal?: DecimalNullableFilter<"Advogado"> | Decimal | DecimalJsLike | number | string | null
    ativo?: BoolFilter<"Advogado"> | boolean
    repasses?: RepasseListRelationFilter
  }

  export type AdvogadoOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nome?: SortOrder
    cpf?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    telefone?: SortOrderInput | SortOrder
    tipo?: SortOrder
    possuiFixoMensal?: SortOrder
    valorFixoMensal?: SortOrderInput | SortOrder
    ativo?: SortOrder
    repasses?: RepasseOrderByRelationAggregateInput
  }

  export type AdvogadoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AdvogadoWhereInput | AdvogadoWhereInput[]
    OR?: AdvogadoWhereInput[]
    NOT?: AdvogadoWhereInput | AdvogadoWhereInput[]
    createdAt?: DateTimeFilter<"Advogado"> | Date | string
    updatedAt?: DateTimeFilter<"Advogado"> | Date | string
    nome?: StringFilter<"Advogado"> | string
    cpf?: StringNullableFilter<"Advogado"> | string | null
    email?: StringNullableFilter<"Advogado"> | string | null
    telefone?: StringNullableFilter<"Advogado"> | string | null
    tipo?: EnumTipoAdvogadoFilter<"Advogado"> | $Enums.TipoAdvogado
    possuiFixoMensal?: BoolFilter<"Advogado"> | boolean
    valorFixoMensal?: DecimalNullableFilter<"Advogado"> | Decimal | DecimalJsLike | number | string | null
    ativo?: BoolFilter<"Advogado"> | boolean
    repasses?: RepasseListRelationFilter
  }, "id">

  export type AdvogadoOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nome?: SortOrder
    cpf?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    telefone?: SortOrderInput | SortOrder
    tipo?: SortOrder
    possuiFixoMensal?: SortOrder
    valorFixoMensal?: SortOrderInput | SortOrder
    ativo?: SortOrder
    _count?: AdvogadoCountOrderByAggregateInput
    _avg?: AdvogadoAvgOrderByAggregateInput
    _max?: AdvogadoMaxOrderByAggregateInput
    _min?: AdvogadoMinOrderByAggregateInput
    _sum?: AdvogadoSumOrderByAggregateInput
  }

  export type AdvogadoScalarWhereWithAggregatesInput = {
    AND?: AdvogadoScalarWhereWithAggregatesInput | AdvogadoScalarWhereWithAggregatesInput[]
    OR?: AdvogadoScalarWhereWithAggregatesInput[]
    NOT?: AdvogadoScalarWhereWithAggregatesInput | AdvogadoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Advogado"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Advogado"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Advogado"> | Date | string
    nome?: StringWithAggregatesFilter<"Advogado"> | string
    cpf?: StringNullableWithAggregatesFilter<"Advogado"> | string | null
    email?: StringNullableWithAggregatesFilter<"Advogado"> | string | null
    telefone?: StringNullableWithAggregatesFilter<"Advogado"> | string | null
    tipo?: EnumTipoAdvogadoWithAggregatesFilter<"Advogado"> | $Enums.TipoAdvogado
    possuiFixoMensal?: BoolWithAggregatesFilter<"Advogado"> | boolean
    valorFixoMensal?: DecimalNullableWithAggregatesFilter<"Advogado"> | Decimal | DecimalJsLike | number | string | null
    ativo?: BoolWithAggregatesFilter<"Advogado"> | boolean
  }

  export type RepasseWhereInput = {
    AND?: RepasseWhereInput | RepasseWhereInput[]
    OR?: RepasseWhereInput[]
    NOT?: RepasseWhereInput | RepasseWhereInput[]
    id?: IntFilter<"Repasse"> | number
    createdAt?: DateTimeFilter<"Repasse"> | Date | string
    updatedAt?: DateTimeFilter<"Repasse"> | Date | string
    advogadoId?: IntFilter<"Repasse"> | number
    ordemPagamentoId?: IntNullableFilter<"Repasse"> | number | null
    referenciaCompetencia?: StringFilter<"Repasse"> | string
    valorDevido?: DecimalFilter<"Repasse"> | Decimal | DecimalJsLike | number | string
    valorPago?: DecimalNullableFilter<"Repasse"> | Decimal | DecimalJsLike | number | string | null
    dataPagamento?: DateTimeNullableFilter<"Repasse"> | Date | string | null
    saldoAReceber?: DecimalNullableFilter<"Repasse"> | Decimal | DecimalJsLike | number | string | null
    origem?: EnumOrigemRepasseFilter<"Repasse"> | $Enums.OrigemRepasse
    modeloDistribuicaoCodigo?: StringNullableFilter<"Repasse"> | string | null
    observacoes?: StringNullableFilter<"Repasse"> | string | null
    advogado?: XOR<AdvogadoRelationFilter, AdvogadoWhereInput>
    ordemPagamento?: XOR<OrdemPagamentoNullableRelationFilter, OrdemPagamentoWhereInput> | null
  }

  export type RepasseOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    advogadoId?: SortOrder
    ordemPagamentoId?: SortOrderInput | SortOrder
    referenciaCompetencia?: SortOrder
    valorDevido?: SortOrder
    valorPago?: SortOrderInput | SortOrder
    dataPagamento?: SortOrderInput | SortOrder
    saldoAReceber?: SortOrderInput | SortOrder
    origem?: SortOrder
    modeloDistribuicaoCodigo?: SortOrderInput | SortOrder
    observacoes?: SortOrderInput | SortOrder
    advogado?: AdvogadoOrderByWithRelationInput
    ordemPagamento?: OrdemPagamentoOrderByWithRelationInput
  }

  export type RepasseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RepasseWhereInput | RepasseWhereInput[]
    OR?: RepasseWhereInput[]
    NOT?: RepasseWhereInput | RepasseWhereInput[]
    createdAt?: DateTimeFilter<"Repasse"> | Date | string
    updatedAt?: DateTimeFilter<"Repasse"> | Date | string
    advogadoId?: IntFilter<"Repasse"> | number
    ordemPagamentoId?: IntNullableFilter<"Repasse"> | number | null
    referenciaCompetencia?: StringFilter<"Repasse"> | string
    valorDevido?: DecimalFilter<"Repasse"> | Decimal | DecimalJsLike | number | string
    valorPago?: DecimalNullableFilter<"Repasse"> | Decimal | DecimalJsLike | number | string | null
    dataPagamento?: DateTimeNullableFilter<"Repasse"> | Date | string | null
    saldoAReceber?: DecimalNullableFilter<"Repasse"> | Decimal | DecimalJsLike | number | string | null
    origem?: EnumOrigemRepasseFilter<"Repasse"> | $Enums.OrigemRepasse
    modeloDistribuicaoCodigo?: StringNullableFilter<"Repasse"> | string | null
    observacoes?: StringNullableFilter<"Repasse"> | string | null
    advogado?: XOR<AdvogadoRelationFilter, AdvogadoWhereInput>
    ordemPagamento?: XOR<OrdemPagamentoNullableRelationFilter, OrdemPagamentoWhereInput> | null
  }, "id">

  export type RepasseOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    advogadoId?: SortOrder
    ordemPagamentoId?: SortOrderInput | SortOrder
    referenciaCompetencia?: SortOrder
    valorDevido?: SortOrder
    valorPago?: SortOrderInput | SortOrder
    dataPagamento?: SortOrderInput | SortOrder
    saldoAReceber?: SortOrderInput | SortOrder
    origem?: SortOrder
    modeloDistribuicaoCodigo?: SortOrderInput | SortOrder
    observacoes?: SortOrderInput | SortOrder
    _count?: RepasseCountOrderByAggregateInput
    _avg?: RepasseAvgOrderByAggregateInput
    _max?: RepasseMaxOrderByAggregateInput
    _min?: RepasseMinOrderByAggregateInput
    _sum?: RepasseSumOrderByAggregateInput
  }

  export type RepasseScalarWhereWithAggregatesInput = {
    AND?: RepasseScalarWhereWithAggregatesInput | RepasseScalarWhereWithAggregatesInput[]
    OR?: RepasseScalarWhereWithAggregatesInput[]
    NOT?: RepasseScalarWhereWithAggregatesInput | RepasseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Repasse"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Repasse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Repasse"> | Date | string
    advogadoId?: IntWithAggregatesFilter<"Repasse"> | number
    ordemPagamentoId?: IntNullableWithAggregatesFilter<"Repasse"> | number | null
    referenciaCompetencia?: StringWithAggregatesFilter<"Repasse"> | string
    valorDevido?: DecimalWithAggregatesFilter<"Repasse"> | Decimal | DecimalJsLike | number | string
    valorPago?: DecimalNullableWithAggregatesFilter<"Repasse"> | Decimal | DecimalJsLike | number | string | null
    dataPagamento?: DateTimeNullableWithAggregatesFilter<"Repasse"> | Date | string | null
    saldoAReceber?: DecimalNullableWithAggregatesFilter<"Repasse"> | Decimal | DecimalJsLike | number | string | null
    origem?: EnumOrigemRepasseWithAggregatesFilter<"Repasse"> | $Enums.OrigemRepasse
    modeloDistribuicaoCodigo?: StringNullableWithAggregatesFilter<"Repasse"> | string | null
    observacoes?: StringNullableWithAggregatesFilter<"Repasse"> | string | null
  }

  export type EstagiarioWhereInput = {
    AND?: EstagiarioWhereInput | EstagiarioWhereInput[]
    OR?: EstagiarioWhereInput[]
    NOT?: EstagiarioWhereInput | EstagiarioWhereInput[]
    id?: IntFilter<"Estagiario"> | number
    createdAt?: DateTimeFilter<"Estagiario"> | Date | string
    updatedAt?: DateTimeFilter<"Estagiario"> | Date | string
    nome?: StringFilter<"Estagiario"> | string
    cpf?: StringNullableFilter<"Estagiario"> | string | null
    email?: StringNullableFilter<"Estagiario"> | string | null
    telefone?: StringNullableFilter<"Estagiario"> | string | null
    auxilioTransporteValor?: DecimalNullableFilter<"Estagiario"> | Decimal | DecimalJsLike | number | string | null
    auxilioEstagioValor?: DecimalNullableFilter<"Estagiario"> | Decimal | DecimalJsLike | number | string | null
    ativo?: BoolFilter<"Estagiario"> | boolean
  }

  export type EstagiarioOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nome?: SortOrder
    cpf?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    telefone?: SortOrderInput | SortOrder
    auxilioTransporteValor?: SortOrderInput | SortOrder
    auxilioEstagioValor?: SortOrderInput | SortOrder
    ativo?: SortOrder
  }

  export type EstagiarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EstagiarioWhereInput | EstagiarioWhereInput[]
    OR?: EstagiarioWhereInput[]
    NOT?: EstagiarioWhereInput | EstagiarioWhereInput[]
    createdAt?: DateTimeFilter<"Estagiario"> | Date | string
    updatedAt?: DateTimeFilter<"Estagiario"> | Date | string
    nome?: StringFilter<"Estagiario"> | string
    cpf?: StringNullableFilter<"Estagiario"> | string | null
    email?: StringNullableFilter<"Estagiario"> | string | null
    telefone?: StringNullableFilter<"Estagiario"> | string | null
    auxilioTransporteValor?: DecimalNullableFilter<"Estagiario"> | Decimal | DecimalJsLike | number | string | null
    auxilioEstagioValor?: DecimalNullableFilter<"Estagiario"> | Decimal | DecimalJsLike | number | string | null
    ativo?: BoolFilter<"Estagiario"> | boolean
  }, "id">

  export type EstagiarioOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nome?: SortOrder
    cpf?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    telefone?: SortOrderInput | SortOrder
    auxilioTransporteValor?: SortOrderInput | SortOrder
    auxilioEstagioValor?: SortOrderInput | SortOrder
    ativo?: SortOrder
    _count?: EstagiarioCountOrderByAggregateInput
    _avg?: EstagiarioAvgOrderByAggregateInput
    _max?: EstagiarioMaxOrderByAggregateInput
    _min?: EstagiarioMinOrderByAggregateInput
    _sum?: EstagiarioSumOrderByAggregateInput
  }

  export type EstagiarioScalarWhereWithAggregatesInput = {
    AND?: EstagiarioScalarWhereWithAggregatesInput | EstagiarioScalarWhereWithAggregatesInput[]
    OR?: EstagiarioScalarWhereWithAggregatesInput[]
    NOT?: EstagiarioScalarWhereWithAggregatesInput | EstagiarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Estagiario"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Estagiario"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Estagiario"> | Date | string
    nome?: StringWithAggregatesFilter<"Estagiario"> | string
    cpf?: StringNullableWithAggregatesFilter<"Estagiario"> | string | null
    email?: StringNullableWithAggregatesFilter<"Estagiario"> | string | null
    telefone?: StringNullableWithAggregatesFilter<"Estagiario"> | string | null
    auxilioTransporteValor?: DecimalNullableWithAggregatesFilter<"Estagiario"> | Decimal | DecimalJsLike | number | string | null
    auxilioEstagioValor?: DecimalNullableWithAggregatesFilter<"Estagiario"> | Decimal | DecimalJsLike | number | string | null
    ativo?: BoolWithAggregatesFilter<"Estagiario"> | boolean
  }

  export type PrestadorServicoWhereInput = {
    AND?: PrestadorServicoWhereInput | PrestadorServicoWhereInput[]
    OR?: PrestadorServicoWhereInput[]
    NOT?: PrestadorServicoWhereInput | PrestadorServicoWhereInput[]
    id?: IntFilter<"PrestadorServico"> | number
    createdAt?: DateTimeFilter<"PrestadorServico"> | Date | string
    updatedAt?: DateTimeFilter<"PrestadorServico"> | Date | string
    nomeRazaoSocial?: StringFilter<"PrestadorServico"> | string
    cpfCnpj?: StringNullableFilter<"PrestadorServico"> | string | null
    tipo?: StringFilter<"PrestadorServico"> | string
    valorRecorrente?: DecimalNullableFilter<"PrestadorServico"> | Decimal | DecimalJsLike | number | string | null
    observacoes?: StringNullableFilter<"PrestadorServico"> | string | null
    ativo?: BoolFilter<"PrestadorServico"> | boolean
  }

  export type PrestadorServicoOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nomeRazaoSocial?: SortOrder
    cpfCnpj?: SortOrderInput | SortOrder
    tipo?: SortOrder
    valorRecorrente?: SortOrderInput | SortOrder
    observacoes?: SortOrderInput | SortOrder
    ativo?: SortOrder
  }

  export type PrestadorServicoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PrestadorServicoWhereInput | PrestadorServicoWhereInput[]
    OR?: PrestadorServicoWhereInput[]
    NOT?: PrestadorServicoWhereInput | PrestadorServicoWhereInput[]
    createdAt?: DateTimeFilter<"PrestadorServico"> | Date | string
    updatedAt?: DateTimeFilter<"PrestadorServico"> | Date | string
    nomeRazaoSocial?: StringFilter<"PrestadorServico"> | string
    cpfCnpj?: StringNullableFilter<"PrestadorServico"> | string | null
    tipo?: StringFilter<"PrestadorServico"> | string
    valorRecorrente?: DecimalNullableFilter<"PrestadorServico"> | Decimal | DecimalJsLike | number | string | null
    observacoes?: StringNullableFilter<"PrestadorServico"> | string | null
    ativo?: BoolFilter<"PrestadorServico"> | boolean
  }, "id">

  export type PrestadorServicoOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nomeRazaoSocial?: SortOrder
    cpfCnpj?: SortOrderInput | SortOrder
    tipo?: SortOrder
    valorRecorrente?: SortOrderInput | SortOrder
    observacoes?: SortOrderInput | SortOrder
    ativo?: SortOrder
    _count?: PrestadorServicoCountOrderByAggregateInput
    _avg?: PrestadorServicoAvgOrderByAggregateInput
    _max?: PrestadorServicoMaxOrderByAggregateInput
    _min?: PrestadorServicoMinOrderByAggregateInput
    _sum?: PrestadorServicoSumOrderByAggregateInput
  }

  export type PrestadorServicoScalarWhereWithAggregatesInput = {
    AND?: PrestadorServicoScalarWhereWithAggregatesInput | PrestadorServicoScalarWhereWithAggregatesInput[]
    OR?: PrestadorServicoScalarWhereWithAggregatesInput[]
    NOT?: PrestadorServicoScalarWhereWithAggregatesInput | PrestadorServicoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PrestadorServico"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PrestadorServico"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PrestadorServico"> | Date | string
    nomeRazaoSocial?: StringWithAggregatesFilter<"PrestadorServico"> | string
    cpfCnpj?: StringNullableWithAggregatesFilter<"PrestadorServico"> | string | null
    tipo?: StringWithAggregatesFilter<"PrestadorServico"> | string
    valorRecorrente?: DecimalNullableWithAggregatesFilter<"PrestadorServico"> | Decimal | DecimalJsLike | number | string | null
    observacoes?: StringNullableWithAggregatesFilter<"PrestadorServico"> | string | null
    ativo?: BoolWithAggregatesFilter<"PrestadorServico"> | boolean
  }

  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id?: IntFilter<"Usuario"> | number
    createdAt?: DateTimeFilter<"Usuario"> | Date | string
    updatedAt?: DateTimeFilter<"Usuario"> | Date | string
    nome?: StringFilter<"Usuario"> | string
    email?: StringFilter<"Usuario"> | string
    senhaHash?: StringFilter<"Usuario"> | string
    perfil?: EnumPerfilUsuarioFilter<"Usuario"> | $Enums.PerfilUsuario
    ativo?: BoolFilter<"Usuario"> | boolean
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senhaHash?: SortOrder
    perfil?: SortOrder
    ativo?: SortOrder
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    createdAt?: DateTimeFilter<"Usuario"> | Date | string
    updatedAt?: DateTimeFilter<"Usuario"> | Date | string
    nome?: StringFilter<"Usuario"> | string
    senhaHash?: StringFilter<"Usuario"> | string
    perfil?: EnumPerfilUsuarioFilter<"Usuario"> | $Enums.PerfilUsuario
    ativo?: BoolFilter<"Usuario"> | boolean
  }, "id" | "email">

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senhaHash?: SortOrder
    perfil?: SortOrder
    ativo?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Usuario"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
    nome?: StringWithAggregatesFilter<"Usuario"> | string
    email?: StringWithAggregatesFilter<"Usuario"> | string
    senhaHash?: StringWithAggregatesFilter<"Usuario"> | string
    perfil?: EnumPerfilUsuarioWithAggregatesFilter<"Usuario"> | $Enums.PerfilUsuario
    ativo?: BoolWithAggregatesFilter<"Usuario"> | boolean
  }

  export type ConfiguracaoCalculoWhereInput = {
    AND?: ConfiguracaoCalculoWhereInput | ConfiguracaoCalculoWhereInput[]
    OR?: ConfiguracaoCalculoWhereInput[]
    NOT?: ConfiguracaoCalculoWhereInput | ConfiguracaoCalculoWhereInput[]
    id?: IntFilter<"ConfiguracaoCalculo"> | number
    createdAt?: DateTimeFilter<"ConfiguracaoCalculo"> | Date | string
    updatedAt?: DateTimeFilter<"ConfiguracaoCalculo"> | Date | string
    codigoModelo?: StringFilter<"ConfiguracaoCalculo"> | string
    descricao?: StringNullableFilter<"ConfiguracaoCalculo"> | string | null
    percentualAdvogado?: DecimalFilter<"ConfiguracaoCalculo"> | Decimal | DecimalJsLike | number | string
    percentualSocio?: DecimalFilter<"ConfiguracaoCalculo"> | Decimal | DecimalJsLike | number | string
    percentualFundoReserva?: DecimalFilter<"ConfiguracaoCalculo"> | Decimal | DecimalJsLike | number | string
    percentualEscritorio?: DecimalFilter<"ConfiguracaoCalculo"> | Decimal | DecimalJsLike | number | string
    vigenciaInicio?: DateTimeFilter<"ConfiguracaoCalculo"> | Date | string
    vigenciaFim?: DateTimeNullableFilter<"ConfiguracaoCalculo"> | Date | string | null
    ativo?: BoolFilter<"ConfiguracaoCalculo"> | boolean
  }

  export type ConfiguracaoCalculoOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    codigoModelo?: SortOrder
    descricao?: SortOrderInput | SortOrder
    percentualAdvogado?: SortOrder
    percentualSocio?: SortOrder
    percentualFundoReserva?: SortOrder
    percentualEscritorio?: SortOrder
    vigenciaInicio?: SortOrder
    vigenciaFim?: SortOrderInput | SortOrder
    ativo?: SortOrder
  }

  export type ConfiguracaoCalculoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    codigoModelo?: string
    AND?: ConfiguracaoCalculoWhereInput | ConfiguracaoCalculoWhereInput[]
    OR?: ConfiguracaoCalculoWhereInput[]
    NOT?: ConfiguracaoCalculoWhereInput | ConfiguracaoCalculoWhereInput[]
    createdAt?: DateTimeFilter<"ConfiguracaoCalculo"> | Date | string
    updatedAt?: DateTimeFilter<"ConfiguracaoCalculo"> | Date | string
    descricao?: StringNullableFilter<"ConfiguracaoCalculo"> | string | null
    percentualAdvogado?: DecimalFilter<"ConfiguracaoCalculo"> | Decimal | DecimalJsLike | number | string
    percentualSocio?: DecimalFilter<"ConfiguracaoCalculo"> | Decimal | DecimalJsLike | number | string
    percentualFundoReserva?: DecimalFilter<"ConfiguracaoCalculo"> | Decimal | DecimalJsLike | number | string
    percentualEscritorio?: DecimalFilter<"ConfiguracaoCalculo"> | Decimal | DecimalJsLike | number | string
    vigenciaInicio?: DateTimeFilter<"ConfiguracaoCalculo"> | Date | string
    vigenciaFim?: DateTimeNullableFilter<"ConfiguracaoCalculo"> | Date | string | null
    ativo?: BoolFilter<"ConfiguracaoCalculo"> | boolean
  }, "id" | "codigoModelo">

  export type ConfiguracaoCalculoOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    codigoModelo?: SortOrder
    descricao?: SortOrderInput | SortOrder
    percentualAdvogado?: SortOrder
    percentualSocio?: SortOrder
    percentualFundoReserva?: SortOrder
    percentualEscritorio?: SortOrder
    vigenciaInicio?: SortOrder
    vigenciaFim?: SortOrderInput | SortOrder
    ativo?: SortOrder
    _count?: ConfiguracaoCalculoCountOrderByAggregateInput
    _avg?: ConfiguracaoCalculoAvgOrderByAggregateInput
    _max?: ConfiguracaoCalculoMaxOrderByAggregateInput
    _min?: ConfiguracaoCalculoMinOrderByAggregateInput
    _sum?: ConfiguracaoCalculoSumOrderByAggregateInput
  }

  export type ConfiguracaoCalculoScalarWhereWithAggregatesInput = {
    AND?: ConfiguracaoCalculoScalarWhereWithAggregatesInput | ConfiguracaoCalculoScalarWhereWithAggregatesInput[]
    OR?: ConfiguracaoCalculoScalarWhereWithAggregatesInput[]
    NOT?: ConfiguracaoCalculoScalarWhereWithAggregatesInput | ConfiguracaoCalculoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ConfiguracaoCalculo"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ConfiguracaoCalculo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConfiguracaoCalculo"> | Date | string
    codigoModelo?: StringWithAggregatesFilter<"ConfiguracaoCalculo"> | string
    descricao?: StringNullableWithAggregatesFilter<"ConfiguracaoCalculo"> | string | null
    percentualAdvogado?: DecimalWithAggregatesFilter<"ConfiguracaoCalculo"> | Decimal | DecimalJsLike | number | string
    percentualSocio?: DecimalWithAggregatesFilter<"ConfiguracaoCalculo"> | Decimal | DecimalJsLike | number | string
    percentualFundoReserva?: DecimalWithAggregatesFilter<"ConfiguracaoCalculo"> | Decimal | DecimalJsLike | number | string
    percentualEscritorio?: DecimalWithAggregatesFilter<"ConfiguracaoCalculo"> | Decimal | DecimalJsLike | number | string
    vigenciaInicio?: DateTimeWithAggregatesFilter<"ConfiguracaoCalculo"> | Date | string
    vigenciaFim?: DateTimeNullableWithAggregatesFilter<"ConfiguracaoCalculo"> | Date | string | null
    ativo?: BoolWithAggregatesFilter<"ConfiguracaoCalculo"> | boolean
  }

  export type ModeloDistribuicaoWhereInput = {
    AND?: ModeloDistribuicaoWhereInput | ModeloDistribuicaoWhereInput[]
    OR?: ModeloDistribuicaoWhereInput[]
    NOT?: ModeloDistribuicaoWhereInput | ModeloDistribuicaoWhereInput[]
    id?: IntFilter<"ModeloDistribuicao"> | number
    createdAt?: DateTimeFilter<"ModeloDistribuicao"> | Date | string
    updatedAt?: DateTimeFilter<"ModeloDistribuicao"> | Date | string
    codigo?: StringFilter<"ModeloDistribuicao"> | string
    origem?: StringFilter<"ModeloDistribuicao"> | string
    tipo?: StringFilter<"ModeloDistribuicao"> | string
    percentual?: DecimalFilter<"ModeloDistribuicao"> | Decimal | DecimalJsLike | number | string
    destinatario?: StringFilter<"ModeloDistribuicao"> | string
  }

  export type ModeloDistribuicaoOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    codigo?: SortOrder
    origem?: SortOrder
    tipo?: SortOrder
    percentual?: SortOrder
    destinatario?: SortOrder
  }

  export type ModeloDistribuicaoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ModeloDistribuicaoWhereInput | ModeloDistribuicaoWhereInput[]
    OR?: ModeloDistribuicaoWhereInput[]
    NOT?: ModeloDistribuicaoWhereInput | ModeloDistribuicaoWhereInput[]
    createdAt?: DateTimeFilter<"ModeloDistribuicao"> | Date | string
    updatedAt?: DateTimeFilter<"ModeloDistribuicao"> | Date | string
    codigo?: StringFilter<"ModeloDistribuicao"> | string
    origem?: StringFilter<"ModeloDistribuicao"> | string
    tipo?: StringFilter<"ModeloDistribuicao"> | string
    percentual?: DecimalFilter<"ModeloDistribuicao"> | Decimal | DecimalJsLike | number | string
    destinatario?: StringFilter<"ModeloDistribuicao"> | string
  }, "id">

  export type ModeloDistribuicaoOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    codigo?: SortOrder
    origem?: SortOrder
    tipo?: SortOrder
    percentual?: SortOrder
    destinatario?: SortOrder
    _count?: ModeloDistribuicaoCountOrderByAggregateInput
    _avg?: ModeloDistribuicaoAvgOrderByAggregateInput
    _max?: ModeloDistribuicaoMaxOrderByAggregateInput
    _min?: ModeloDistribuicaoMinOrderByAggregateInput
    _sum?: ModeloDistribuicaoSumOrderByAggregateInput
  }

  export type ModeloDistribuicaoScalarWhereWithAggregatesInput = {
    AND?: ModeloDistribuicaoScalarWhereWithAggregatesInput | ModeloDistribuicaoScalarWhereWithAggregatesInput[]
    OR?: ModeloDistribuicaoScalarWhereWithAggregatesInput[]
    NOT?: ModeloDistribuicaoScalarWhereWithAggregatesInput | ModeloDistribuicaoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ModeloDistribuicao"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ModeloDistribuicao"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ModeloDistribuicao"> | Date | string
    codigo?: StringWithAggregatesFilter<"ModeloDistribuicao"> | string
    origem?: StringWithAggregatesFilter<"ModeloDistribuicao"> | string
    tipo?: StringWithAggregatesFilter<"ModeloDistribuicao"> | string
    percentual?: DecimalWithAggregatesFilter<"ModeloDistribuicao"> | Decimal | DecimalJsLike | number | string
    destinatario?: StringWithAggregatesFilter<"ModeloDistribuicao"> | string
  }

  export type ClienteCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    cpfCnpj: string
    nomeRazaoSocial: string
    email?: string | null
    telefone?: string | null
    observacoes?: string | null
    ativo?: boolean
    ordens?: OrdemPagamentoCreateNestedManyWithoutClienteInput
  }

  export type ClienteUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cpfCnpj: string
    nomeRazaoSocial: string
    email?: string | null
    telefone?: string | null
    observacoes?: string | null
    ativo?: boolean
    ordens?: OrdemPagamentoUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClienteUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpfCnpj?: StringFieldUpdateOperationsInput | string
    nomeRazaoSocial?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    ordens?: OrdemPagamentoUpdateManyWithoutClienteNestedInput
  }

  export type ClienteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpfCnpj?: StringFieldUpdateOperationsInput | string
    nomeRazaoSocial?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    ordens?: OrdemPagamentoUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type ClienteCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cpfCnpj: string
    nomeRazaoSocial: string
    email?: string | null
    telefone?: string | null
    observacoes?: string | null
    ativo?: boolean
  }

  export type ClienteUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpfCnpj?: StringFieldUpdateOperationsInput | string
    nomeRazaoSocial?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClienteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpfCnpj?: StringFieldUpdateOperationsInput | string
    nomeRazaoSocial?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrdemPagamentoCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    sequenciaCliente: number
    codigoInterno?: string | null
    descricao?: string | null
    tipoContrato?: string | null
    valorTotalPrevisto?: Decimal | DecimalJsLike | number | string | null
    modeloPagamento: $Enums.ModeloPagamento
    dataInicio: Date | string
    dataFimPrevista?: Date | string | null
    status: $Enums.StatusOrdem
    cliente: ClienteCreateNestedOneWithoutOrdensInput
    pagamentos?: PagamentoCreateNestedManyWithoutOrdemPagamentoInput
    repasses?: RepasseCreateNestedManyWithoutOrdemPagamentoInput
  }

  export type OrdemPagamentoUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clienteId: number
    sequenciaCliente: number
    codigoInterno?: string | null
    descricao?: string | null
    tipoContrato?: string | null
    valorTotalPrevisto?: Decimal | DecimalJsLike | number | string | null
    modeloPagamento: $Enums.ModeloPagamento
    dataInicio: Date | string
    dataFimPrevista?: Date | string | null
    status: $Enums.StatusOrdem
    pagamentos?: PagamentoUncheckedCreateNestedManyWithoutOrdemPagamentoInput
    repasses?: RepasseUncheckedCreateNestedManyWithoutOrdemPagamentoInput
  }

  export type OrdemPagamentoUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sequenciaCliente?: IntFieldUpdateOperationsInput | number
    codigoInterno?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    tipoContrato?: NullableStringFieldUpdateOperationsInput | string | null
    valorTotalPrevisto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    modeloPagamento?: EnumModeloPagamentoFieldUpdateOperationsInput | $Enums.ModeloPagamento
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFimPrevista?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusOrdemFieldUpdateOperationsInput | $Enums.StatusOrdem
    cliente?: ClienteUpdateOneRequiredWithoutOrdensNestedInput
    pagamentos?: PagamentoUpdateManyWithoutOrdemPagamentoNestedInput
    repasses?: RepasseUpdateManyWithoutOrdemPagamentoNestedInput
  }

  export type OrdemPagamentoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clienteId?: IntFieldUpdateOperationsInput | number
    sequenciaCliente?: IntFieldUpdateOperationsInput | number
    codigoInterno?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    tipoContrato?: NullableStringFieldUpdateOperationsInput | string | null
    valorTotalPrevisto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    modeloPagamento?: EnumModeloPagamentoFieldUpdateOperationsInput | $Enums.ModeloPagamento
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFimPrevista?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusOrdemFieldUpdateOperationsInput | $Enums.StatusOrdem
    pagamentos?: PagamentoUncheckedUpdateManyWithoutOrdemPagamentoNestedInput
    repasses?: RepasseUncheckedUpdateManyWithoutOrdemPagamentoNestedInput
  }

  export type OrdemPagamentoCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clienteId: number
    sequenciaCliente: number
    codigoInterno?: string | null
    descricao?: string | null
    tipoContrato?: string | null
    valorTotalPrevisto?: Decimal | DecimalJsLike | number | string | null
    modeloPagamento: $Enums.ModeloPagamento
    dataInicio: Date | string
    dataFimPrevista?: Date | string | null
    status: $Enums.StatusOrdem
  }

  export type OrdemPagamentoUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sequenciaCliente?: IntFieldUpdateOperationsInput | number
    codigoInterno?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    tipoContrato?: NullableStringFieldUpdateOperationsInput | string | null
    valorTotalPrevisto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    modeloPagamento?: EnumModeloPagamentoFieldUpdateOperationsInput | $Enums.ModeloPagamento
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFimPrevista?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusOrdemFieldUpdateOperationsInput | $Enums.StatusOrdem
  }

  export type OrdemPagamentoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clienteId?: IntFieldUpdateOperationsInput | number
    sequenciaCliente?: IntFieldUpdateOperationsInput | number
    codigoInterno?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    tipoContrato?: NullableStringFieldUpdateOperationsInput | string | null
    valorTotalPrevisto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    modeloPagamento?: EnumModeloPagamentoFieldUpdateOperationsInput | $Enums.ModeloPagamento
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFimPrevista?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusOrdemFieldUpdateOperationsInput | $Enums.StatusOrdem
  }

  export type PagamentoCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    numeroParcela: number
    dataPrevista: Date | string
    dataEfetiva?: Date | string | null
    valorPrevisto: Decimal | DecimalJsLike | number | string
    valorPago?: Decimal | DecimalJsLike | number | string | null
    formaPagamento?: string | null
    status: $Enums.StatusPagamento
    observacoes?: string | null
    ordemPagamento: OrdemPagamentoCreateNestedOneWithoutPagamentosInput
  }

  export type PagamentoUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ordemPagamentoId: number
    numeroParcela: number
    dataPrevista: Date | string
    dataEfetiva?: Date | string | null
    valorPrevisto: Decimal | DecimalJsLike | number | string
    valorPago?: Decimal | DecimalJsLike | number | string | null
    formaPagamento?: string | null
    status: $Enums.StatusPagamento
    observacoes?: string | null
  }

  export type PagamentoUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroParcela?: IntFieldUpdateOperationsInput | number
    dataPrevista?: DateTimeFieldUpdateOperationsInput | Date | string
    dataEfetiva?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valorPrevisto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorPago?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    formaPagamento?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusPagamentoFieldUpdateOperationsInput | $Enums.StatusPagamento
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    ordemPagamento?: OrdemPagamentoUpdateOneRequiredWithoutPagamentosNestedInput
  }

  export type PagamentoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordemPagamentoId?: IntFieldUpdateOperationsInput | number
    numeroParcela?: IntFieldUpdateOperationsInput | number
    dataPrevista?: DateTimeFieldUpdateOperationsInput | Date | string
    dataEfetiva?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valorPrevisto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorPago?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    formaPagamento?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusPagamentoFieldUpdateOperationsInput | $Enums.StatusPagamento
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PagamentoCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ordemPagamentoId: number
    numeroParcela: number
    dataPrevista: Date | string
    dataEfetiva?: Date | string | null
    valorPrevisto: Decimal | DecimalJsLike | number | string
    valorPago?: Decimal | DecimalJsLike | number | string | null
    formaPagamento?: string | null
    status: $Enums.StatusPagamento
    observacoes?: string | null
  }

  export type PagamentoUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroParcela?: IntFieldUpdateOperationsInput | number
    dataPrevista?: DateTimeFieldUpdateOperationsInput | Date | string
    dataEfetiva?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valorPrevisto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorPago?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    formaPagamento?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusPagamentoFieldUpdateOperationsInput | $Enums.StatusPagamento
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PagamentoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordemPagamentoId?: IntFieldUpdateOperationsInput | number
    numeroParcela?: IntFieldUpdateOperationsInput | number
    dataPrevista?: DateTimeFieldUpdateOperationsInput | Date | string
    dataEfetiva?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valorPrevisto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorPago?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    formaPagamento?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusPagamentoFieldUpdateOperationsInput | $Enums.StatusPagamento
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdvogadoCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nome: string
    cpf?: string | null
    email?: string | null
    telefone?: string | null
    tipo: $Enums.TipoAdvogado
    possuiFixoMensal?: boolean
    valorFixoMensal?: Decimal | DecimalJsLike | number | string | null
    ativo?: boolean
    repasses?: RepasseCreateNestedManyWithoutAdvogadoInput
  }

  export type AdvogadoUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nome: string
    cpf?: string | null
    email?: string | null
    telefone?: string | null
    tipo: $Enums.TipoAdvogado
    possuiFixoMensal?: boolean
    valorFixoMensal?: Decimal | DecimalJsLike | number | string | null
    ativo?: boolean
    repasses?: RepasseUncheckedCreateNestedManyWithoutAdvogadoInput
  }

  export type AdvogadoUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nome?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoAdvogadoFieldUpdateOperationsInput | $Enums.TipoAdvogado
    possuiFixoMensal?: BoolFieldUpdateOperationsInput | boolean
    valorFixoMensal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    repasses?: RepasseUpdateManyWithoutAdvogadoNestedInput
  }

  export type AdvogadoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nome?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoAdvogadoFieldUpdateOperationsInput | $Enums.TipoAdvogado
    possuiFixoMensal?: BoolFieldUpdateOperationsInput | boolean
    valorFixoMensal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    repasses?: RepasseUncheckedUpdateManyWithoutAdvogadoNestedInput
  }

  export type AdvogadoCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nome: string
    cpf?: string | null
    email?: string | null
    telefone?: string | null
    tipo: $Enums.TipoAdvogado
    possuiFixoMensal?: boolean
    valorFixoMensal?: Decimal | DecimalJsLike | number | string | null
    ativo?: boolean
  }

  export type AdvogadoUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nome?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoAdvogadoFieldUpdateOperationsInput | $Enums.TipoAdvogado
    possuiFixoMensal?: BoolFieldUpdateOperationsInput | boolean
    valorFixoMensal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdvogadoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nome?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoAdvogadoFieldUpdateOperationsInput | $Enums.TipoAdvogado
    possuiFixoMensal?: BoolFieldUpdateOperationsInput | boolean
    valorFixoMensal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RepasseCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    referenciaCompetencia: string
    valorDevido: Decimal | DecimalJsLike | number | string
    valorPago?: Decimal | DecimalJsLike | number | string | null
    dataPagamento?: Date | string | null
    saldoAReceber?: Decimal | DecimalJsLike | number | string | null
    origem: $Enums.OrigemRepasse
    modeloDistribuicaoCodigo?: string | null
    observacoes?: string | null
    advogado: AdvogadoCreateNestedOneWithoutRepassesInput
    ordemPagamento?: OrdemPagamentoCreateNestedOneWithoutRepassesInput
  }

  export type RepasseUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    advogadoId: number
    ordemPagamentoId?: number | null
    referenciaCompetencia: string
    valorDevido: Decimal | DecimalJsLike | number | string
    valorPago?: Decimal | DecimalJsLike | number | string | null
    dataPagamento?: Date | string | null
    saldoAReceber?: Decimal | DecimalJsLike | number | string | null
    origem: $Enums.OrigemRepasse
    modeloDistribuicaoCodigo?: string | null
    observacoes?: string | null
  }

  export type RepasseUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenciaCompetencia?: StringFieldUpdateOperationsInput | string
    valorDevido?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorPago?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dataPagamento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saldoAReceber?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    origem?: EnumOrigemRepasseFieldUpdateOperationsInput | $Enums.OrigemRepasse
    modeloDistribuicaoCodigo?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    advogado?: AdvogadoUpdateOneRequiredWithoutRepassesNestedInput
    ordemPagamento?: OrdemPagamentoUpdateOneWithoutRepassesNestedInput
  }

  export type RepasseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    advogadoId?: IntFieldUpdateOperationsInput | number
    ordemPagamentoId?: NullableIntFieldUpdateOperationsInput | number | null
    referenciaCompetencia?: StringFieldUpdateOperationsInput | string
    valorDevido?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorPago?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dataPagamento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saldoAReceber?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    origem?: EnumOrigemRepasseFieldUpdateOperationsInput | $Enums.OrigemRepasse
    modeloDistribuicaoCodigo?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RepasseCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    advogadoId: number
    ordemPagamentoId?: number | null
    referenciaCompetencia: string
    valorDevido: Decimal | DecimalJsLike | number | string
    valorPago?: Decimal | DecimalJsLike | number | string | null
    dataPagamento?: Date | string | null
    saldoAReceber?: Decimal | DecimalJsLike | number | string | null
    origem: $Enums.OrigemRepasse
    modeloDistribuicaoCodigo?: string | null
    observacoes?: string | null
  }

  export type RepasseUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenciaCompetencia?: StringFieldUpdateOperationsInput | string
    valorDevido?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorPago?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dataPagamento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saldoAReceber?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    origem?: EnumOrigemRepasseFieldUpdateOperationsInput | $Enums.OrigemRepasse
    modeloDistribuicaoCodigo?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RepasseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    advogadoId?: IntFieldUpdateOperationsInput | number
    ordemPagamentoId?: NullableIntFieldUpdateOperationsInput | number | null
    referenciaCompetencia?: StringFieldUpdateOperationsInput | string
    valorDevido?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorPago?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dataPagamento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saldoAReceber?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    origem?: EnumOrigemRepasseFieldUpdateOperationsInput | $Enums.OrigemRepasse
    modeloDistribuicaoCodigo?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EstagiarioCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nome: string
    cpf?: string | null
    email?: string | null
    telefone?: string | null
    auxilioTransporteValor?: Decimal | DecimalJsLike | number | string | null
    auxilioEstagioValor?: Decimal | DecimalJsLike | number | string | null
    ativo?: boolean
  }

  export type EstagiarioUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nome: string
    cpf?: string | null
    email?: string | null
    telefone?: string | null
    auxilioTransporteValor?: Decimal | DecimalJsLike | number | string | null
    auxilioEstagioValor?: Decimal | DecimalJsLike | number | string | null
    ativo?: boolean
  }

  export type EstagiarioUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nome?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    auxilioTransporteValor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    auxilioEstagioValor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EstagiarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nome?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    auxilioTransporteValor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    auxilioEstagioValor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EstagiarioCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nome: string
    cpf?: string | null
    email?: string | null
    telefone?: string | null
    auxilioTransporteValor?: Decimal | DecimalJsLike | number | string | null
    auxilioEstagioValor?: Decimal | DecimalJsLike | number | string | null
    ativo?: boolean
  }

  export type EstagiarioUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nome?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    auxilioTransporteValor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    auxilioEstagioValor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EstagiarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nome?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    auxilioTransporteValor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    auxilioEstagioValor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PrestadorServicoCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nomeRazaoSocial: string
    cpfCnpj?: string | null
    tipo: string
    valorRecorrente?: Decimal | DecimalJsLike | number | string | null
    observacoes?: string | null
    ativo?: boolean
  }

  export type PrestadorServicoUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nomeRazaoSocial: string
    cpfCnpj?: string | null
    tipo: string
    valorRecorrente?: Decimal | DecimalJsLike | number | string | null
    observacoes?: string | null
    ativo?: boolean
  }

  export type PrestadorServicoUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nomeRazaoSocial?: StringFieldUpdateOperationsInput | string
    cpfCnpj?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    valorRecorrente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PrestadorServicoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nomeRazaoSocial?: StringFieldUpdateOperationsInput | string
    cpfCnpj?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    valorRecorrente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PrestadorServicoCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nomeRazaoSocial: string
    cpfCnpj?: string | null
    tipo: string
    valorRecorrente?: Decimal | DecimalJsLike | number | string | null
    observacoes?: string | null
    ativo?: boolean
  }

  export type PrestadorServicoUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nomeRazaoSocial?: StringFieldUpdateOperationsInput | string
    cpfCnpj?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    valorRecorrente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PrestadorServicoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nomeRazaoSocial?: StringFieldUpdateOperationsInput | string
    cpfCnpj?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    valorRecorrente?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UsuarioCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nome: string
    email: string
    senhaHash: string
    perfil: $Enums.PerfilUsuario
    ativo?: boolean
  }

  export type UsuarioUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nome: string
    email: string
    senhaHash: string
    perfil: $Enums.PerfilUsuario
    ativo?: boolean
  }

  export type UsuarioUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    perfil?: EnumPerfilUsuarioFieldUpdateOperationsInput | $Enums.PerfilUsuario
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    perfil?: EnumPerfilUsuarioFieldUpdateOperationsInput | $Enums.PerfilUsuario
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UsuarioCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nome: string
    email: string
    senhaHash: string
    perfil: $Enums.PerfilUsuario
    ativo?: boolean
  }

  export type UsuarioUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    perfil?: EnumPerfilUsuarioFieldUpdateOperationsInput | $Enums.PerfilUsuario
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senhaHash?: StringFieldUpdateOperationsInput | string
    perfil?: EnumPerfilUsuarioFieldUpdateOperationsInput | $Enums.PerfilUsuario
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConfiguracaoCalculoCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    codigoModelo: string
    descricao?: string | null
    percentualAdvogado: Decimal | DecimalJsLike | number | string
    percentualSocio: Decimal | DecimalJsLike | number | string
    percentualFundoReserva: Decimal | DecimalJsLike | number | string
    percentualEscritorio: Decimal | DecimalJsLike | number | string
    vigenciaInicio: Date | string
    vigenciaFim?: Date | string | null
    ativo?: boolean
  }

  export type ConfiguracaoCalculoUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    codigoModelo: string
    descricao?: string | null
    percentualAdvogado: Decimal | DecimalJsLike | number | string
    percentualSocio: Decimal | DecimalJsLike | number | string
    percentualFundoReserva: Decimal | DecimalJsLike | number | string
    percentualEscritorio: Decimal | DecimalJsLike | number | string
    vigenciaInicio: Date | string
    vigenciaFim?: Date | string | null
    ativo?: boolean
  }

  export type ConfiguracaoCalculoUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    codigoModelo?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    percentualAdvogado?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    percentualSocio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    percentualFundoReserva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    percentualEscritorio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vigenciaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    vigenciaFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConfiguracaoCalculoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    codigoModelo?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    percentualAdvogado?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    percentualSocio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    percentualFundoReserva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    percentualEscritorio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vigenciaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    vigenciaFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConfiguracaoCalculoCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    codigoModelo: string
    descricao?: string | null
    percentualAdvogado: Decimal | DecimalJsLike | number | string
    percentualSocio: Decimal | DecimalJsLike | number | string
    percentualFundoReserva: Decimal | DecimalJsLike | number | string
    percentualEscritorio: Decimal | DecimalJsLike | number | string
    vigenciaInicio: Date | string
    vigenciaFim?: Date | string | null
    ativo?: boolean
  }

  export type ConfiguracaoCalculoUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    codigoModelo?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    percentualAdvogado?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    percentualSocio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    percentualFundoReserva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    percentualEscritorio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vigenciaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    vigenciaFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConfiguracaoCalculoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    codigoModelo?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    percentualAdvogado?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    percentualSocio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    percentualFundoReserva?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    percentualEscritorio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vigenciaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    vigenciaFim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ModeloDistribuicaoCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    codigo: string
    origem: string
    tipo: string
    percentual: Decimal | DecimalJsLike | number | string
    destinatario: string
  }

  export type ModeloDistribuicaoUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    codigo: string
    origem: string
    tipo: string
    percentual: Decimal | DecimalJsLike | number | string
    destinatario: string
  }

  export type ModeloDistribuicaoUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    codigo?: StringFieldUpdateOperationsInput | string
    origem?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    percentual?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinatario?: StringFieldUpdateOperationsInput | string
  }

  export type ModeloDistribuicaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    codigo?: StringFieldUpdateOperationsInput | string
    origem?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    percentual?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinatario?: StringFieldUpdateOperationsInput | string
  }

  export type ModeloDistribuicaoCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    codigo: string
    origem: string
    tipo: string
    percentual: Decimal | DecimalJsLike | number | string
    destinatario: string
  }

  export type ModeloDistribuicaoUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    codigo?: StringFieldUpdateOperationsInput | string
    origem?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    percentual?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinatario?: StringFieldUpdateOperationsInput | string
  }

  export type ModeloDistribuicaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    codigo?: StringFieldUpdateOperationsInput | string
    origem?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    percentual?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    destinatario?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type OrdemPagamentoListRelationFilter = {
    every?: OrdemPagamentoWhereInput
    some?: OrdemPagamentoWhereInput
    none?: OrdemPagamentoWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type OrdemPagamentoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClienteCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cpfCnpj?: SortOrder
    nomeRazaoSocial?: SortOrder
    email?: SortOrder
    telefone?: SortOrder
    observacoes?: SortOrder
    ativo?: SortOrder
  }

  export type ClienteAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClienteMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cpfCnpj?: SortOrder
    nomeRazaoSocial?: SortOrder
    email?: SortOrder
    telefone?: SortOrder
    observacoes?: SortOrder
    ativo?: SortOrder
  }

  export type ClienteMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cpfCnpj?: SortOrder
    nomeRazaoSocial?: SortOrder
    email?: SortOrder
    telefone?: SortOrder
    observacoes?: SortOrder
    ativo?: SortOrder
  }

  export type ClienteSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type EnumModeloPagamentoFilter<$PrismaModel = never> = {
    equals?: $Enums.ModeloPagamento | EnumModeloPagamentoFieldRefInput<$PrismaModel>
    in?: $Enums.ModeloPagamento[] | ListEnumModeloPagamentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModeloPagamento[] | ListEnumModeloPagamentoFieldRefInput<$PrismaModel>
    not?: NestedEnumModeloPagamentoFilter<$PrismaModel> | $Enums.ModeloPagamento
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumStatusOrdemFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusOrdem | EnumStatusOrdemFieldRefInput<$PrismaModel>
    in?: $Enums.StatusOrdem[] | ListEnumStatusOrdemFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusOrdem[] | ListEnumStatusOrdemFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusOrdemFilter<$PrismaModel> | $Enums.StatusOrdem
  }

  export type ClienteRelationFilter = {
    is?: ClienteWhereInput
    isNot?: ClienteWhereInput
  }

  export type PagamentoListRelationFilter = {
    every?: PagamentoWhereInput
    some?: PagamentoWhereInput
    none?: PagamentoWhereInput
  }

  export type RepasseListRelationFilter = {
    every?: RepasseWhereInput
    some?: RepasseWhereInput
    none?: RepasseWhereInput
  }

  export type PagamentoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RepasseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrdemPagamentoCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clienteId?: SortOrder
    sequenciaCliente?: SortOrder
    codigoInterno?: SortOrder
    descricao?: SortOrder
    tipoContrato?: SortOrder
    valorTotalPrevisto?: SortOrder
    modeloPagamento?: SortOrder
    dataInicio?: SortOrder
    dataFimPrevista?: SortOrder
    status?: SortOrder
  }

  export type OrdemPagamentoAvgOrderByAggregateInput = {
    id?: SortOrder
    clienteId?: SortOrder
    sequenciaCliente?: SortOrder
    valorTotalPrevisto?: SortOrder
  }

  export type OrdemPagamentoMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clienteId?: SortOrder
    sequenciaCliente?: SortOrder
    codigoInterno?: SortOrder
    descricao?: SortOrder
    tipoContrato?: SortOrder
    valorTotalPrevisto?: SortOrder
    modeloPagamento?: SortOrder
    dataInicio?: SortOrder
    dataFimPrevista?: SortOrder
    status?: SortOrder
  }

  export type OrdemPagamentoMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clienteId?: SortOrder
    sequenciaCliente?: SortOrder
    codigoInterno?: SortOrder
    descricao?: SortOrder
    tipoContrato?: SortOrder
    valorTotalPrevisto?: SortOrder
    modeloPagamento?: SortOrder
    dataInicio?: SortOrder
    dataFimPrevista?: SortOrder
    status?: SortOrder
  }

  export type OrdemPagamentoSumOrderByAggregateInput = {
    id?: SortOrder
    clienteId?: SortOrder
    sequenciaCliente?: SortOrder
    valorTotalPrevisto?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumModeloPagamentoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModeloPagamento | EnumModeloPagamentoFieldRefInput<$PrismaModel>
    in?: $Enums.ModeloPagamento[] | ListEnumModeloPagamentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModeloPagamento[] | ListEnumModeloPagamentoFieldRefInput<$PrismaModel>
    not?: NestedEnumModeloPagamentoWithAggregatesFilter<$PrismaModel> | $Enums.ModeloPagamento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModeloPagamentoFilter<$PrismaModel>
    _max?: NestedEnumModeloPagamentoFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumStatusOrdemWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusOrdem | EnumStatusOrdemFieldRefInput<$PrismaModel>
    in?: $Enums.StatusOrdem[] | ListEnumStatusOrdemFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusOrdem[] | ListEnumStatusOrdemFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusOrdemWithAggregatesFilter<$PrismaModel> | $Enums.StatusOrdem
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusOrdemFilter<$PrismaModel>
    _max?: NestedEnumStatusOrdemFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumStatusPagamentoFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusPagamento | EnumStatusPagamentoFieldRefInput<$PrismaModel>
    in?: $Enums.StatusPagamento[] | ListEnumStatusPagamentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusPagamento[] | ListEnumStatusPagamentoFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusPagamentoFilter<$PrismaModel> | $Enums.StatusPagamento
  }

  export type OrdemPagamentoRelationFilter = {
    is?: OrdemPagamentoWhereInput
    isNot?: OrdemPagamentoWhereInput
  }

  export type PagamentoCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ordemPagamentoId?: SortOrder
    numeroParcela?: SortOrder
    dataPrevista?: SortOrder
    dataEfetiva?: SortOrder
    valorPrevisto?: SortOrder
    valorPago?: SortOrder
    formaPagamento?: SortOrder
    status?: SortOrder
    observacoes?: SortOrder
  }

  export type PagamentoAvgOrderByAggregateInput = {
    id?: SortOrder
    ordemPagamentoId?: SortOrder
    numeroParcela?: SortOrder
    valorPrevisto?: SortOrder
    valorPago?: SortOrder
  }

  export type PagamentoMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ordemPagamentoId?: SortOrder
    numeroParcela?: SortOrder
    dataPrevista?: SortOrder
    dataEfetiva?: SortOrder
    valorPrevisto?: SortOrder
    valorPago?: SortOrder
    formaPagamento?: SortOrder
    status?: SortOrder
    observacoes?: SortOrder
  }

  export type PagamentoMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ordemPagamentoId?: SortOrder
    numeroParcela?: SortOrder
    dataPrevista?: SortOrder
    dataEfetiva?: SortOrder
    valorPrevisto?: SortOrder
    valorPago?: SortOrder
    formaPagamento?: SortOrder
    status?: SortOrder
    observacoes?: SortOrder
  }

  export type PagamentoSumOrderByAggregateInput = {
    id?: SortOrder
    ordemPagamentoId?: SortOrder
    numeroParcela?: SortOrder
    valorPrevisto?: SortOrder
    valorPago?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumStatusPagamentoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusPagamento | EnumStatusPagamentoFieldRefInput<$PrismaModel>
    in?: $Enums.StatusPagamento[] | ListEnumStatusPagamentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusPagamento[] | ListEnumStatusPagamentoFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusPagamentoWithAggregatesFilter<$PrismaModel> | $Enums.StatusPagamento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusPagamentoFilter<$PrismaModel>
    _max?: NestedEnumStatusPagamentoFilter<$PrismaModel>
  }

  export type EnumTipoAdvogadoFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoAdvogado | EnumTipoAdvogadoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoAdvogado[] | ListEnumTipoAdvogadoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoAdvogado[] | ListEnumTipoAdvogadoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoAdvogadoFilter<$PrismaModel> | $Enums.TipoAdvogado
  }

  export type AdvogadoCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nome?: SortOrder
    cpf?: SortOrder
    email?: SortOrder
    telefone?: SortOrder
    tipo?: SortOrder
    possuiFixoMensal?: SortOrder
    valorFixoMensal?: SortOrder
    ativo?: SortOrder
  }

  export type AdvogadoAvgOrderByAggregateInput = {
    id?: SortOrder
    valorFixoMensal?: SortOrder
  }

  export type AdvogadoMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nome?: SortOrder
    cpf?: SortOrder
    email?: SortOrder
    telefone?: SortOrder
    tipo?: SortOrder
    possuiFixoMensal?: SortOrder
    valorFixoMensal?: SortOrder
    ativo?: SortOrder
  }

  export type AdvogadoMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nome?: SortOrder
    cpf?: SortOrder
    email?: SortOrder
    telefone?: SortOrder
    tipo?: SortOrder
    possuiFixoMensal?: SortOrder
    valorFixoMensal?: SortOrder
    ativo?: SortOrder
  }

  export type AdvogadoSumOrderByAggregateInput = {
    id?: SortOrder
    valorFixoMensal?: SortOrder
  }

  export type EnumTipoAdvogadoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoAdvogado | EnumTipoAdvogadoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoAdvogado[] | ListEnumTipoAdvogadoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoAdvogado[] | ListEnumTipoAdvogadoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoAdvogadoWithAggregatesFilter<$PrismaModel> | $Enums.TipoAdvogado
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoAdvogadoFilter<$PrismaModel>
    _max?: NestedEnumTipoAdvogadoFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumOrigemRepasseFilter<$PrismaModel = never> = {
    equals?: $Enums.OrigemRepasse | EnumOrigemRepasseFieldRefInput<$PrismaModel>
    in?: $Enums.OrigemRepasse[] | ListEnumOrigemRepasseFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrigemRepasse[] | ListEnumOrigemRepasseFieldRefInput<$PrismaModel>
    not?: NestedEnumOrigemRepasseFilter<$PrismaModel> | $Enums.OrigemRepasse
  }

  export type AdvogadoRelationFilter = {
    is?: AdvogadoWhereInput
    isNot?: AdvogadoWhereInput
  }

  export type OrdemPagamentoNullableRelationFilter = {
    is?: OrdemPagamentoWhereInput | null
    isNot?: OrdemPagamentoWhereInput | null
  }

  export type RepasseCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    advogadoId?: SortOrder
    ordemPagamentoId?: SortOrder
    referenciaCompetencia?: SortOrder
    valorDevido?: SortOrder
    valorPago?: SortOrder
    dataPagamento?: SortOrder
    saldoAReceber?: SortOrder
    origem?: SortOrder
    modeloDistribuicaoCodigo?: SortOrder
    observacoes?: SortOrder
  }

  export type RepasseAvgOrderByAggregateInput = {
    id?: SortOrder
    advogadoId?: SortOrder
    ordemPagamentoId?: SortOrder
    valorDevido?: SortOrder
    valorPago?: SortOrder
    saldoAReceber?: SortOrder
  }

  export type RepasseMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    advogadoId?: SortOrder
    ordemPagamentoId?: SortOrder
    referenciaCompetencia?: SortOrder
    valorDevido?: SortOrder
    valorPago?: SortOrder
    dataPagamento?: SortOrder
    saldoAReceber?: SortOrder
    origem?: SortOrder
    modeloDistribuicaoCodigo?: SortOrder
    observacoes?: SortOrder
  }

  export type RepasseMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    advogadoId?: SortOrder
    ordemPagamentoId?: SortOrder
    referenciaCompetencia?: SortOrder
    valorDevido?: SortOrder
    valorPago?: SortOrder
    dataPagamento?: SortOrder
    saldoAReceber?: SortOrder
    origem?: SortOrder
    modeloDistribuicaoCodigo?: SortOrder
    observacoes?: SortOrder
  }

  export type RepasseSumOrderByAggregateInput = {
    id?: SortOrder
    advogadoId?: SortOrder
    ordemPagamentoId?: SortOrder
    valorDevido?: SortOrder
    valorPago?: SortOrder
    saldoAReceber?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumOrigemRepasseWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrigemRepasse | EnumOrigemRepasseFieldRefInput<$PrismaModel>
    in?: $Enums.OrigemRepasse[] | ListEnumOrigemRepasseFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrigemRepasse[] | ListEnumOrigemRepasseFieldRefInput<$PrismaModel>
    not?: NestedEnumOrigemRepasseWithAggregatesFilter<$PrismaModel> | $Enums.OrigemRepasse
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrigemRepasseFilter<$PrismaModel>
    _max?: NestedEnumOrigemRepasseFilter<$PrismaModel>
  }

  export type EstagiarioCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nome?: SortOrder
    cpf?: SortOrder
    email?: SortOrder
    telefone?: SortOrder
    auxilioTransporteValor?: SortOrder
    auxilioEstagioValor?: SortOrder
    ativo?: SortOrder
  }

  export type EstagiarioAvgOrderByAggregateInput = {
    id?: SortOrder
    auxilioTransporteValor?: SortOrder
    auxilioEstagioValor?: SortOrder
  }

  export type EstagiarioMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nome?: SortOrder
    cpf?: SortOrder
    email?: SortOrder
    telefone?: SortOrder
    auxilioTransporteValor?: SortOrder
    auxilioEstagioValor?: SortOrder
    ativo?: SortOrder
  }

  export type EstagiarioMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nome?: SortOrder
    cpf?: SortOrder
    email?: SortOrder
    telefone?: SortOrder
    auxilioTransporteValor?: SortOrder
    auxilioEstagioValor?: SortOrder
    ativo?: SortOrder
  }

  export type EstagiarioSumOrderByAggregateInput = {
    id?: SortOrder
    auxilioTransporteValor?: SortOrder
    auxilioEstagioValor?: SortOrder
  }

  export type PrestadorServicoCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nomeRazaoSocial?: SortOrder
    cpfCnpj?: SortOrder
    tipo?: SortOrder
    valorRecorrente?: SortOrder
    observacoes?: SortOrder
    ativo?: SortOrder
  }

  export type PrestadorServicoAvgOrderByAggregateInput = {
    id?: SortOrder
    valorRecorrente?: SortOrder
  }

  export type PrestadorServicoMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nomeRazaoSocial?: SortOrder
    cpfCnpj?: SortOrder
    tipo?: SortOrder
    valorRecorrente?: SortOrder
    observacoes?: SortOrder
    ativo?: SortOrder
  }

  export type PrestadorServicoMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nomeRazaoSocial?: SortOrder
    cpfCnpj?: SortOrder
    tipo?: SortOrder
    valorRecorrente?: SortOrder
    observacoes?: SortOrder
    ativo?: SortOrder
  }

  export type PrestadorServicoSumOrderByAggregateInput = {
    id?: SortOrder
    valorRecorrente?: SortOrder
  }

  export type EnumPerfilUsuarioFilter<$PrismaModel = never> = {
    equals?: $Enums.PerfilUsuario | EnumPerfilUsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.PerfilUsuario[] | ListEnumPerfilUsuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.PerfilUsuario[] | ListEnumPerfilUsuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumPerfilUsuarioFilter<$PrismaModel> | $Enums.PerfilUsuario
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senhaHash?: SortOrder
    perfil?: SortOrder
    ativo?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senhaHash?: SortOrder
    perfil?: SortOrder
    ativo?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senhaHash?: SortOrder
    perfil?: SortOrder
    ativo?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumPerfilUsuarioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PerfilUsuario | EnumPerfilUsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.PerfilUsuario[] | ListEnumPerfilUsuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.PerfilUsuario[] | ListEnumPerfilUsuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumPerfilUsuarioWithAggregatesFilter<$PrismaModel> | $Enums.PerfilUsuario
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPerfilUsuarioFilter<$PrismaModel>
    _max?: NestedEnumPerfilUsuarioFilter<$PrismaModel>
  }

  export type ConfiguracaoCalculoCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    codigoModelo?: SortOrder
    descricao?: SortOrder
    percentualAdvogado?: SortOrder
    percentualSocio?: SortOrder
    percentualFundoReserva?: SortOrder
    percentualEscritorio?: SortOrder
    vigenciaInicio?: SortOrder
    vigenciaFim?: SortOrder
    ativo?: SortOrder
  }

  export type ConfiguracaoCalculoAvgOrderByAggregateInput = {
    id?: SortOrder
    percentualAdvogado?: SortOrder
    percentualSocio?: SortOrder
    percentualFundoReserva?: SortOrder
    percentualEscritorio?: SortOrder
  }

  export type ConfiguracaoCalculoMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    codigoModelo?: SortOrder
    descricao?: SortOrder
    percentualAdvogado?: SortOrder
    percentualSocio?: SortOrder
    percentualFundoReserva?: SortOrder
    percentualEscritorio?: SortOrder
    vigenciaInicio?: SortOrder
    vigenciaFim?: SortOrder
    ativo?: SortOrder
  }

  export type ConfiguracaoCalculoMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    codigoModelo?: SortOrder
    descricao?: SortOrder
    percentualAdvogado?: SortOrder
    percentualSocio?: SortOrder
    percentualFundoReserva?: SortOrder
    percentualEscritorio?: SortOrder
    vigenciaInicio?: SortOrder
    vigenciaFim?: SortOrder
    ativo?: SortOrder
  }

  export type ConfiguracaoCalculoSumOrderByAggregateInput = {
    id?: SortOrder
    percentualAdvogado?: SortOrder
    percentualSocio?: SortOrder
    percentualFundoReserva?: SortOrder
    percentualEscritorio?: SortOrder
  }

  export type ModeloDistribuicaoCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    codigo?: SortOrder
    origem?: SortOrder
    tipo?: SortOrder
    percentual?: SortOrder
    destinatario?: SortOrder
  }

  export type ModeloDistribuicaoAvgOrderByAggregateInput = {
    id?: SortOrder
    percentual?: SortOrder
  }

  export type ModeloDistribuicaoMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    codigo?: SortOrder
    origem?: SortOrder
    tipo?: SortOrder
    percentual?: SortOrder
    destinatario?: SortOrder
  }

  export type ModeloDistribuicaoMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    codigo?: SortOrder
    origem?: SortOrder
    tipo?: SortOrder
    percentual?: SortOrder
    destinatario?: SortOrder
  }

  export type ModeloDistribuicaoSumOrderByAggregateInput = {
    id?: SortOrder
    percentual?: SortOrder
  }

  export type OrdemPagamentoCreateNestedManyWithoutClienteInput = {
    create?: XOR<OrdemPagamentoCreateWithoutClienteInput, OrdemPagamentoUncheckedCreateWithoutClienteInput> | OrdemPagamentoCreateWithoutClienteInput[] | OrdemPagamentoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: OrdemPagamentoCreateOrConnectWithoutClienteInput | OrdemPagamentoCreateOrConnectWithoutClienteInput[]
    createMany?: OrdemPagamentoCreateManyClienteInputEnvelope
    connect?: OrdemPagamentoWhereUniqueInput | OrdemPagamentoWhereUniqueInput[]
  }

  export type OrdemPagamentoUncheckedCreateNestedManyWithoutClienteInput = {
    create?: XOR<OrdemPagamentoCreateWithoutClienteInput, OrdemPagamentoUncheckedCreateWithoutClienteInput> | OrdemPagamentoCreateWithoutClienteInput[] | OrdemPagamentoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: OrdemPagamentoCreateOrConnectWithoutClienteInput | OrdemPagamentoCreateOrConnectWithoutClienteInput[]
    createMany?: OrdemPagamentoCreateManyClienteInputEnvelope
    connect?: OrdemPagamentoWhereUniqueInput | OrdemPagamentoWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type OrdemPagamentoUpdateManyWithoutClienteNestedInput = {
    create?: XOR<OrdemPagamentoCreateWithoutClienteInput, OrdemPagamentoUncheckedCreateWithoutClienteInput> | OrdemPagamentoCreateWithoutClienteInput[] | OrdemPagamentoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: OrdemPagamentoCreateOrConnectWithoutClienteInput | OrdemPagamentoCreateOrConnectWithoutClienteInput[]
    upsert?: OrdemPagamentoUpsertWithWhereUniqueWithoutClienteInput | OrdemPagamentoUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: OrdemPagamentoCreateManyClienteInputEnvelope
    set?: OrdemPagamentoWhereUniqueInput | OrdemPagamentoWhereUniqueInput[]
    disconnect?: OrdemPagamentoWhereUniqueInput | OrdemPagamentoWhereUniqueInput[]
    delete?: OrdemPagamentoWhereUniqueInput | OrdemPagamentoWhereUniqueInput[]
    connect?: OrdemPagamentoWhereUniqueInput | OrdemPagamentoWhereUniqueInput[]
    update?: OrdemPagamentoUpdateWithWhereUniqueWithoutClienteInput | OrdemPagamentoUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: OrdemPagamentoUpdateManyWithWhereWithoutClienteInput | OrdemPagamentoUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: OrdemPagamentoScalarWhereInput | OrdemPagamentoScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrdemPagamentoUncheckedUpdateManyWithoutClienteNestedInput = {
    create?: XOR<OrdemPagamentoCreateWithoutClienteInput, OrdemPagamentoUncheckedCreateWithoutClienteInput> | OrdemPagamentoCreateWithoutClienteInput[] | OrdemPagamentoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: OrdemPagamentoCreateOrConnectWithoutClienteInput | OrdemPagamentoCreateOrConnectWithoutClienteInput[]
    upsert?: OrdemPagamentoUpsertWithWhereUniqueWithoutClienteInput | OrdemPagamentoUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: OrdemPagamentoCreateManyClienteInputEnvelope
    set?: OrdemPagamentoWhereUniqueInput | OrdemPagamentoWhereUniqueInput[]
    disconnect?: OrdemPagamentoWhereUniqueInput | OrdemPagamentoWhereUniqueInput[]
    delete?: OrdemPagamentoWhereUniqueInput | OrdemPagamentoWhereUniqueInput[]
    connect?: OrdemPagamentoWhereUniqueInput | OrdemPagamentoWhereUniqueInput[]
    update?: OrdemPagamentoUpdateWithWhereUniqueWithoutClienteInput | OrdemPagamentoUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: OrdemPagamentoUpdateManyWithWhereWithoutClienteInput | OrdemPagamentoUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: OrdemPagamentoScalarWhereInput | OrdemPagamentoScalarWhereInput[]
  }

  export type ClienteCreateNestedOneWithoutOrdensInput = {
    create?: XOR<ClienteCreateWithoutOrdensInput, ClienteUncheckedCreateWithoutOrdensInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutOrdensInput
    connect?: ClienteWhereUniqueInput
  }

  export type PagamentoCreateNestedManyWithoutOrdemPagamentoInput = {
    create?: XOR<PagamentoCreateWithoutOrdemPagamentoInput, PagamentoUncheckedCreateWithoutOrdemPagamentoInput> | PagamentoCreateWithoutOrdemPagamentoInput[] | PagamentoUncheckedCreateWithoutOrdemPagamentoInput[]
    connectOrCreate?: PagamentoCreateOrConnectWithoutOrdemPagamentoInput | PagamentoCreateOrConnectWithoutOrdemPagamentoInput[]
    createMany?: PagamentoCreateManyOrdemPagamentoInputEnvelope
    connect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
  }

  export type RepasseCreateNestedManyWithoutOrdemPagamentoInput = {
    create?: XOR<RepasseCreateWithoutOrdemPagamentoInput, RepasseUncheckedCreateWithoutOrdemPagamentoInput> | RepasseCreateWithoutOrdemPagamentoInput[] | RepasseUncheckedCreateWithoutOrdemPagamentoInput[]
    connectOrCreate?: RepasseCreateOrConnectWithoutOrdemPagamentoInput | RepasseCreateOrConnectWithoutOrdemPagamentoInput[]
    createMany?: RepasseCreateManyOrdemPagamentoInputEnvelope
    connect?: RepasseWhereUniqueInput | RepasseWhereUniqueInput[]
  }

  export type PagamentoUncheckedCreateNestedManyWithoutOrdemPagamentoInput = {
    create?: XOR<PagamentoCreateWithoutOrdemPagamentoInput, PagamentoUncheckedCreateWithoutOrdemPagamentoInput> | PagamentoCreateWithoutOrdemPagamentoInput[] | PagamentoUncheckedCreateWithoutOrdemPagamentoInput[]
    connectOrCreate?: PagamentoCreateOrConnectWithoutOrdemPagamentoInput | PagamentoCreateOrConnectWithoutOrdemPagamentoInput[]
    createMany?: PagamentoCreateManyOrdemPagamentoInputEnvelope
    connect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
  }

  export type RepasseUncheckedCreateNestedManyWithoutOrdemPagamentoInput = {
    create?: XOR<RepasseCreateWithoutOrdemPagamentoInput, RepasseUncheckedCreateWithoutOrdemPagamentoInput> | RepasseCreateWithoutOrdemPagamentoInput[] | RepasseUncheckedCreateWithoutOrdemPagamentoInput[]
    connectOrCreate?: RepasseCreateOrConnectWithoutOrdemPagamentoInput | RepasseCreateOrConnectWithoutOrdemPagamentoInput[]
    createMany?: RepasseCreateManyOrdemPagamentoInputEnvelope
    connect?: RepasseWhereUniqueInput | RepasseWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumModeloPagamentoFieldUpdateOperationsInput = {
    set?: $Enums.ModeloPagamento
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumStatusOrdemFieldUpdateOperationsInput = {
    set?: $Enums.StatusOrdem
  }

  export type ClienteUpdateOneRequiredWithoutOrdensNestedInput = {
    create?: XOR<ClienteCreateWithoutOrdensInput, ClienteUncheckedCreateWithoutOrdensInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutOrdensInput
    upsert?: ClienteUpsertWithoutOrdensInput
    connect?: ClienteWhereUniqueInput
    update?: XOR<XOR<ClienteUpdateToOneWithWhereWithoutOrdensInput, ClienteUpdateWithoutOrdensInput>, ClienteUncheckedUpdateWithoutOrdensInput>
  }

  export type PagamentoUpdateManyWithoutOrdemPagamentoNestedInput = {
    create?: XOR<PagamentoCreateWithoutOrdemPagamentoInput, PagamentoUncheckedCreateWithoutOrdemPagamentoInput> | PagamentoCreateWithoutOrdemPagamentoInput[] | PagamentoUncheckedCreateWithoutOrdemPagamentoInput[]
    connectOrCreate?: PagamentoCreateOrConnectWithoutOrdemPagamentoInput | PagamentoCreateOrConnectWithoutOrdemPagamentoInput[]
    upsert?: PagamentoUpsertWithWhereUniqueWithoutOrdemPagamentoInput | PagamentoUpsertWithWhereUniqueWithoutOrdemPagamentoInput[]
    createMany?: PagamentoCreateManyOrdemPagamentoInputEnvelope
    set?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    disconnect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    delete?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    connect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    update?: PagamentoUpdateWithWhereUniqueWithoutOrdemPagamentoInput | PagamentoUpdateWithWhereUniqueWithoutOrdemPagamentoInput[]
    updateMany?: PagamentoUpdateManyWithWhereWithoutOrdemPagamentoInput | PagamentoUpdateManyWithWhereWithoutOrdemPagamentoInput[]
    deleteMany?: PagamentoScalarWhereInput | PagamentoScalarWhereInput[]
  }

  export type RepasseUpdateManyWithoutOrdemPagamentoNestedInput = {
    create?: XOR<RepasseCreateWithoutOrdemPagamentoInput, RepasseUncheckedCreateWithoutOrdemPagamentoInput> | RepasseCreateWithoutOrdemPagamentoInput[] | RepasseUncheckedCreateWithoutOrdemPagamentoInput[]
    connectOrCreate?: RepasseCreateOrConnectWithoutOrdemPagamentoInput | RepasseCreateOrConnectWithoutOrdemPagamentoInput[]
    upsert?: RepasseUpsertWithWhereUniqueWithoutOrdemPagamentoInput | RepasseUpsertWithWhereUniqueWithoutOrdemPagamentoInput[]
    createMany?: RepasseCreateManyOrdemPagamentoInputEnvelope
    set?: RepasseWhereUniqueInput | RepasseWhereUniqueInput[]
    disconnect?: RepasseWhereUniqueInput | RepasseWhereUniqueInput[]
    delete?: RepasseWhereUniqueInput | RepasseWhereUniqueInput[]
    connect?: RepasseWhereUniqueInput | RepasseWhereUniqueInput[]
    update?: RepasseUpdateWithWhereUniqueWithoutOrdemPagamentoInput | RepasseUpdateWithWhereUniqueWithoutOrdemPagamentoInput[]
    updateMany?: RepasseUpdateManyWithWhereWithoutOrdemPagamentoInput | RepasseUpdateManyWithWhereWithoutOrdemPagamentoInput[]
    deleteMany?: RepasseScalarWhereInput | RepasseScalarWhereInput[]
  }

  export type PagamentoUncheckedUpdateManyWithoutOrdemPagamentoNestedInput = {
    create?: XOR<PagamentoCreateWithoutOrdemPagamentoInput, PagamentoUncheckedCreateWithoutOrdemPagamentoInput> | PagamentoCreateWithoutOrdemPagamentoInput[] | PagamentoUncheckedCreateWithoutOrdemPagamentoInput[]
    connectOrCreate?: PagamentoCreateOrConnectWithoutOrdemPagamentoInput | PagamentoCreateOrConnectWithoutOrdemPagamentoInput[]
    upsert?: PagamentoUpsertWithWhereUniqueWithoutOrdemPagamentoInput | PagamentoUpsertWithWhereUniqueWithoutOrdemPagamentoInput[]
    createMany?: PagamentoCreateManyOrdemPagamentoInputEnvelope
    set?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    disconnect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    delete?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    connect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    update?: PagamentoUpdateWithWhereUniqueWithoutOrdemPagamentoInput | PagamentoUpdateWithWhereUniqueWithoutOrdemPagamentoInput[]
    updateMany?: PagamentoUpdateManyWithWhereWithoutOrdemPagamentoInput | PagamentoUpdateManyWithWhereWithoutOrdemPagamentoInput[]
    deleteMany?: PagamentoScalarWhereInput | PagamentoScalarWhereInput[]
  }

  export type RepasseUncheckedUpdateManyWithoutOrdemPagamentoNestedInput = {
    create?: XOR<RepasseCreateWithoutOrdemPagamentoInput, RepasseUncheckedCreateWithoutOrdemPagamentoInput> | RepasseCreateWithoutOrdemPagamentoInput[] | RepasseUncheckedCreateWithoutOrdemPagamentoInput[]
    connectOrCreate?: RepasseCreateOrConnectWithoutOrdemPagamentoInput | RepasseCreateOrConnectWithoutOrdemPagamentoInput[]
    upsert?: RepasseUpsertWithWhereUniqueWithoutOrdemPagamentoInput | RepasseUpsertWithWhereUniqueWithoutOrdemPagamentoInput[]
    createMany?: RepasseCreateManyOrdemPagamentoInputEnvelope
    set?: RepasseWhereUniqueInput | RepasseWhereUniqueInput[]
    disconnect?: RepasseWhereUniqueInput | RepasseWhereUniqueInput[]
    delete?: RepasseWhereUniqueInput | RepasseWhereUniqueInput[]
    connect?: RepasseWhereUniqueInput | RepasseWhereUniqueInput[]
    update?: RepasseUpdateWithWhereUniqueWithoutOrdemPagamentoInput | RepasseUpdateWithWhereUniqueWithoutOrdemPagamentoInput[]
    updateMany?: RepasseUpdateManyWithWhereWithoutOrdemPagamentoInput | RepasseUpdateManyWithWhereWithoutOrdemPagamentoInput[]
    deleteMany?: RepasseScalarWhereInput | RepasseScalarWhereInput[]
  }

  export type OrdemPagamentoCreateNestedOneWithoutPagamentosInput = {
    create?: XOR<OrdemPagamentoCreateWithoutPagamentosInput, OrdemPagamentoUncheckedCreateWithoutPagamentosInput>
    connectOrCreate?: OrdemPagamentoCreateOrConnectWithoutPagamentosInput
    connect?: OrdemPagamentoWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumStatusPagamentoFieldUpdateOperationsInput = {
    set?: $Enums.StatusPagamento
  }

  export type OrdemPagamentoUpdateOneRequiredWithoutPagamentosNestedInput = {
    create?: XOR<OrdemPagamentoCreateWithoutPagamentosInput, OrdemPagamentoUncheckedCreateWithoutPagamentosInput>
    connectOrCreate?: OrdemPagamentoCreateOrConnectWithoutPagamentosInput
    upsert?: OrdemPagamentoUpsertWithoutPagamentosInput
    connect?: OrdemPagamentoWhereUniqueInput
    update?: XOR<XOR<OrdemPagamentoUpdateToOneWithWhereWithoutPagamentosInput, OrdemPagamentoUpdateWithoutPagamentosInput>, OrdemPagamentoUncheckedUpdateWithoutPagamentosInput>
  }

  export type RepasseCreateNestedManyWithoutAdvogadoInput = {
    create?: XOR<RepasseCreateWithoutAdvogadoInput, RepasseUncheckedCreateWithoutAdvogadoInput> | RepasseCreateWithoutAdvogadoInput[] | RepasseUncheckedCreateWithoutAdvogadoInput[]
    connectOrCreate?: RepasseCreateOrConnectWithoutAdvogadoInput | RepasseCreateOrConnectWithoutAdvogadoInput[]
    createMany?: RepasseCreateManyAdvogadoInputEnvelope
    connect?: RepasseWhereUniqueInput | RepasseWhereUniqueInput[]
  }

  export type RepasseUncheckedCreateNestedManyWithoutAdvogadoInput = {
    create?: XOR<RepasseCreateWithoutAdvogadoInput, RepasseUncheckedCreateWithoutAdvogadoInput> | RepasseCreateWithoutAdvogadoInput[] | RepasseUncheckedCreateWithoutAdvogadoInput[]
    connectOrCreate?: RepasseCreateOrConnectWithoutAdvogadoInput | RepasseCreateOrConnectWithoutAdvogadoInput[]
    createMany?: RepasseCreateManyAdvogadoInputEnvelope
    connect?: RepasseWhereUniqueInput | RepasseWhereUniqueInput[]
  }

  export type EnumTipoAdvogadoFieldUpdateOperationsInput = {
    set?: $Enums.TipoAdvogado
  }

  export type RepasseUpdateManyWithoutAdvogadoNestedInput = {
    create?: XOR<RepasseCreateWithoutAdvogadoInput, RepasseUncheckedCreateWithoutAdvogadoInput> | RepasseCreateWithoutAdvogadoInput[] | RepasseUncheckedCreateWithoutAdvogadoInput[]
    connectOrCreate?: RepasseCreateOrConnectWithoutAdvogadoInput | RepasseCreateOrConnectWithoutAdvogadoInput[]
    upsert?: RepasseUpsertWithWhereUniqueWithoutAdvogadoInput | RepasseUpsertWithWhereUniqueWithoutAdvogadoInput[]
    createMany?: RepasseCreateManyAdvogadoInputEnvelope
    set?: RepasseWhereUniqueInput | RepasseWhereUniqueInput[]
    disconnect?: RepasseWhereUniqueInput | RepasseWhereUniqueInput[]
    delete?: RepasseWhereUniqueInput | RepasseWhereUniqueInput[]
    connect?: RepasseWhereUniqueInput | RepasseWhereUniqueInput[]
    update?: RepasseUpdateWithWhereUniqueWithoutAdvogadoInput | RepasseUpdateWithWhereUniqueWithoutAdvogadoInput[]
    updateMany?: RepasseUpdateManyWithWhereWithoutAdvogadoInput | RepasseUpdateManyWithWhereWithoutAdvogadoInput[]
    deleteMany?: RepasseScalarWhereInput | RepasseScalarWhereInput[]
  }

  export type RepasseUncheckedUpdateManyWithoutAdvogadoNestedInput = {
    create?: XOR<RepasseCreateWithoutAdvogadoInput, RepasseUncheckedCreateWithoutAdvogadoInput> | RepasseCreateWithoutAdvogadoInput[] | RepasseUncheckedCreateWithoutAdvogadoInput[]
    connectOrCreate?: RepasseCreateOrConnectWithoutAdvogadoInput | RepasseCreateOrConnectWithoutAdvogadoInput[]
    upsert?: RepasseUpsertWithWhereUniqueWithoutAdvogadoInput | RepasseUpsertWithWhereUniqueWithoutAdvogadoInput[]
    createMany?: RepasseCreateManyAdvogadoInputEnvelope
    set?: RepasseWhereUniqueInput | RepasseWhereUniqueInput[]
    disconnect?: RepasseWhereUniqueInput | RepasseWhereUniqueInput[]
    delete?: RepasseWhereUniqueInput | RepasseWhereUniqueInput[]
    connect?: RepasseWhereUniqueInput | RepasseWhereUniqueInput[]
    update?: RepasseUpdateWithWhereUniqueWithoutAdvogadoInput | RepasseUpdateWithWhereUniqueWithoutAdvogadoInput[]
    updateMany?: RepasseUpdateManyWithWhereWithoutAdvogadoInput | RepasseUpdateManyWithWhereWithoutAdvogadoInput[]
    deleteMany?: RepasseScalarWhereInput | RepasseScalarWhereInput[]
  }

  export type AdvogadoCreateNestedOneWithoutRepassesInput = {
    create?: XOR<AdvogadoCreateWithoutRepassesInput, AdvogadoUncheckedCreateWithoutRepassesInput>
    connectOrCreate?: AdvogadoCreateOrConnectWithoutRepassesInput
    connect?: AdvogadoWhereUniqueInput
  }

  export type OrdemPagamentoCreateNestedOneWithoutRepassesInput = {
    create?: XOR<OrdemPagamentoCreateWithoutRepassesInput, OrdemPagamentoUncheckedCreateWithoutRepassesInput>
    connectOrCreate?: OrdemPagamentoCreateOrConnectWithoutRepassesInput
    connect?: OrdemPagamentoWhereUniqueInput
  }

  export type EnumOrigemRepasseFieldUpdateOperationsInput = {
    set?: $Enums.OrigemRepasse
  }

  export type AdvogadoUpdateOneRequiredWithoutRepassesNestedInput = {
    create?: XOR<AdvogadoCreateWithoutRepassesInput, AdvogadoUncheckedCreateWithoutRepassesInput>
    connectOrCreate?: AdvogadoCreateOrConnectWithoutRepassesInput
    upsert?: AdvogadoUpsertWithoutRepassesInput
    connect?: AdvogadoWhereUniqueInput
    update?: XOR<XOR<AdvogadoUpdateToOneWithWhereWithoutRepassesInput, AdvogadoUpdateWithoutRepassesInput>, AdvogadoUncheckedUpdateWithoutRepassesInput>
  }

  export type OrdemPagamentoUpdateOneWithoutRepassesNestedInput = {
    create?: XOR<OrdemPagamentoCreateWithoutRepassesInput, OrdemPagamentoUncheckedCreateWithoutRepassesInput>
    connectOrCreate?: OrdemPagamentoCreateOrConnectWithoutRepassesInput
    upsert?: OrdemPagamentoUpsertWithoutRepassesInput
    disconnect?: OrdemPagamentoWhereInput | boolean
    delete?: OrdemPagamentoWhereInput | boolean
    connect?: OrdemPagamentoWhereUniqueInput
    update?: XOR<XOR<OrdemPagamentoUpdateToOneWithWhereWithoutRepassesInput, OrdemPagamentoUpdateWithoutRepassesInput>, OrdemPagamentoUncheckedUpdateWithoutRepassesInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumPerfilUsuarioFieldUpdateOperationsInput = {
    set?: $Enums.PerfilUsuario
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumModeloPagamentoFilter<$PrismaModel = never> = {
    equals?: $Enums.ModeloPagamento | EnumModeloPagamentoFieldRefInput<$PrismaModel>
    in?: $Enums.ModeloPagamento[] | ListEnumModeloPagamentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModeloPagamento[] | ListEnumModeloPagamentoFieldRefInput<$PrismaModel>
    not?: NestedEnumModeloPagamentoFilter<$PrismaModel> | $Enums.ModeloPagamento
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumStatusOrdemFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusOrdem | EnumStatusOrdemFieldRefInput<$PrismaModel>
    in?: $Enums.StatusOrdem[] | ListEnumStatusOrdemFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusOrdem[] | ListEnumStatusOrdemFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusOrdemFilter<$PrismaModel> | $Enums.StatusOrdem
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumModeloPagamentoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModeloPagamento | EnumModeloPagamentoFieldRefInput<$PrismaModel>
    in?: $Enums.ModeloPagamento[] | ListEnumModeloPagamentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModeloPagamento[] | ListEnumModeloPagamentoFieldRefInput<$PrismaModel>
    not?: NestedEnumModeloPagamentoWithAggregatesFilter<$PrismaModel> | $Enums.ModeloPagamento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModeloPagamentoFilter<$PrismaModel>
    _max?: NestedEnumModeloPagamentoFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumStatusOrdemWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusOrdem | EnumStatusOrdemFieldRefInput<$PrismaModel>
    in?: $Enums.StatusOrdem[] | ListEnumStatusOrdemFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusOrdem[] | ListEnumStatusOrdemFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusOrdemWithAggregatesFilter<$PrismaModel> | $Enums.StatusOrdem
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusOrdemFilter<$PrismaModel>
    _max?: NestedEnumStatusOrdemFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumStatusPagamentoFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusPagamento | EnumStatusPagamentoFieldRefInput<$PrismaModel>
    in?: $Enums.StatusPagamento[] | ListEnumStatusPagamentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusPagamento[] | ListEnumStatusPagamentoFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusPagamentoFilter<$PrismaModel> | $Enums.StatusPagamento
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumStatusPagamentoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusPagamento | EnumStatusPagamentoFieldRefInput<$PrismaModel>
    in?: $Enums.StatusPagamento[] | ListEnumStatusPagamentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusPagamento[] | ListEnumStatusPagamentoFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusPagamentoWithAggregatesFilter<$PrismaModel> | $Enums.StatusPagamento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusPagamentoFilter<$PrismaModel>
    _max?: NestedEnumStatusPagamentoFilter<$PrismaModel>
  }

  export type NestedEnumTipoAdvogadoFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoAdvogado | EnumTipoAdvogadoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoAdvogado[] | ListEnumTipoAdvogadoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoAdvogado[] | ListEnumTipoAdvogadoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoAdvogadoFilter<$PrismaModel> | $Enums.TipoAdvogado
  }

  export type NestedEnumTipoAdvogadoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoAdvogado | EnumTipoAdvogadoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoAdvogado[] | ListEnumTipoAdvogadoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoAdvogado[] | ListEnumTipoAdvogadoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoAdvogadoWithAggregatesFilter<$PrismaModel> | $Enums.TipoAdvogado
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoAdvogadoFilter<$PrismaModel>
    _max?: NestedEnumTipoAdvogadoFilter<$PrismaModel>
  }

  export type NestedEnumOrigemRepasseFilter<$PrismaModel = never> = {
    equals?: $Enums.OrigemRepasse | EnumOrigemRepasseFieldRefInput<$PrismaModel>
    in?: $Enums.OrigemRepasse[] | ListEnumOrigemRepasseFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrigemRepasse[] | ListEnumOrigemRepasseFieldRefInput<$PrismaModel>
    not?: NestedEnumOrigemRepasseFilter<$PrismaModel> | $Enums.OrigemRepasse
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumOrigemRepasseWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrigemRepasse | EnumOrigemRepasseFieldRefInput<$PrismaModel>
    in?: $Enums.OrigemRepasse[] | ListEnumOrigemRepasseFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrigemRepasse[] | ListEnumOrigemRepasseFieldRefInput<$PrismaModel>
    not?: NestedEnumOrigemRepasseWithAggregatesFilter<$PrismaModel> | $Enums.OrigemRepasse
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrigemRepasseFilter<$PrismaModel>
    _max?: NestedEnumOrigemRepasseFilter<$PrismaModel>
  }

  export type NestedEnumPerfilUsuarioFilter<$PrismaModel = never> = {
    equals?: $Enums.PerfilUsuario | EnumPerfilUsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.PerfilUsuario[] | ListEnumPerfilUsuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.PerfilUsuario[] | ListEnumPerfilUsuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumPerfilUsuarioFilter<$PrismaModel> | $Enums.PerfilUsuario
  }

  export type NestedEnumPerfilUsuarioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PerfilUsuario | EnumPerfilUsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.PerfilUsuario[] | ListEnumPerfilUsuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.PerfilUsuario[] | ListEnumPerfilUsuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumPerfilUsuarioWithAggregatesFilter<$PrismaModel> | $Enums.PerfilUsuario
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPerfilUsuarioFilter<$PrismaModel>
    _max?: NestedEnumPerfilUsuarioFilter<$PrismaModel>
  }

  export type OrdemPagamentoCreateWithoutClienteInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    sequenciaCliente: number
    codigoInterno?: string | null
    descricao?: string | null
    tipoContrato?: string | null
    valorTotalPrevisto?: Decimal | DecimalJsLike | number | string | null
    modeloPagamento: $Enums.ModeloPagamento
    dataInicio: Date | string
    dataFimPrevista?: Date | string | null
    status: $Enums.StatusOrdem
    pagamentos?: PagamentoCreateNestedManyWithoutOrdemPagamentoInput
    repasses?: RepasseCreateNestedManyWithoutOrdemPagamentoInput
  }

  export type OrdemPagamentoUncheckedCreateWithoutClienteInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sequenciaCliente: number
    codigoInterno?: string | null
    descricao?: string | null
    tipoContrato?: string | null
    valorTotalPrevisto?: Decimal | DecimalJsLike | number | string | null
    modeloPagamento: $Enums.ModeloPagamento
    dataInicio: Date | string
    dataFimPrevista?: Date | string | null
    status: $Enums.StatusOrdem
    pagamentos?: PagamentoUncheckedCreateNestedManyWithoutOrdemPagamentoInput
    repasses?: RepasseUncheckedCreateNestedManyWithoutOrdemPagamentoInput
  }

  export type OrdemPagamentoCreateOrConnectWithoutClienteInput = {
    where: OrdemPagamentoWhereUniqueInput
    create: XOR<OrdemPagamentoCreateWithoutClienteInput, OrdemPagamentoUncheckedCreateWithoutClienteInput>
  }

  export type OrdemPagamentoCreateManyClienteInputEnvelope = {
    data: OrdemPagamentoCreateManyClienteInput | OrdemPagamentoCreateManyClienteInput[]
    skipDuplicates?: boolean
  }

  export type OrdemPagamentoUpsertWithWhereUniqueWithoutClienteInput = {
    where: OrdemPagamentoWhereUniqueInput
    update: XOR<OrdemPagamentoUpdateWithoutClienteInput, OrdemPagamentoUncheckedUpdateWithoutClienteInput>
    create: XOR<OrdemPagamentoCreateWithoutClienteInput, OrdemPagamentoUncheckedCreateWithoutClienteInput>
  }

  export type OrdemPagamentoUpdateWithWhereUniqueWithoutClienteInput = {
    where: OrdemPagamentoWhereUniqueInput
    data: XOR<OrdemPagamentoUpdateWithoutClienteInput, OrdemPagamentoUncheckedUpdateWithoutClienteInput>
  }

  export type OrdemPagamentoUpdateManyWithWhereWithoutClienteInput = {
    where: OrdemPagamentoScalarWhereInput
    data: XOR<OrdemPagamentoUpdateManyMutationInput, OrdemPagamentoUncheckedUpdateManyWithoutClienteInput>
  }

  export type OrdemPagamentoScalarWhereInput = {
    AND?: OrdemPagamentoScalarWhereInput | OrdemPagamentoScalarWhereInput[]
    OR?: OrdemPagamentoScalarWhereInput[]
    NOT?: OrdemPagamentoScalarWhereInput | OrdemPagamentoScalarWhereInput[]
    id?: IntFilter<"OrdemPagamento"> | number
    createdAt?: DateTimeFilter<"OrdemPagamento"> | Date | string
    updatedAt?: DateTimeFilter<"OrdemPagamento"> | Date | string
    clienteId?: IntFilter<"OrdemPagamento"> | number
    sequenciaCliente?: IntFilter<"OrdemPagamento"> | number
    codigoInterno?: StringNullableFilter<"OrdemPagamento"> | string | null
    descricao?: StringNullableFilter<"OrdemPagamento"> | string | null
    tipoContrato?: StringNullableFilter<"OrdemPagamento"> | string | null
    valorTotalPrevisto?: DecimalNullableFilter<"OrdemPagamento"> | Decimal | DecimalJsLike | number | string | null
    modeloPagamento?: EnumModeloPagamentoFilter<"OrdemPagamento"> | $Enums.ModeloPagamento
    dataInicio?: DateTimeFilter<"OrdemPagamento"> | Date | string
    dataFimPrevista?: DateTimeNullableFilter<"OrdemPagamento"> | Date | string | null
    status?: EnumStatusOrdemFilter<"OrdemPagamento"> | $Enums.StatusOrdem
  }

  export type ClienteCreateWithoutOrdensInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    cpfCnpj: string
    nomeRazaoSocial: string
    email?: string | null
    telefone?: string | null
    observacoes?: string | null
    ativo?: boolean
  }

  export type ClienteUncheckedCreateWithoutOrdensInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cpfCnpj: string
    nomeRazaoSocial: string
    email?: string | null
    telefone?: string | null
    observacoes?: string | null
    ativo?: boolean
  }

  export type ClienteCreateOrConnectWithoutOrdensInput = {
    where: ClienteWhereUniqueInput
    create: XOR<ClienteCreateWithoutOrdensInput, ClienteUncheckedCreateWithoutOrdensInput>
  }

  export type PagamentoCreateWithoutOrdemPagamentoInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    numeroParcela: number
    dataPrevista: Date | string
    dataEfetiva?: Date | string | null
    valorPrevisto: Decimal | DecimalJsLike | number | string
    valorPago?: Decimal | DecimalJsLike | number | string | null
    formaPagamento?: string | null
    status: $Enums.StatusPagamento
    observacoes?: string | null
  }

  export type PagamentoUncheckedCreateWithoutOrdemPagamentoInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    numeroParcela: number
    dataPrevista: Date | string
    dataEfetiva?: Date | string | null
    valorPrevisto: Decimal | DecimalJsLike | number | string
    valorPago?: Decimal | DecimalJsLike | number | string | null
    formaPagamento?: string | null
    status: $Enums.StatusPagamento
    observacoes?: string | null
  }

  export type PagamentoCreateOrConnectWithoutOrdemPagamentoInput = {
    where: PagamentoWhereUniqueInput
    create: XOR<PagamentoCreateWithoutOrdemPagamentoInput, PagamentoUncheckedCreateWithoutOrdemPagamentoInput>
  }

  export type PagamentoCreateManyOrdemPagamentoInputEnvelope = {
    data: PagamentoCreateManyOrdemPagamentoInput | PagamentoCreateManyOrdemPagamentoInput[]
    skipDuplicates?: boolean
  }

  export type RepasseCreateWithoutOrdemPagamentoInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    referenciaCompetencia: string
    valorDevido: Decimal | DecimalJsLike | number | string
    valorPago?: Decimal | DecimalJsLike | number | string | null
    dataPagamento?: Date | string | null
    saldoAReceber?: Decimal | DecimalJsLike | number | string | null
    origem: $Enums.OrigemRepasse
    modeloDistribuicaoCodigo?: string | null
    observacoes?: string | null
    advogado: AdvogadoCreateNestedOneWithoutRepassesInput
  }

  export type RepasseUncheckedCreateWithoutOrdemPagamentoInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    advogadoId: number
    referenciaCompetencia: string
    valorDevido: Decimal | DecimalJsLike | number | string
    valorPago?: Decimal | DecimalJsLike | number | string | null
    dataPagamento?: Date | string | null
    saldoAReceber?: Decimal | DecimalJsLike | number | string | null
    origem: $Enums.OrigemRepasse
    modeloDistribuicaoCodigo?: string | null
    observacoes?: string | null
  }

  export type RepasseCreateOrConnectWithoutOrdemPagamentoInput = {
    where: RepasseWhereUniqueInput
    create: XOR<RepasseCreateWithoutOrdemPagamentoInput, RepasseUncheckedCreateWithoutOrdemPagamentoInput>
  }

  export type RepasseCreateManyOrdemPagamentoInputEnvelope = {
    data: RepasseCreateManyOrdemPagamentoInput | RepasseCreateManyOrdemPagamentoInput[]
    skipDuplicates?: boolean
  }

  export type ClienteUpsertWithoutOrdensInput = {
    update: XOR<ClienteUpdateWithoutOrdensInput, ClienteUncheckedUpdateWithoutOrdensInput>
    create: XOR<ClienteCreateWithoutOrdensInput, ClienteUncheckedCreateWithoutOrdensInput>
    where?: ClienteWhereInput
  }

  export type ClienteUpdateToOneWithWhereWithoutOrdensInput = {
    where?: ClienteWhereInput
    data: XOR<ClienteUpdateWithoutOrdensInput, ClienteUncheckedUpdateWithoutOrdensInput>
  }

  export type ClienteUpdateWithoutOrdensInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpfCnpj?: StringFieldUpdateOperationsInput | string
    nomeRazaoSocial?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClienteUncheckedUpdateWithoutOrdensInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpfCnpj?: StringFieldUpdateOperationsInput | string
    nomeRazaoSocial?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PagamentoUpsertWithWhereUniqueWithoutOrdemPagamentoInput = {
    where: PagamentoWhereUniqueInput
    update: XOR<PagamentoUpdateWithoutOrdemPagamentoInput, PagamentoUncheckedUpdateWithoutOrdemPagamentoInput>
    create: XOR<PagamentoCreateWithoutOrdemPagamentoInput, PagamentoUncheckedCreateWithoutOrdemPagamentoInput>
  }

  export type PagamentoUpdateWithWhereUniqueWithoutOrdemPagamentoInput = {
    where: PagamentoWhereUniqueInput
    data: XOR<PagamentoUpdateWithoutOrdemPagamentoInput, PagamentoUncheckedUpdateWithoutOrdemPagamentoInput>
  }

  export type PagamentoUpdateManyWithWhereWithoutOrdemPagamentoInput = {
    where: PagamentoScalarWhereInput
    data: XOR<PagamentoUpdateManyMutationInput, PagamentoUncheckedUpdateManyWithoutOrdemPagamentoInput>
  }

  export type PagamentoScalarWhereInput = {
    AND?: PagamentoScalarWhereInput | PagamentoScalarWhereInput[]
    OR?: PagamentoScalarWhereInput[]
    NOT?: PagamentoScalarWhereInput | PagamentoScalarWhereInput[]
    id?: IntFilter<"Pagamento"> | number
    createdAt?: DateTimeFilter<"Pagamento"> | Date | string
    updatedAt?: DateTimeFilter<"Pagamento"> | Date | string
    ordemPagamentoId?: IntFilter<"Pagamento"> | number
    numeroParcela?: IntFilter<"Pagamento"> | number
    dataPrevista?: DateTimeFilter<"Pagamento"> | Date | string
    dataEfetiva?: DateTimeNullableFilter<"Pagamento"> | Date | string | null
    valorPrevisto?: DecimalFilter<"Pagamento"> | Decimal | DecimalJsLike | number | string
    valorPago?: DecimalNullableFilter<"Pagamento"> | Decimal | DecimalJsLike | number | string | null
    formaPagamento?: StringNullableFilter<"Pagamento"> | string | null
    status?: EnumStatusPagamentoFilter<"Pagamento"> | $Enums.StatusPagamento
    observacoes?: StringNullableFilter<"Pagamento"> | string | null
  }

  export type RepasseUpsertWithWhereUniqueWithoutOrdemPagamentoInput = {
    where: RepasseWhereUniqueInput
    update: XOR<RepasseUpdateWithoutOrdemPagamentoInput, RepasseUncheckedUpdateWithoutOrdemPagamentoInput>
    create: XOR<RepasseCreateWithoutOrdemPagamentoInput, RepasseUncheckedCreateWithoutOrdemPagamentoInput>
  }

  export type RepasseUpdateWithWhereUniqueWithoutOrdemPagamentoInput = {
    where: RepasseWhereUniqueInput
    data: XOR<RepasseUpdateWithoutOrdemPagamentoInput, RepasseUncheckedUpdateWithoutOrdemPagamentoInput>
  }

  export type RepasseUpdateManyWithWhereWithoutOrdemPagamentoInput = {
    where: RepasseScalarWhereInput
    data: XOR<RepasseUpdateManyMutationInput, RepasseUncheckedUpdateManyWithoutOrdemPagamentoInput>
  }

  export type RepasseScalarWhereInput = {
    AND?: RepasseScalarWhereInput | RepasseScalarWhereInput[]
    OR?: RepasseScalarWhereInput[]
    NOT?: RepasseScalarWhereInput | RepasseScalarWhereInput[]
    id?: IntFilter<"Repasse"> | number
    createdAt?: DateTimeFilter<"Repasse"> | Date | string
    updatedAt?: DateTimeFilter<"Repasse"> | Date | string
    advogadoId?: IntFilter<"Repasse"> | number
    ordemPagamentoId?: IntNullableFilter<"Repasse"> | number | null
    referenciaCompetencia?: StringFilter<"Repasse"> | string
    valorDevido?: DecimalFilter<"Repasse"> | Decimal | DecimalJsLike | number | string
    valorPago?: DecimalNullableFilter<"Repasse"> | Decimal | DecimalJsLike | number | string | null
    dataPagamento?: DateTimeNullableFilter<"Repasse"> | Date | string | null
    saldoAReceber?: DecimalNullableFilter<"Repasse"> | Decimal | DecimalJsLike | number | string | null
    origem?: EnumOrigemRepasseFilter<"Repasse"> | $Enums.OrigemRepasse
    modeloDistribuicaoCodigo?: StringNullableFilter<"Repasse"> | string | null
    observacoes?: StringNullableFilter<"Repasse"> | string | null
  }

  export type OrdemPagamentoCreateWithoutPagamentosInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    sequenciaCliente: number
    codigoInterno?: string | null
    descricao?: string | null
    tipoContrato?: string | null
    valorTotalPrevisto?: Decimal | DecimalJsLike | number | string | null
    modeloPagamento: $Enums.ModeloPagamento
    dataInicio: Date | string
    dataFimPrevista?: Date | string | null
    status: $Enums.StatusOrdem
    cliente: ClienteCreateNestedOneWithoutOrdensInput
    repasses?: RepasseCreateNestedManyWithoutOrdemPagamentoInput
  }

  export type OrdemPagamentoUncheckedCreateWithoutPagamentosInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clienteId: number
    sequenciaCliente: number
    codigoInterno?: string | null
    descricao?: string | null
    tipoContrato?: string | null
    valorTotalPrevisto?: Decimal | DecimalJsLike | number | string | null
    modeloPagamento: $Enums.ModeloPagamento
    dataInicio: Date | string
    dataFimPrevista?: Date | string | null
    status: $Enums.StatusOrdem
    repasses?: RepasseUncheckedCreateNestedManyWithoutOrdemPagamentoInput
  }

  export type OrdemPagamentoCreateOrConnectWithoutPagamentosInput = {
    where: OrdemPagamentoWhereUniqueInput
    create: XOR<OrdemPagamentoCreateWithoutPagamentosInput, OrdemPagamentoUncheckedCreateWithoutPagamentosInput>
  }

  export type OrdemPagamentoUpsertWithoutPagamentosInput = {
    update: XOR<OrdemPagamentoUpdateWithoutPagamentosInput, OrdemPagamentoUncheckedUpdateWithoutPagamentosInput>
    create: XOR<OrdemPagamentoCreateWithoutPagamentosInput, OrdemPagamentoUncheckedCreateWithoutPagamentosInput>
    where?: OrdemPagamentoWhereInput
  }

  export type OrdemPagamentoUpdateToOneWithWhereWithoutPagamentosInput = {
    where?: OrdemPagamentoWhereInput
    data: XOR<OrdemPagamentoUpdateWithoutPagamentosInput, OrdemPagamentoUncheckedUpdateWithoutPagamentosInput>
  }

  export type OrdemPagamentoUpdateWithoutPagamentosInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sequenciaCliente?: IntFieldUpdateOperationsInput | number
    codigoInterno?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    tipoContrato?: NullableStringFieldUpdateOperationsInput | string | null
    valorTotalPrevisto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    modeloPagamento?: EnumModeloPagamentoFieldUpdateOperationsInput | $Enums.ModeloPagamento
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFimPrevista?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusOrdemFieldUpdateOperationsInput | $Enums.StatusOrdem
    cliente?: ClienteUpdateOneRequiredWithoutOrdensNestedInput
    repasses?: RepasseUpdateManyWithoutOrdemPagamentoNestedInput
  }

  export type OrdemPagamentoUncheckedUpdateWithoutPagamentosInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clienteId?: IntFieldUpdateOperationsInput | number
    sequenciaCliente?: IntFieldUpdateOperationsInput | number
    codigoInterno?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    tipoContrato?: NullableStringFieldUpdateOperationsInput | string | null
    valorTotalPrevisto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    modeloPagamento?: EnumModeloPagamentoFieldUpdateOperationsInput | $Enums.ModeloPagamento
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFimPrevista?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusOrdemFieldUpdateOperationsInput | $Enums.StatusOrdem
    repasses?: RepasseUncheckedUpdateManyWithoutOrdemPagamentoNestedInput
  }

  export type RepasseCreateWithoutAdvogadoInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    referenciaCompetencia: string
    valorDevido: Decimal | DecimalJsLike | number | string
    valorPago?: Decimal | DecimalJsLike | number | string | null
    dataPagamento?: Date | string | null
    saldoAReceber?: Decimal | DecimalJsLike | number | string | null
    origem: $Enums.OrigemRepasse
    modeloDistribuicaoCodigo?: string | null
    observacoes?: string | null
    ordemPagamento?: OrdemPagamentoCreateNestedOneWithoutRepassesInput
  }

  export type RepasseUncheckedCreateWithoutAdvogadoInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ordemPagamentoId?: number | null
    referenciaCompetencia: string
    valorDevido: Decimal | DecimalJsLike | number | string
    valorPago?: Decimal | DecimalJsLike | number | string | null
    dataPagamento?: Date | string | null
    saldoAReceber?: Decimal | DecimalJsLike | number | string | null
    origem: $Enums.OrigemRepasse
    modeloDistribuicaoCodigo?: string | null
    observacoes?: string | null
  }

  export type RepasseCreateOrConnectWithoutAdvogadoInput = {
    where: RepasseWhereUniqueInput
    create: XOR<RepasseCreateWithoutAdvogadoInput, RepasseUncheckedCreateWithoutAdvogadoInput>
  }

  export type RepasseCreateManyAdvogadoInputEnvelope = {
    data: RepasseCreateManyAdvogadoInput | RepasseCreateManyAdvogadoInput[]
    skipDuplicates?: boolean
  }

  export type RepasseUpsertWithWhereUniqueWithoutAdvogadoInput = {
    where: RepasseWhereUniqueInput
    update: XOR<RepasseUpdateWithoutAdvogadoInput, RepasseUncheckedUpdateWithoutAdvogadoInput>
    create: XOR<RepasseCreateWithoutAdvogadoInput, RepasseUncheckedCreateWithoutAdvogadoInput>
  }

  export type RepasseUpdateWithWhereUniqueWithoutAdvogadoInput = {
    where: RepasseWhereUniqueInput
    data: XOR<RepasseUpdateWithoutAdvogadoInput, RepasseUncheckedUpdateWithoutAdvogadoInput>
  }

  export type RepasseUpdateManyWithWhereWithoutAdvogadoInput = {
    where: RepasseScalarWhereInput
    data: XOR<RepasseUpdateManyMutationInput, RepasseUncheckedUpdateManyWithoutAdvogadoInput>
  }

  export type AdvogadoCreateWithoutRepassesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    nome: string
    cpf?: string | null
    email?: string | null
    telefone?: string | null
    tipo: $Enums.TipoAdvogado
    possuiFixoMensal?: boolean
    valorFixoMensal?: Decimal | DecimalJsLike | number | string | null
    ativo?: boolean
  }

  export type AdvogadoUncheckedCreateWithoutRepassesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nome: string
    cpf?: string | null
    email?: string | null
    telefone?: string | null
    tipo: $Enums.TipoAdvogado
    possuiFixoMensal?: boolean
    valorFixoMensal?: Decimal | DecimalJsLike | number | string | null
    ativo?: boolean
  }

  export type AdvogadoCreateOrConnectWithoutRepassesInput = {
    where: AdvogadoWhereUniqueInput
    create: XOR<AdvogadoCreateWithoutRepassesInput, AdvogadoUncheckedCreateWithoutRepassesInput>
  }

  export type OrdemPagamentoCreateWithoutRepassesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    sequenciaCliente: number
    codigoInterno?: string | null
    descricao?: string | null
    tipoContrato?: string | null
    valorTotalPrevisto?: Decimal | DecimalJsLike | number | string | null
    modeloPagamento: $Enums.ModeloPagamento
    dataInicio: Date | string
    dataFimPrevista?: Date | string | null
    status: $Enums.StatusOrdem
    cliente: ClienteCreateNestedOneWithoutOrdensInput
    pagamentos?: PagamentoCreateNestedManyWithoutOrdemPagamentoInput
  }

  export type OrdemPagamentoUncheckedCreateWithoutRepassesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clienteId: number
    sequenciaCliente: number
    codigoInterno?: string | null
    descricao?: string | null
    tipoContrato?: string | null
    valorTotalPrevisto?: Decimal | DecimalJsLike | number | string | null
    modeloPagamento: $Enums.ModeloPagamento
    dataInicio: Date | string
    dataFimPrevista?: Date | string | null
    status: $Enums.StatusOrdem
    pagamentos?: PagamentoUncheckedCreateNestedManyWithoutOrdemPagamentoInput
  }

  export type OrdemPagamentoCreateOrConnectWithoutRepassesInput = {
    where: OrdemPagamentoWhereUniqueInput
    create: XOR<OrdemPagamentoCreateWithoutRepassesInput, OrdemPagamentoUncheckedCreateWithoutRepassesInput>
  }

  export type AdvogadoUpsertWithoutRepassesInput = {
    update: XOR<AdvogadoUpdateWithoutRepassesInput, AdvogadoUncheckedUpdateWithoutRepassesInput>
    create: XOR<AdvogadoCreateWithoutRepassesInput, AdvogadoUncheckedCreateWithoutRepassesInput>
    where?: AdvogadoWhereInput
  }

  export type AdvogadoUpdateToOneWithWhereWithoutRepassesInput = {
    where?: AdvogadoWhereInput
    data: XOR<AdvogadoUpdateWithoutRepassesInput, AdvogadoUncheckedUpdateWithoutRepassesInput>
  }

  export type AdvogadoUpdateWithoutRepassesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nome?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoAdvogadoFieldUpdateOperationsInput | $Enums.TipoAdvogado
    possuiFixoMensal?: BoolFieldUpdateOperationsInput | boolean
    valorFixoMensal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdvogadoUncheckedUpdateWithoutRepassesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nome?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoAdvogadoFieldUpdateOperationsInput | $Enums.TipoAdvogado
    possuiFixoMensal?: BoolFieldUpdateOperationsInput | boolean
    valorFixoMensal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrdemPagamentoUpsertWithoutRepassesInput = {
    update: XOR<OrdemPagamentoUpdateWithoutRepassesInput, OrdemPagamentoUncheckedUpdateWithoutRepassesInput>
    create: XOR<OrdemPagamentoCreateWithoutRepassesInput, OrdemPagamentoUncheckedCreateWithoutRepassesInput>
    where?: OrdemPagamentoWhereInput
  }

  export type OrdemPagamentoUpdateToOneWithWhereWithoutRepassesInput = {
    where?: OrdemPagamentoWhereInput
    data: XOR<OrdemPagamentoUpdateWithoutRepassesInput, OrdemPagamentoUncheckedUpdateWithoutRepassesInput>
  }

  export type OrdemPagamentoUpdateWithoutRepassesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sequenciaCliente?: IntFieldUpdateOperationsInput | number
    codigoInterno?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    tipoContrato?: NullableStringFieldUpdateOperationsInput | string | null
    valorTotalPrevisto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    modeloPagamento?: EnumModeloPagamentoFieldUpdateOperationsInput | $Enums.ModeloPagamento
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFimPrevista?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusOrdemFieldUpdateOperationsInput | $Enums.StatusOrdem
    cliente?: ClienteUpdateOneRequiredWithoutOrdensNestedInput
    pagamentos?: PagamentoUpdateManyWithoutOrdemPagamentoNestedInput
  }

  export type OrdemPagamentoUncheckedUpdateWithoutRepassesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clienteId?: IntFieldUpdateOperationsInput | number
    sequenciaCliente?: IntFieldUpdateOperationsInput | number
    codigoInterno?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    tipoContrato?: NullableStringFieldUpdateOperationsInput | string | null
    valorTotalPrevisto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    modeloPagamento?: EnumModeloPagamentoFieldUpdateOperationsInput | $Enums.ModeloPagamento
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFimPrevista?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusOrdemFieldUpdateOperationsInput | $Enums.StatusOrdem
    pagamentos?: PagamentoUncheckedUpdateManyWithoutOrdemPagamentoNestedInput
  }

  export type OrdemPagamentoCreateManyClienteInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sequenciaCliente: number
    codigoInterno?: string | null
    descricao?: string | null
    tipoContrato?: string | null
    valorTotalPrevisto?: Decimal | DecimalJsLike | number | string | null
    modeloPagamento: $Enums.ModeloPagamento
    dataInicio: Date | string
    dataFimPrevista?: Date | string | null
    status: $Enums.StatusOrdem
  }

  export type OrdemPagamentoUpdateWithoutClienteInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sequenciaCliente?: IntFieldUpdateOperationsInput | number
    codigoInterno?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    tipoContrato?: NullableStringFieldUpdateOperationsInput | string | null
    valorTotalPrevisto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    modeloPagamento?: EnumModeloPagamentoFieldUpdateOperationsInput | $Enums.ModeloPagamento
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFimPrevista?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusOrdemFieldUpdateOperationsInput | $Enums.StatusOrdem
    pagamentos?: PagamentoUpdateManyWithoutOrdemPagamentoNestedInput
    repasses?: RepasseUpdateManyWithoutOrdemPagamentoNestedInput
  }

  export type OrdemPagamentoUncheckedUpdateWithoutClienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sequenciaCliente?: IntFieldUpdateOperationsInput | number
    codigoInterno?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    tipoContrato?: NullableStringFieldUpdateOperationsInput | string | null
    valorTotalPrevisto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    modeloPagamento?: EnumModeloPagamentoFieldUpdateOperationsInput | $Enums.ModeloPagamento
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFimPrevista?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusOrdemFieldUpdateOperationsInput | $Enums.StatusOrdem
    pagamentos?: PagamentoUncheckedUpdateManyWithoutOrdemPagamentoNestedInput
    repasses?: RepasseUncheckedUpdateManyWithoutOrdemPagamentoNestedInput
  }

  export type OrdemPagamentoUncheckedUpdateManyWithoutClienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sequenciaCliente?: IntFieldUpdateOperationsInput | number
    codigoInterno?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    tipoContrato?: NullableStringFieldUpdateOperationsInput | string | null
    valorTotalPrevisto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    modeloPagamento?: EnumModeloPagamentoFieldUpdateOperationsInput | $Enums.ModeloPagamento
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFimPrevista?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusOrdemFieldUpdateOperationsInput | $Enums.StatusOrdem
  }

  export type PagamentoCreateManyOrdemPagamentoInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    numeroParcela: number
    dataPrevista: Date | string
    dataEfetiva?: Date | string | null
    valorPrevisto: Decimal | DecimalJsLike | number | string
    valorPago?: Decimal | DecimalJsLike | number | string | null
    formaPagamento?: string | null
    status: $Enums.StatusPagamento
    observacoes?: string | null
  }

  export type RepasseCreateManyOrdemPagamentoInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    advogadoId: number
    referenciaCompetencia: string
    valorDevido: Decimal | DecimalJsLike | number | string
    valorPago?: Decimal | DecimalJsLike | number | string | null
    dataPagamento?: Date | string | null
    saldoAReceber?: Decimal | DecimalJsLike | number | string | null
    origem: $Enums.OrigemRepasse
    modeloDistribuicaoCodigo?: string | null
    observacoes?: string | null
  }

  export type PagamentoUpdateWithoutOrdemPagamentoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroParcela?: IntFieldUpdateOperationsInput | number
    dataPrevista?: DateTimeFieldUpdateOperationsInput | Date | string
    dataEfetiva?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valorPrevisto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorPago?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    formaPagamento?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusPagamentoFieldUpdateOperationsInput | $Enums.StatusPagamento
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PagamentoUncheckedUpdateWithoutOrdemPagamentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroParcela?: IntFieldUpdateOperationsInput | number
    dataPrevista?: DateTimeFieldUpdateOperationsInput | Date | string
    dataEfetiva?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valorPrevisto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorPago?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    formaPagamento?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusPagamentoFieldUpdateOperationsInput | $Enums.StatusPagamento
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PagamentoUncheckedUpdateManyWithoutOrdemPagamentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroParcela?: IntFieldUpdateOperationsInput | number
    dataPrevista?: DateTimeFieldUpdateOperationsInput | Date | string
    dataEfetiva?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valorPrevisto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorPago?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    formaPagamento?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusPagamentoFieldUpdateOperationsInput | $Enums.StatusPagamento
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RepasseUpdateWithoutOrdemPagamentoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenciaCompetencia?: StringFieldUpdateOperationsInput | string
    valorDevido?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorPago?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dataPagamento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saldoAReceber?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    origem?: EnumOrigemRepasseFieldUpdateOperationsInput | $Enums.OrigemRepasse
    modeloDistribuicaoCodigo?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    advogado?: AdvogadoUpdateOneRequiredWithoutRepassesNestedInput
  }

  export type RepasseUncheckedUpdateWithoutOrdemPagamentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    advogadoId?: IntFieldUpdateOperationsInput | number
    referenciaCompetencia?: StringFieldUpdateOperationsInput | string
    valorDevido?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorPago?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dataPagamento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saldoAReceber?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    origem?: EnumOrigemRepasseFieldUpdateOperationsInput | $Enums.OrigemRepasse
    modeloDistribuicaoCodigo?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RepasseUncheckedUpdateManyWithoutOrdemPagamentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    advogadoId?: IntFieldUpdateOperationsInput | number
    referenciaCompetencia?: StringFieldUpdateOperationsInput | string
    valorDevido?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorPago?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dataPagamento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saldoAReceber?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    origem?: EnumOrigemRepasseFieldUpdateOperationsInput | $Enums.OrigemRepasse
    modeloDistribuicaoCodigo?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RepasseCreateManyAdvogadoInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ordemPagamentoId?: number | null
    referenciaCompetencia: string
    valorDevido: Decimal | DecimalJsLike | number | string
    valorPago?: Decimal | DecimalJsLike | number | string | null
    dataPagamento?: Date | string | null
    saldoAReceber?: Decimal | DecimalJsLike | number | string | null
    origem: $Enums.OrigemRepasse
    modeloDistribuicaoCodigo?: string | null
    observacoes?: string | null
  }

  export type RepasseUpdateWithoutAdvogadoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenciaCompetencia?: StringFieldUpdateOperationsInput | string
    valorDevido?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorPago?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dataPagamento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saldoAReceber?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    origem?: EnumOrigemRepasseFieldUpdateOperationsInput | $Enums.OrigemRepasse
    modeloDistribuicaoCodigo?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    ordemPagamento?: OrdemPagamentoUpdateOneWithoutRepassesNestedInput
  }

  export type RepasseUncheckedUpdateWithoutAdvogadoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordemPagamentoId?: NullableIntFieldUpdateOperationsInput | number | null
    referenciaCompetencia?: StringFieldUpdateOperationsInput | string
    valorDevido?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorPago?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dataPagamento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saldoAReceber?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    origem?: EnumOrigemRepasseFieldUpdateOperationsInput | $Enums.OrigemRepasse
    modeloDistribuicaoCodigo?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RepasseUncheckedUpdateManyWithoutAdvogadoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordemPagamentoId?: NullableIntFieldUpdateOperationsInput | number | null
    referenciaCompetencia?: StringFieldUpdateOperationsInput | string
    valorDevido?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valorPago?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dataPagamento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saldoAReceber?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    origem?: EnumOrigemRepasseFieldUpdateOperationsInput | $Enums.OrigemRepasse
    modeloDistribuicaoCodigo?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use ClienteCountOutputTypeDefaultArgs instead
     */
    export type ClienteCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClienteCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrdemPagamentoCountOutputTypeDefaultArgs instead
     */
    export type OrdemPagamentoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrdemPagamentoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdvogadoCountOutputTypeDefaultArgs instead
     */
    export type AdvogadoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdvogadoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClienteDefaultArgs instead
     */
    export type ClienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClienteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrdemPagamentoDefaultArgs instead
     */
    export type OrdemPagamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrdemPagamentoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PagamentoDefaultArgs instead
     */
    export type PagamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PagamentoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdvogadoDefaultArgs instead
     */
    export type AdvogadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdvogadoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RepasseDefaultArgs instead
     */
    export type RepasseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RepasseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EstagiarioDefaultArgs instead
     */
    export type EstagiarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EstagiarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PrestadorServicoDefaultArgs instead
     */
    export type PrestadorServicoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PrestadorServicoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioDefaultArgs instead
     */
    export type UsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConfiguracaoCalculoDefaultArgs instead
     */
    export type ConfiguracaoCalculoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConfiguracaoCalculoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModeloDistribuicaoDefaultArgs instead
     */
    export type ModeloDistribuicaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModeloDistribuicaoDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}